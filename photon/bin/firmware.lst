
/Users/nrobinson/comp-sci/code/photon/bin/firmware.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000018f8  080a0018  080a0018  00008018  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .backup       00000004  40024000  080a1910  0000c000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .data         00000078  20000300  080a1914  00010300  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          0000026c  20000378  20000378  00018378  2**2
                  ALLOC
  5 .module_info_suffix 00000028  080a198c  080a198c  0001198c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .module_info_crc 00000004  080a19b4  080a19b4  000119b4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .debug_info   0007b59b  00000000  00000000  000119b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0001033b  00000000  00000000  0008cf53  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000b843  00000000  00000000  0009d28e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00001838  00000000  00000000  000a8ad1  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000024c8  00000000  00000000  000aa309  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  000210d1  00000000  00000000  000ac7d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0001f0b9  00000000  00000000  000cd8a2  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0006ca6f  00000000  00000000  000ec95b  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00007834  00000000  00000000  001593cc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080a0018 <user_part_module>:
 80a0018:	94 16 0a 08                                         ....

080a001c <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a001c:	4809      	ldr	r0, [pc, #36]	; (80a0044 <module_user_pre_init+0x28>)
 80a001e:	490a      	ldr	r1, [pc, #40]	; (80a0048 <module_user_pre_init+0x2c>)
extern constructor_ptr_t link_constructors_end;

/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {
 80a0020:	b508      	push	{r3, lr}

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0022:	4288      	cmp	r0, r1
 80a0024:	d005      	beq.n	80a0032 <module_user_pre_init+0x16>
 80a0026:	4a09      	ldr	r2, [pc, #36]	; (80a004c <module_user_pre_init+0x30>)
 80a0028:	4282      	cmp	r2, r0
 80a002a:	d002      	beq.n	80a0032 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a002c:	1a12      	subs	r2, r2, r0
 80a002e:	f001 fa57 	bl	80a14e0 <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a0032:	4807      	ldr	r0, [pc, #28]	; (80a0050 <module_user_pre_init+0x34>)
 80a0034:	4a07      	ldr	r2, [pc, #28]	; (80a0054 <module_user_pre_init+0x38>)
 80a0036:	2100      	movs	r1, #0
 80a0038:	1a12      	subs	r2, r2, r0
 80a003a:	f001 fa5c 	bl	80a14f6 <memset>
    return &link_heap_start;
}
 80a003e:	4806      	ldr	r0, [pc, #24]	; (80a0058 <module_user_pre_init+0x3c>)
 80a0040:	bd08      	pop	{r3, pc}
 80a0042:	bf00      	nop
 80a0044:	20000300 	.word	0x20000300
 80a0048:	080a1914 	.word	0x080a1914
 80a004c:	20000378 	.word	0x20000378
 80a0050:	20000378 	.word	0x20000378
 80a0054:	200005e4 	.word	0x200005e4
 80a0058:	200005e4 	.word	0x200005e4

080a005c <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a005c:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
 80a005e:	f001 f843 	bl	80a10e8 <module_user_init_hook>

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0062:	4b07      	ldr	r3, [pc, #28]	; (80a0080 <module_user_init+0x24>)
 80a0064:	4c07      	ldr	r4, [pc, #28]	; (80a0084 <module_user_init+0x28>)
 80a0066:	461e      	mov	r6, r3
 80a0068:	1ae4      	subs	r4, r4, r3
 80a006a:	08a4      	lsrs	r4, r4, #2
 80a006c:	2500      	movs	r5, #0
 80a006e:	42a5      	cmp	r5, r4
 80a0070:	d004      	beq.n	80a007c <module_user_init+0x20>
    {
        link_constructors_location[ctor_num]();
 80a0072:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80a0076:	4798      	blx	r3
{
    module_user_init_hook();

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0078:	3501      	adds	r5, #1
 80a007a:	e7f8      	b.n	80a006e <module_user_init+0x12>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a007c:	bd70      	pop	{r4, r5, r6, pc}
 80a007e:	bf00      	nop
 80a0080:	080a18b8 	.word	0x080a18b8
 80a0084:	080a1910 	.word	0x080a1910

080a0088 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a0088:	f000 b928 	b.w	80a02dc <setup>

080a008c <module_user_loop>:
}

void module_user_loop() {
 80a008c:	b508      	push	{r3, lr}
    loop();
 80a008e:	f000 f99f 	bl	80a03d0 <loop>
    _post_loop();
}
 80a0092:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    setup();
}

void module_user_loop() {
    loop();
    _post_loop();
 80a0096:	f001 b811 	b.w	80a10bc <_post_loop>

080a009a <_ZdlPv>:
	return malloc(size);
}

void operator delete(void *p)
{
	free(p);
 80a009a:	f000 bb21 	b.w	80a06e0 <free>

080a009e <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
 80a009e:	7800      	ldrb	r0, [r0, #0]
 80a00a0:	fab0 f080 	clz	r0, r0
 80a00a4:	0940      	lsrs	r0, r0, #5
 80a00a6:	4770      	bx	lr

080a00a8 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
 80a00a8:	2301      	movs	r3, #1
 80a00aa:	7003      	strb	r3, [r0, #0]
 80a00ac:	4770      	bx	lr
	...

080a00b0 <_Z8printLcd6String>:

String readString;


int printLcd(String text)
{
 80a00b0:	b530      	push	{r4, r5, lr}
 80a00b2:	b085      	sub	sp, #20
 80a00b4:	4605      	mov	r5, r0
  Serial1.println("print " + text);
 80a00b6:	f000 ff4b 	bl	80a0f50 <_Z22__fetch_global_Serial1v>

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a00ba:	490a      	ldr	r1, [pc, #40]	; (80a00e4 <_Z8printLcd6String+0x34>)
 80a00bc:	4604      	mov	r4, r0
 80a00be:	4668      	mov	r0, sp
 80a00c0:	f000 fd74 	bl	80a0bac <_ZN6StringC1EPKc>
 80a00c4:	4629      	mov	r1, r5
 80a00c6:	4668      	mov	r0, sp
 80a00c8:	f000 fde3 	bl	80a0c92 <_ZplRK15StringSumHelperRK6String>
 80a00cc:	4603      	mov	r3, r0
 80a00ce:	4620      	mov	r0, r4
 80a00d0:	6819      	ldr	r1, [r3, #0]
 80a00d2:	f000 fc8e 	bl	80a09f2 <_ZN5Print7printlnEPKc>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a00d6:	4668      	mov	r0, sp
 80a00d8:	f000 fd26 	bl	80a0b28 <_ZN6StringD1Ev>
  return 1;
}
 80a00dc:	2001      	movs	r0, #1
 80a00de:	b005      	add	sp, #20
 80a00e0:	bd30      	pop	{r4, r5, pc}
 80a00e2:	bf00      	nop
 80a00e4:	080a16a8 	.word	0x080a16a8

080a00e8 <_Z4move6String>:

  return valuedata;
}

int move(String command)
{
 80a00e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a00ec:	4604      	mov	r4, r0
 80a00ee:	b09c      	sub	sp, #112	; 0x70
// 151 151 151 151
String nanoCommand = command.substring(0,7);
 80a00f0:	2307      	movs	r3, #7
 80a00f2:	4621      	mov	r1, r4
 80a00f4:	2200      	movs	r2, #0
 80a00f6:	4668      	mov	r0, sp
 80a00f8:	f000 fe14 	bl	80a0d24 <_ZNK6String9substringEjj>
Serial.println(nanoCommand);
 80a00fc:	f000 ff84 	bl	80a1008 <_Z20_fetch_global_serialv>
 80a0100:	9900      	ldr	r1, [sp, #0]
 80a0102:	f000 fc76 	bl	80a09f2 <_ZN5Print7printlnEPKc>
String photonCommand = command.substring(8);
 80a0106:	2208      	movs	r2, #8
 80a0108:	4621      	mov	r1, r4
 80a010a:	a804      	add	r0, sp, #16
 80a010c:	f000 fe32 	bl	80a0d74 <_ZNK6String9substringEj>
Serial.println(photonCommand);
 80a0110:	f000 ff7a 	bl	80a1008 <_Z20_fetch_global_serialv>
 80a0114:	9904      	ldr	r1, [sp, #16]
 80a0116:	f000 fc6c 	bl	80a09f2 <_ZN5Print7printlnEPKc>
delay(100);
 80a011a:	2064      	movs	r0, #100	; 0x64
 80a011c:	f000 faf0 	bl	80a0700 <delay>

    Serial1.println("move "+nanoCommand);
 80a0120:	f000 ff16 	bl	80a0f50 <_Z22__fetch_global_Serial1v>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a0124:	4965      	ldr	r1, [pc, #404]	; (80a02bc <_Z4move6String+0x1d4>)
 80a0126:	4604      	mov	r4, r0
 80a0128:	a818      	add	r0, sp, #96	; 0x60
 80a012a:	f000 fd3f 	bl	80a0bac <_ZN6StringC1EPKc>
 80a012e:	4669      	mov	r1, sp
 80a0130:	a818      	add	r0, sp, #96	; 0x60
 80a0132:	f000 fdae 	bl	80a0c92 <_ZplRK15StringSumHelperRK6String>
 80a0136:	4603      	mov	r3, r0
    analogWrite(BLIN1, 0);
 80a0138:	4f61      	ldr	r7, [pc, #388]	; (80a02c0 <_Z4move6String+0x1d8>)
Serial.println(nanoCommand);
String photonCommand = command.substring(8);
Serial.println(photonCommand);
delay(100);

    Serial1.println("move "+nanoCommand);
 80a013a:	6819      	ldr	r1, [r3, #0]
 80a013c:	4620      	mov	r0, r4
 80a013e:	f000 fc58 	bl	80a09f2 <_ZN5Print7printlnEPKc>
    analogWrite(BLIN1, 0);
    analogWrite(BLIN2, 0);
 80a0142:	4e60      	ldr	r6, [pc, #384]	; (80a02c4 <_Z4move6String+0x1dc>)

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a0144:	a818      	add	r0, sp, #96	; 0x60
 80a0146:	f000 fcef 	bl	80a0b28 <_ZN6StringD1Ev>
    analogWrite(BRIN1, 0);
 80a014a:	4d5f      	ldr	r5, [pc, #380]	; (80a02c8 <_Z4move6String+0x1e0>)
String photonCommand = command.substring(8);
Serial.println(photonCommand);
delay(100);

    Serial1.println("move "+nanoCommand);
    analogWrite(BLIN1, 0);
 80a014c:	8838      	ldrh	r0, [r7, #0]
 80a014e:	2100      	movs	r1, #0
 80a0150:	f001 f81b 	bl	80a118a <_Z11analogWritett>
    analogWrite(BLIN2, 0);
    analogWrite(BRIN1, 0);
    analogWrite(BRIN2, 0);
 80a0154:	4c5d      	ldr	r4, [pc, #372]	; (80a02cc <_Z4move6String+0x1e4>)
Serial.println(photonCommand);
delay(100);

    Serial1.println("move "+nanoCommand);
    analogWrite(BLIN1, 0);
    analogWrite(BLIN2, 0);
 80a0156:	8830      	ldrh	r0, [r6, #0]
 80a0158:	2100      	movs	r1, #0
 80a015a:	f001 f816 	bl	80a118a <_Z11analogWritett>
    analogWrite(BRIN1, 0);
 80a015e:	8828      	ldrh	r0, [r5, #0]
 80a0160:	2100      	movs	r1, #0
 80a0162:	f001 f812 	bl	80a118a <_Z11analogWritett>
    analogWrite(BRIN2, 0);
 80a0166:	8820      	ldrh	r0, [r4, #0]
 80a0168:	2100      	movs	r1, #0
 80a016a:	f001 f80e 	bl	80a118a <_Z11analogWritett>

    // move 151 151
    String BLValue = photonCommand.substring(0,3);
 80a016e:	2303      	movs	r3, #3
 80a0170:	a808      	add	r0, sp, #32
 80a0172:	a904      	add	r1, sp, #16
 80a0174:	2200      	movs	r2, #0
 80a0176:	f000 fdd5 	bl	80a0d24 <_ZNK6String9substringEjj>
    String BRValue = photonCommand.substring(4);
 80a017a:	2204      	movs	r2, #4
 80a017c:	a80c      	add	r0, sp, #48	; 0x30
 80a017e:	a904      	add	r1, sp, #16
 80a0180:	f000 fdf8 	bl	80a0d74 <_ZNK6String9substringEj>
    String BLdir = String(BLValue.charAt(0));
 80a0184:	2100      	movs	r1, #0
 80a0186:	a808      	add	r0, sp, #32
 80a0188:	f000 fdca 	bl	80a0d20 <_ZNK6String6charAtEj>
 80a018c:	4601      	mov	r1, r0
 80a018e:	a810      	add	r0, sp, #64	; 0x40
 80a0190:	f000 fd4a 	bl	80a0c28 <_ZN6StringC1Ec>
    String BRdir = String(BRValue.charAt(0));
 80a0194:	2100      	movs	r1, #0
 80a0196:	a80c      	add	r0, sp, #48	; 0x30
 80a0198:	f000 fdc2 	bl	80a0d20 <_ZNK6String6charAtEj>
 80a019c:	4601      	mov	r1, r0
 80a019e:	a814      	add	r0, sp, #80	; 0x50
 80a01a0:	f000 fd42 	bl	80a0c28 <_ZN6StringC1Ec>
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
 80a01a4:	a810      	add	r0, sp, #64	; 0x40
 80a01a6:	494a      	ldr	r1, [pc, #296]	; (80a02d0 <_Z4move6String+0x1e8>)
 80a01a8:	f000 fd80 	bl	80a0cac <_ZNK6String6equalsEPKc>

    // BL!
    if (BLdir == "1")
 80a01ac:	b188      	cbz	r0, 80a01d2 <_Z4move6String+0xea>
    {
      int speedvar = BLValue.substring(1).toInt() * 5;
 80a01ae:	a908      	add	r1, sp, #32
 80a01b0:	2201      	movs	r2, #1
 80a01b2:	a818      	add	r0, sp, #96	; 0x60
 80a01b4:	f000 fdde 	bl	80a0d74 <_ZNK6String9substringEj>
 80a01b8:	a818      	add	r0, sp, #96	; 0x60
 80a01ba:	f000 fe0d 	bl	80a0dd8 <_ZNK6String5toIntEv>
 80a01be:	4680      	mov	r8, r0
 80a01c0:	a818      	add	r0, sp, #96	; 0x60
 80a01c2:	f000 fcb1 	bl	80a0b28 <_ZN6StringD1Ev>
 80a01c6:	eb08 0188 	add.w	r1, r8, r8, lsl #2
      analogWrite(BLIN1, speedvar);
 80a01ca:	8838      	ldrh	r0, [r7, #0]
 80a01cc:	b289      	uxth	r1, r1
 80a01ce:	f000 ffdc 	bl	80a118a <_Z11analogWritett>
 80a01d2:	a810      	add	r0, sp, #64	; 0x40
 80a01d4:	493f      	ldr	r1, [pc, #252]	; (80a02d4 <_Z4move6String+0x1ec>)
 80a01d6:	f000 fd69 	bl	80a0cac <_ZNK6String6equalsEPKc>
    }

    if (BLdir == "2")
 80a01da:	b188      	cbz	r0, 80a0200 <_Z4move6String+0x118>
    {
      int speedvar = BLValue.substring(1).toInt() * 5;
 80a01dc:	a908      	add	r1, sp, #32
 80a01de:	2201      	movs	r2, #1
 80a01e0:	a818      	add	r0, sp, #96	; 0x60
 80a01e2:	f000 fdc7 	bl	80a0d74 <_ZNK6String9substringEj>
 80a01e6:	a818      	add	r0, sp, #96	; 0x60
 80a01e8:	f000 fdf6 	bl	80a0dd8 <_ZNK6String5toIntEv>
 80a01ec:	4680      	mov	r8, r0
 80a01ee:	a818      	add	r0, sp, #96	; 0x60
 80a01f0:	f000 fc9a 	bl	80a0b28 <_ZN6StringD1Ev>
 80a01f4:	eb08 0188 	add.w	r1, r8, r8, lsl #2
      analogWrite(BLIN2, speedvar);
 80a01f8:	8830      	ldrh	r0, [r6, #0]
 80a01fa:	b289      	uxth	r1, r1
 80a01fc:	f000 ffc5 	bl	80a118a <_Z11analogWritett>
 80a0200:	a810      	add	r0, sp, #64	; 0x40
 80a0202:	4935      	ldr	r1, [pc, #212]	; (80a02d8 <_Z4move6String+0x1f0>)
 80a0204:	f000 fd52 	bl	80a0cac <_ZNK6String6equalsEPKc>
    }

    if (BLdir == "0")
 80a0208:	b138      	cbz	r0, 80a021a <_Z4move6String+0x132>
    {
      analogWrite(BLIN1, 0);
 80a020a:	8838      	ldrh	r0, [r7, #0]
 80a020c:	2100      	movs	r1, #0
 80a020e:	f000 ffbc 	bl	80a118a <_Z11analogWritett>
      analogWrite(BLIN2, 0);
 80a0212:	8830      	ldrh	r0, [r6, #0]
 80a0214:	2100      	movs	r1, #0
 80a0216:	f000 ffb8 	bl	80a118a <_Z11analogWritett>
 80a021a:	a814      	add	r0, sp, #80	; 0x50
 80a021c:	492c      	ldr	r1, [pc, #176]	; (80a02d0 <_Z4move6String+0x1e8>)
 80a021e:	f000 fd45 	bl	80a0cac <_ZNK6String6equalsEPKc>
    }

    // BR!

    if (BRdir == "1")
 80a0222:	b188      	cbz	r0, 80a0248 <_Z4move6String+0x160>
    {
      int speedvar = BRValue.substring(1).toInt() * 5;
 80a0224:	a90c      	add	r1, sp, #48	; 0x30
 80a0226:	2201      	movs	r2, #1
 80a0228:	a818      	add	r0, sp, #96	; 0x60
 80a022a:	f000 fda3 	bl	80a0d74 <_ZNK6String9substringEj>
 80a022e:	a818      	add	r0, sp, #96	; 0x60
 80a0230:	f000 fdd2 	bl	80a0dd8 <_ZNK6String5toIntEv>
 80a0234:	4606      	mov	r6, r0
 80a0236:	a818      	add	r0, sp, #96	; 0x60
 80a0238:	f000 fc76 	bl	80a0b28 <_ZN6StringD1Ev>
 80a023c:	eb06 0186 	add.w	r1, r6, r6, lsl #2
      analogWrite(BRIN1, speedvar);
 80a0240:	8828      	ldrh	r0, [r5, #0]
 80a0242:	b289      	uxth	r1, r1
 80a0244:	f000 ffa1 	bl	80a118a <_Z11analogWritett>
 80a0248:	a814      	add	r0, sp, #80	; 0x50
 80a024a:	4922      	ldr	r1, [pc, #136]	; (80a02d4 <_Z4move6String+0x1ec>)
 80a024c:	f000 fd2e 	bl	80a0cac <_ZNK6String6equalsEPKc>
    }

    if (BRdir == "2")
 80a0250:	b188      	cbz	r0, 80a0276 <_Z4move6String+0x18e>
    {
      int speedvar = BRValue.substring(1).toInt() * 5;
 80a0252:	a90c      	add	r1, sp, #48	; 0x30
 80a0254:	2201      	movs	r2, #1
 80a0256:	a818      	add	r0, sp, #96	; 0x60
 80a0258:	f000 fd8c 	bl	80a0d74 <_ZNK6String9substringEj>
 80a025c:	a818      	add	r0, sp, #96	; 0x60
 80a025e:	f000 fdbb 	bl	80a0dd8 <_ZNK6String5toIntEv>
 80a0262:	4606      	mov	r6, r0
 80a0264:	a818      	add	r0, sp, #96	; 0x60
 80a0266:	f000 fc5f 	bl	80a0b28 <_ZN6StringD1Ev>
 80a026a:	eb06 0186 	add.w	r1, r6, r6, lsl #2
      analogWrite(BRIN2, speedvar);
 80a026e:	8820      	ldrh	r0, [r4, #0]
 80a0270:	b289      	uxth	r1, r1
 80a0272:	f000 ff8a 	bl	80a118a <_Z11analogWritett>
 80a0276:	a814      	add	r0, sp, #80	; 0x50
 80a0278:	4917      	ldr	r1, [pc, #92]	; (80a02d8 <_Z4move6String+0x1f0>)
 80a027a:	f000 fd17 	bl	80a0cac <_ZNK6String6equalsEPKc>
    }

    if (BRdir == "0")
 80a027e:	b138      	cbz	r0, 80a0290 <_Z4move6String+0x1a8>
    {
      analogWrite(BRIN1, 0);
 80a0280:	8828      	ldrh	r0, [r5, #0]
 80a0282:	2100      	movs	r1, #0
 80a0284:	f000 ff81 	bl	80a118a <_Z11analogWritett>
      analogWrite(BRIN2, 0);
 80a0288:	8820      	ldrh	r0, [r4, #0]
 80a028a:	2100      	movs	r1, #0
 80a028c:	f000 ff7d 	bl	80a118a <_Z11analogWritett>

    // move 151 151
    String BLValue = photonCommand.substring(0,3);
    String BRValue = photonCommand.substring(4);
    String BLdir = String(BLValue.charAt(0));
    String BRdir = String(BRValue.charAt(0));
 80a0290:	a814      	add	r0, sp, #80	; 0x50
 80a0292:	f000 fc49 	bl	80a0b28 <_ZN6StringD1Ev>
    analogWrite(BRIN2, 0);

    // move 151 151
    String BLValue = photonCommand.substring(0,3);
    String BRValue = photonCommand.substring(4);
    String BLdir = String(BLValue.charAt(0));
 80a0296:	a810      	add	r0, sp, #64	; 0x40
 80a0298:	f000 fc46 	bl	80a0b28 <_ZN6StringD1Ev>
    analogWrite(BRIN1, 0);
    analogWrite(BRIN2, 0);

    // move 151 151
    String BLValue = photonCommand.substring(0,3);
    String BRValue = photonCommand.substring(4);
 80a029c:	a80c      	add	r0, sp, #48	; 0x30
 80a029e:	f000 fc43 	bl	80a0b28 <_ZN6StringD1Ev>
    analogWrite(BLIN2, 0);
    analogWrite(BRIN1, 0);
    analogWrite(BRIN2, 0);

    // move 151 151
    String BLValue = photonCommand.substring(0,3);
 80a02a2:	a808      	add	r0, sp, #32
 80a02a4:	f000 fc40 	bl	80a0b28 <_ZN6StringD1Ev>
int move(String command)
{
// 151 151 151 151
String nanoCommand = command.substring(0,7);
Serial.println(nanoCommand);
String photonCommand = command.substring(8);
 80a02a8:	a804      	add	r0, sp, #16
 80a02aa:	f000 fc3d 	bl	80a0b28 <_ZN6StringD1Ev>
      analogWrite(BRIN1, 0);
      analogWrite(BRIN2, 0);
    }


return 1;
 80a02ae:	4668      	mov	r0, sp
 80a02b0:	f000 fc3a 	bl	80a0b28 <_ZN6StringD1Ev>
}
 80a02b4:	2001      	movs	r0, #1
 80a02b6:	b01c      	add	sp, #112	; 0x70
 80a02b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a02bc:	080a16af 	.word	0x080a16af
 80a02c0:	20000304 	.word	0x20000304
 80a02c4:	2000037c 	.word	0x2000037c
 80a02c8:	20000300 	.word	0x20000300
 80a02cc:	20000308 	.word	0x20000308
 80a02d0:	080a16b5 	.word	0x080a16b5
 80a02d4:	080a16b7 	.word	0x080a16b7
 80a02d8:	080a16ba 	.word	0x080a16ba

080a02dc <setup>:

void setup()
{
 80a02dc:	b510      	push	{r4, lr}
Serial1.begin(9600);
 80a02de:	f000 fe37 	bl	80a0f50 <_Z22__fetch_global_Serial1v>
 80a02e2:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a02e6:	f000 fe2d 	bl	80a0f44 <_ZN11USARTSerial5beginEm>
Serial.begin(9600);
 80a02ea:	f000 fe8d 	bl	80a1008 <_Z20_fetch_global_serialv>
 80a02ee:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a02f2:	f000 fe85 	bl	80a1000 <_ZN9USBSerial5beginEl>
pinMode(BLIN1, OUTPUT);
 80a02f6:	4b10      	ldr	r3, [pc, #64]	; (80a0338 <setup+0x5c>)
 80a02f8:	2101      	movs	r1, #1
 80a02fa:	8818      	ldrh	r0, [r3, #0]
 80a02fc:	f000 ff34 	bl	80a1168 <pinMode>
pinMode(BLIN2, OUTPUT);
 80a0300:	4b0e      	ldr	r3, [pc, #56]	; (80a033c <setup+0x60>)
 80a0302:	2101      	movs	r1, #1
 80a0304:	8818      	ldrh	r0, [r3, #0]
 80a0306:	f000 ff2f 	bl	80a1168 <pinMode>

pinMode(BRIN1, OUTPUT);
 80a030a:	4b0d      	ldr	r3, [pc, #52]	; (80a0340 <setup+0x64>)
 80a030c:	2101      	movs	r1, #1
 80a030e:	8818      	ldrh	r0, [r3, #0]
 80a0310:	f000 ff2a 	bl	80a1168 <pinMode>
pinMode(BRIN2, OUTPUT);
 80a0314:	4b0b      	ldr	r3, [pc, #44]	; (80a0344 <setup+0x68>)
        return _function(name, args...);
    }

    static bool _function(const char *funcKey, user_function_int_str_t* func)
    {
        return CLOUD_FN(register_function(call_raw_user_function, (void*)func, funcKey), false);
 80a0316:	4c0c      	ldr	r4, [pc, #48]	; (80a0348 <setup+0x6c>)
 80a0318:	8818      	ldrh	r0, [r3, #0]
 80a031a:	2101      	movs	r1, #1
 80a031c:	f000 ff24 	bl	80a1168 <pinMode>
 80a0320:	4620      	mov	r0, r4
 80a0322:	490a      	ldr	r1, [pc, #40]	; (80a034c <setup+0x70>)
 80a0324:	4a0a      	ldr	r2, [pc, #40]	; (80a0350 <setup+0x74>)
 80a0326:	f000 fa35 	bl	80a0794 <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
 80a032a:	4620      	mov	r0, r4

Particle.function("move", move);
Particle.function("print", printLcd);
}
 80a032c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a0330:	4908      	ldr	r1, [pc, #32]	; (80a0354 <setup+0x78>)
 80a0332:	4a09      	ldr	r2, [pc, #36]	; (80a0358 <setup+0x7c>)
 80a0334:	f000 ba2e 	b.w	80a0794 <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
 80a0338:	20000304 	.word	0x20000304
 80a033c:	2000037c 	.word	0x2000037c
 80a0340:	20000300 	.word	0x20000300
 80a0344:	20000308 	.word	0x20000308
 80a0348:	080a0769 	.word	0x080a0769
 80a034c:	080a00e9 	.word	0x080a00e9
 80a0350:	080a16bc 	.word	0x080a16bc
 80a0354:	080a00b1 	.word	0x080a00b1
 80a0358:	080a16c1 	.word	0x080a16c1

080a035c <_Z12parseCommand6String>:



void parseCommand(String command)
{
 80a035c:	b530      	push	{r4, r5, lr}
 80a035e:	4604      	mov	r4, r0
 80a0360:	b085      	sub	sp, #20
if (command.startsWith("move"))
 80a0362:	4919      	ldr	r1, [pc, #100]	; (80a03c8 <_Z12parseCommand6String+0x6c>)
 80a0364:	4668      	mov	r0, sp
 80a0366:	f000 fc21 	bl	80a0bac <_ZN6StringC1EPKc>
 80a036a:	4620      	mov	r0, r4
 80a036c:	4669      	mov	r1, sp
 80a036e:	f000 fcc5 	bl	80a0cfc <_ZNK6String10startsWithERKS_>
 80a0372:	4605      	mov	r5, r0
 80a0374:	4668      	mov	r0, sp
 80a0376:	f000 fbd7 	bl	80a0b28 <_ZN6StringD1Ev>
 80a037a:	b155      	cbz	r5, 80a0392 <_Z12parseCommand6String+0x36>
{
  move(command.substring(5));
 80a037c:	4668      	mov	r0, sp
 80a037e:	4621      	mov	r1, r4
 80a0380:	2205      	movs	r2, #5
 80a0382:	f000 fcf7 	bl	80a0d74 <_ZNK6String9substringEj>
 80a0386:	4668      	mov	r0, sp
 80a0388:	f7ff feae 	bl	80a00e8 <_Z4move6String>
 80a038c:	4668      	mov	r0, sp
 80a038e:	f000 fbcb 	bl	80a0b28 <_ZN6StringD1Ev>
}

if (command.startsWith("print"))
 80a0392:	490e      	ldr	r1, [pc, #56]	; (80a03cc <_Z12parseCommand6String+0x70>)
 80a0394:	4668      	mov	r0, sp
 80a0396:	f000 fc09 	bl	80a0bac <_ZN6StringC1EPKc>
 80a039a:	4620      	mov	r0, r4
 80a039c:	4669      	mov	r1, sp
 80a039e:	f000 fcad 	bl	80a0cfc <_ZNK6String10startsWithERKS_>
 80a03a2:	4605      	mov	r5, r0
 80a03a4:	4668      	mov	r0, sp
 80a03a6:	f000 fbbf 	bl	80a0b28 <_ZN6StringD1Ev>
 80a03aa:	b155      	cbz	r5, 80a03c2 <_Z12parseCommand6String+0x66>
{
  printLcd(command.substring(6));
 80a03ac:	4668      	mov	r0, sp
 80a03ae:	4621      	mov	r1, r4
 80a03b0:	2206      	movs	r2, #6
 80a03b2:	f000 fcdf 	bl	80a0d74 <_ZNK6String9substringEj>
 80a03b6:	4668      	mov	r0, sp
 80a03b8:	f7ff fe7a 	bl	80a00b0 <_Z8printLcd6String>
 80a03bc:	4668      	mov	r0, sp
 80a03be:	f000 fbb3 	bl	80a0b28 <_ZN6StringD1Ev>
}

}
 80a03c2:	b005      	add	sp, #20
 80a03c4:	bd30      	pop	{r4, r5, pc}
 80a03c6:	bf00      	nop
 80a03c8:	080a16bc 	.word	0x080a16bc
 80a03cc:	080a16c1 	.word	0x080a16c1

080a03d0 <loop>:

void loop()
{
 80a03d0:	b51f      	push	{r0, r1, r2, r3, r4, lr}

    while (Serial.available())
 80a03d2:	f000 fe19 	bl	80a1008 <_Z20_fetch_global_serialv>
 80a03d6:	6803      	ldr	r3, [r0, #0]
 80a03d8:	691b      	ldr	r3, [r3, #16]
 80a03da:	4798      	blx	r3
 80a03dc:	b160      	cbz	r0, 80a03f8 <loop+0x28>
    {
      delay(3);
 80a03de:	2003      	movs	r0, #3
 80a03e0:	f000 f98e 	bl	80a0700 <delay>
      char c = Serial.read();
 80a03e4:	f000 fe10 	bl	80a1008 <_Z20_fetch_global_serialv>
 80a03e8:	6803      	ldr	r3, [r0, #0]
 80a03ea:	695b      	ldr	r3, [r3, #20]
 80a03ec:	4798      	blx	r3

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
	String & operator += (char c)			{concat(c); return (*this);}
 80a03ee:	b2c1      	uxtb	r1, r0
 80a03f0:	480f      	ldr	r0, [pc, #60]	; (80a0430 <loop+0x60>)
 80a03f2:	f000 fc41 	bl	80a0c78 <_ZN6String6concatEc>
 80a03f6:	e7ec      	b.n	80a03d2 <loop+0x2>
      readString += c;
    }

    readString.trim();
 80a03f8:	4c0d      	ldr	r4, [pc, #52]	; (80a0430 <loop+0x60>)
 80a03fa:	4620      	mov	r0, r4
 80a03fc:	f000 fcc1 	bl	80a0d82 <_ZN6String4trimEv>

    if (readString.length() > 0)
 80a0400:	68a3      	ldr	r3, [r4, #8]
 80a0402:	b193      	cbz	r3, 80a042a <loop+0x5a>
    {
      parseCommand(readString);
 80a0404:	4621      	mov	r1, r4
 80a0406:	4668      	mov	r0, sp
 80a0408:	f000 fbf2 	bl	80a0bf0 <_ZN6StringC1ERKS_>
 80a040c:	4668      	mov	r0, sp
 80a040e:	f7ff ffa5 	bl	80a035c <_Z12parseCommand6String>
 80a0412:	4668      	mov	r0, sp
 80a0414:	f000 fb88 	bl	80a0b28 <_ZN6StringD1Ev>
      Serial.println(readString);
 80a0418:	f000 fdf6 	bl	80a1008 <_Z20_fetch_global_serialv>
 80a041c:	6821      	ldr	r1, [r4, #0]
 80a041e:	f000 fae8 	bl	80a09f2 <_ZN5Print7printlnEPKc>

      readString = "";
 80a0422:	4620      	mov	r0, r4
 80a0424:	4903      	ldr	r1, [pc, #12]	; (80a0434 <loop+0x64>)
 80a0426:	f000 fbee 	bl	80a0c06 <_ZN6StringaSEPKc>
    }
}
 80a042a:	b004      	add	sp, #16
 80a042c:	bd10      	pop	{r4, pc}
 80a042e:	bf00      	nop
 80a0430:	2000038c 	.word	0x2000038c
 80a0434:	080a16b4 	.word	0x080a16b4

080a0438 <_GLOBAL__sub_I_BLIN1>:
{
public:
    typedef uint8_t flag_t;
    inline SleepNetworkFlag(SystemSleepNetwork f) : SleepNetworkFlag(static_cast<flag_t>(f)) {}

    inline SleepNetworkFlag(flag_t flag) : flag_(flag) {}
 80a0438:	4b0e      	ldr	r3, [pc, #56]	; (80a0474 <_GLOBAL__sub_I_BLIN1+0x3c>)
 80a043a:	2200      	movs	r2, #0
 80a043c:	490e      	ldr	r1, [pc, #56]	; (80a0478 <_GLOBAL__sub_I_BLIN1+0x40>)
 80a043e:	b510      	push	{r4, lr}
 80a0440:	701a      	strb	r2, [r3, #0]
 80a0442:	2301      	movs	r3, #1
 80a0444:	700b      	strb	r3, [r1, #0]

class PublishFlag
{
public:
	typedef uint8_t flag_t;
	PublishFlag(flag_t flag) : flag_(flag) {}
 80a0446:	490d      	ldr	r1, [pc, #52]	; (80a047c <_GLOBAL__sub_I_BLIN1+0x44>)
int BLIN2 = D0;

int BRIN1 = D2;
int BRIN2 = D3;

String readString;
 80a0448:	4c0d      	ldr	r4, [pc, #52]	; (80a0480 <_GLOBAL__sub_I_BLIN1+0x48>)
 80a044a:	700a      	strb	r2, [r1, #0]
 80a044c:	4a0d      	ldr	r2, [pc, #52]	; (80a0484 <_GLOBAL__sub_I_BLIN1+0x4c>)
 80a044e:	7013      	strb	r3, [r2, #0]
 80a0450:	4b0d      	ldr	r3, [pc, #52]	; (80a0488 <_GLOBAL__sub_I_BLIN1+0x50>)
 80a0452:	2202      	movs	r2, #2
 80a0454:	701a      	strb	r2, [r3, #0]
inline int32_t pinReadFast(pin_t _pin)
{
	return ((PIN_MAP[_pin].gpio_peripheral->IDR & PIN_MAP[_pin].gpio_pin) == 0 ? LOW : HIGH);
}
#elif defined(STM32F2XX)
static STM32_Pin_Info* PIN_MAP = HAL_Pin_Map();
 80a0456:	f000 f831 	bl	80a04bc <HAL_Pin_Map>
 80a045a:	4b0c      	ldr	r3, [pc, #48]	; (80a048c <_GLOBAL__sub_I_BLIN1+0x54>)
 80a045c:	490c      	ldr	r1, [pc, #48]	; (80a0490 <_GLOBAL__sub_I_BLIN1+0x58>)
 80a045e:	6018      	str	r0, [r3, #0]
 80a0460:	4620      	mov	r0, r4
 80a0462:	f000 fba3 	bl	80a0bac <_ZN6StringC1EPKc>
 80a0466:	4620      	mov	r0, r4
      parseCommand(readString);
      Serial.println(readString);

      readString = "";
    }
}
 80a0468:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
int BLIN2 = D0;

int BRIN1 = D2;
int BRIN2 = D3;

String readString;
 80a046c:	4909      	ldr	r1, [pc, #36]	; (80a0494 <_GLOBAL__sub_I_BLIN1+0x5c>)
 80a046e:	4a0a      	ldr	r2, [pc, #40]	; (80a0498 <_GLOBAL__sub_I_BLIN1+0x60>)
 80a0470:	f000 bf50 	b.w	80a1314 <__aeabi_atexit>
 80a0474:	20000383 	.word	0x20000383
 80a0478:	20000388 	.word	0x20000388
 80a047c:	20000381 	.word	0x20000381
 80a0480:	2000038c 	.word	0x2000038c
 80a0484:	20000382 	.word	0x20000382
 80a0488:	20000380 	.word	0x20000380
 80a048c:	20000384 	.word	0x20000384
 80a0490:	080a16b4 	.word	0x080a16b4
 80a0494:	080a0b29 	.word	0x080a0b29
 80a0498:	20000378 	.word	0x20000378

080a049c <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
 80a049c:	b508      	push	{r3, lr}
 80a049e:	4b02      	ldr	r3, [pc, #8]	; (80a04a8 <HAL_RNG_GetRandomNumber+0xc>)
 80a04a0:	681b      	ldr	r3, [r3, #0]
 80a04a2:	685b      	ldr	r3, [r3, #4]
 80a04a4:	9301      	str	r3, [sp, #4]
 80a04a6:	bd08      	pop	{r3, pc}
 80a04a8:	0806019c 	.word	0x0806019c

080a04ac <HAL_Timer_Get_Milli_Seconds>:
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
 80a04ac:	b508      	push	{r3, lr}
 80a04ae:	4b02      	ldr	r3, [pc, #8]	; (80a04b8 <HAL_Timer_Get_Milli_Seconds+0xc>)
 80a04b0:	681b      	ldr	r3, [r3, #0]
 80a04b2:	695b      	ldr	r3, [r3, #20]
 80a04b4:	9301      	str	r3, [sp, #4]
 80a04b6:	bd08      	pop	{r3, pc}
 80a04b8:	0806019c 	.word	0x0806019c

080a04bc <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, STM32_Pin_Info*(void))
 80a04bc:	b508      	push	{r3, lr}
 80a04be:	4b02      	ldr	r3, [pc, #8]	; (80a04c8 <HAL_Pin_Map+0xc>)
 80a04c0:	681b      	ldr	r3, [r3, #0]
 80a04c2:	681b      	ldr	r3, [r3, #0]
 80a04c4:	9301      	str	r3, [sp, #4]
 80a04c6:	bd08      	pop	{r3, pc}
 80a04c8:	080601b0 	.word	0x080601b0

080a04cc <HAL_Validate_Pin_Function>:
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
 80a04cc:	b508      	push	{r3, lr}
 80a04ce:	4b02      	ldr	r3, [pc, #8]	; (80a04d8 <HAL_Validate_Pin_Function+0xc>)
 80a04d0:	681b      	ldr	r3, [r3, #0]
 80a04d2:	685b      	ldr	r3, [r3, #4]
 80a04d4:	9301      	str	r3, [sp, #4]
 80a04d6:	bd08      	pop	{r3, pc}
 80a04d8:	080601b0 	.word	0x080601b0

080a04dc <HAL_Pin_Mode>:
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
 80a04dc:	b508      	push	{r3, lr}
 80a04de:	4b02      	ldr	r3, [pc, #8]	; (80a04e8 <HAL_Pin_Mode+0xc>)
 80a04e0:	681b      	ldr	r3, [r3, #0]
 80a04e2:	689b      	ldr	r3, [r3, #8]
 80a04e4:	9301      	str	r3, [sp, #4]
 80a04e6:	bd08      	pop	{r3, pc}
 80a04e8:	080601b0 	.word	0x080601b0

080a04ec <HAL_Get_Pin_Mode>:
DYNALIB_FN(3, hal_gpio, HAL_Get_Pin_Mode, PinMode(pin_t))
 80a04ec:	b508      	push	{r3, lr}
 80a04ee:	4b02      	ldr	r3, [pc, #8]	; (80a04f8 <HAL_Get_Pin_Mode+0xc>)
 80a04f0:	681b      	ldr	r3, [r3, #0]
 80a04f2:	68db      	ldr	r3, [r3, #12]
 80a04f4:	9301      	str	r3, [sp, #4]
 80a04f6:	bd08      	pop	{r3, pc}
 80a04f8:	080601b0 	.word	0x080601b0

080a04fc <HAL_DAC_Write>:
DYNALIB_FN(6, hal_gpio, HAL_Interrupts_Attach, void(uint16_t, HAL_InterruptHandler, void*, InterruptMode, HAL_InterruptExtraConfiguration*))
DYNALIB_FN(7, hal_gpio, HAL_Interrupts_Detach, void(uint16_t))
DYNALIB_FN(8, hal_gpio, HAL_Interrupts_Enable_All, void(void))
DYNALIB_FN(9, hal_gpio, HAL_Interrupts_Disable_All, void(void))

DYNALIB_FN(10, hal_gpio, HAL_DAC_Write, void(pin_t, uint16_t))
 80a04fc:	b508      	push	{r3, lr}
 80a04fe:	4b02      	ldr	r3, [pc, #8]	; (80a0508 <HAL_DAC_Write+0xc>)
 80a0500:	681b      	ldr	r3, [r3, #0]
 80a0502:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a0504:	9301      	str	r3, [sp, #4]
 80a0506:	bd08      	pop	{r3, pc}
 80a0508:	080601b0 	.word	0x080601b0

080a050c <HAL_PWM_Write>:
DYNALIB_FN(11, hal_gpio, HAL_ADC_Set_Sample_Time, void(uint8_t))
DYNALIB_FN(12, hal_gpio, HAL_ADC_Read, int32_t(uint16_t))

DYNALIB_FN(13, hal_gpio, HAL_PWM_Write, void(uint16_t, uint8_t))
 80a050c:	b508      	push	{r3, lr}
 80a050e:	4b02      	ldr	r3, [pc, #8]	; (80a0518 <HAL_PWM_Write+0xc>)
 80a0510:	681b      	ldr	r3, [r3, #0]
 80a0512:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a0514:	9301      	str	r3, [sp, #4]
 80a0516:	bd08      	pop	{r3, pc}
 80a0518:	080601b0 	.word	0x080601b0

080a051c <HAL_I2C_Write_Data>:
DYNALIB_FN(BASE_IDX + 3, hal_i2c, HAL_I2C_Begin, void(HAL_I2C_Interface, I2C_Mode, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 4, hal_i2c, HAL_I2C_End, void(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, HAL_I2C_Request_Data, uint32_t(HAL_I2C_Interface, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 6, hal_i2c, HAL_I2C_Begin_Transmission, void(HAL_I2C_Interface, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 7, hal_i2c, HAL_I2C_End_Transmission, uint8_t(HAL_I2C_Interface, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 8, hal_i2c, HAL_I2C_Write_Data, uint32_t(HAL_I2C_Interface, uint8_t, void*))
 80a051c:	b508      	push	{r3, lr}
 80a051e:	4b02      	ldr	r3, [pc, #8]	; (80a0528 <HAL_I2C_Write_Data+0xc>)
 80a0520:	681b      	ldr	r3, [r3, #0]
 80a0522:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a0524:	9301      	str	r3, [sp, #4]
 80a0526:	bd08      	pop	{r3, pc}
 80a0528:	080601ac 	.word	0x080601ac

080a052c <HAL_I2C_Available_Data>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, HAL_I2C_Available_Data, int32_t(HAL_I2C_Interface, void*))
 80a052c:	b508      	push	{r3, lr}
 80a052e:	4b02      	ldr	r3, [pc, #8]	; (80a0538 <HAL_I2C_Available_Data+0xc>)
 80a0530:	681b      	ldr	r3, [r3, #0]
 80a0532:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a0534:	9301      	str	r3, [sp, #4]
 80a0536:	bd08      	pop	{r3, pc}
 80a0538:	080601ac 	.word	0x080601ac

080a053c <HAL_I2C_Read_Data>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, HAL_I2C_Read_Data, int32_t(HAL_I2C_Interface, void*))
 80a053c:	b508      	push	{r3, lr}
 80a053e:	4b02      	ldr	r3, [pc, #8]	; (80a0548 <HAL_I2C_Read_Data+0xc>)
 80a0540:	681b      	ldr	r3, [r3, #0]
 80a0542:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a0544:	9301      	str	r3, [sp, #4]
 80a0546:	bd08      	pop	{r3, pc}
 80a0548:	080601ac 	.word	0x080601ac

080a054c <HAL_I2C_Peek_Data>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, HAL_I2C_Peek_Data, int32_t(HAL_I2C_Interface, void*))
 80a054c:	b508      	push	{r3, lr}
 80a054e:	4b02      	ldr	r3, [pc, #8]	; (80a0558 <HAL_I2C_Peek_Data+0xc>)
 80a0550:	681b      	ldr	r3, [r3, #0]
 80a0552:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a0554:	9301      	str	r3, [sp, #4]
 80a0556:	bd08      	pop	{r3, pc}
 80a0558:	080601ac 	.word	0x080601ac

080a055c <HAL_I2C_Flush_Data>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, HAL_I2C_Flush_Data, void(HAL_I2C_Interface, void*))
 80a055c:	b508      	push	{r3, lr}
 80a055e:	4b02      	ldr	r3, [pc, #8]	; (80a0568 <HAL_I2C_Flush_Data+0xc>)
 80a0560:	681b      	ldr	r3, [r3, #0]
 80a0562:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a0564:	9301      	str	r3, [sp, #4]
 80a0566:	bd08      	pop	{r3, pc}
 80a0568:	080601ac 	.word	0x080601ac

080a056c <HAL_I2C_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, HAL_I2C_Is_Enabled, bool(HAL_I2C_Interface, void*))
 80a056c:	b508      	push	{r3, lr}
 80a056e:	4b02      	ldr	r3, [pc, #8]	; (80a0578 <HAL_I2C_Is_Enabled+0xc>)
 80a0570:	681b      	ldr	r3, [r3, #0]
 80a0572:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80a0574:	9301      	str	r3, [sp, #4]
 80a0576:	bd08      	pop	{r3, pc}
 80a0578:	080601ac 	.word	0x080601ac

080a057c <HAL_I2C_Init>:
DYNALIB_FN(BASE_IDX + 14, hal_i2c, HAL_I2C_Set_Callback_On_Receive, void(HAL_I2C_Interface, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, HAL_I2C_Set_Callback_On_Request, void(HAL_I2C_Interface, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, HAL_I2C_Init, void(HAL_I2C_Interface, void*))
 80a057c:	b508      	push	{r3, lr}
 80a057e:	4b03      	ldr	r3, [pc, #12]	; (80a058c <HAL_I2C_Init+0x10>)
 80a0580:	681b      	ldr	r3, [r3, #0]
 80a0582:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a0586:	9301      	str	r3, [sp, #4]
 80a0588:	bd08      	pop	{r3, pc}
 80a058a:	0000      	.short	0x0000
 80a058c:	080601ac 	.word	0x080601ac

080a0590 <HAL_SPI_Init>:
DYNALIB_FN(2, hal_spi, HAL_SPI_Set_Bit_Order, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(3, hal_spi, HAL_SPI_Set_Data_Mode, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(4, hal_spi, HAL_SPI_Set_Clock_Divider, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(5, hal_spi, HAL_SPI_Send_Receive_Data, uint16_t(HAL_SPI_Interface, uint16_t))
DYNALIB_FN(6, hal_spi, HAL_SPI_Is_Enabled_Old, bool(void))
DYNALIB_FN(7, hal_spi, HAL_SPI_Init, void(HAL_SPI_Interface))
 80a0590:	b508      	push	{r3, lr}
 80a0592:	4b02      	ldr	r3, [pc, #8]	; (80a059c <HAL_SPI_Init+0xc>)
 80a0594:	681b      	ldr	r3, [r3, #0]
 80a0596:	69db      	ldr	r3, [r3, #28]
 80a0598:	9301      	str	r3, [sp, #4]
 80a059a:	bd08      	pop	{r3, pc}
 80a059c:	080601b4 	.word	0x080601b4

080a05a0 <HAL_SPI_Is_Enabled>:
DYNALIB_FN(8, hal_spi, HAL_SPI_Is_Enabled, bool(HAL_SPI_Interface))
 80a05a0:	b508      	push	{r3, lr}
 80a05a2:	4b02      	ldr	r3, [pc, #8]	; (80a05ac <HAL_SPI_Is_Enabled+0xc>)
 80a05a4:	681b      	ldr	r3, [r3, #0]
 80a05a6:	6a1b      	ldr	r3, [r3, #32]
 80a05a8:	9301      	str	r3, [sp, #4]
 80a05aa:	bd08      	pop	{r3, pc}
 80a05ac:	080601b4 	.word	0x080601b4

080a05b0 <USB_USART_Init>:
// GNINRAW

DYNALIB_BEGIN(hal_usart)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usart, USB_USART_Init, void(uint32_t))
 80a05b0:	b508      	push	{r3, lr}
 80a05b2:	4b02      	ldr	r3, [pc, #8]	; (80a05bc <USB_USART_Init+0xc>)
 80a05b4:	681b      	ldr	r3, [r3, #0]
 80a05b6:	681b      	ldr	r3, [r3, #0]
 80a05b8:	9301      	str	r3, [sp, #4]
 80a05ba:	bd08      	pop	{r3, pc}
 80a05bc:	080601c4 	.word	0x080601c4

080a05c0 <USB_USART_Available_Data>:
DYNALIB_FN(1, hal_usart, USB_USART_Available_Data, uint8_t(void))
 80a05c0:	b508      	push	{r3, lr}
 80a05c2:	4b02      	ldr	r3, [pc, #8]	; (80a05cc <USB_USART_Available_Data+0xc>)
 80a05c4:	681b      	ldr	r3, [r3, #0]
 80a05c6:	685b      	ldr	r3, [r3, #4]
 80a05c8:	9301      	str	r3, [sp, #4]
 80a05ca:	bd08      	pop	{r3, pc}
 80a05cc:	080601c4 	.word	0x080601c4

080a05d0 <USB_USART_Receive_Data>:
DYNALIB_FN(2, hal_usart, USB_USART_Receive_Data, int32_t(uint8_t))
 80a05d0:	b508      	push	{r3, lr}
 80a05d2:	4b02      	ldr	r3, [pc, #8]	; (80a05dc <USB_USART_Receive_Data+0xc>)
 80a05d4:	681b      	ldr	r3, [r3, #0]
 80a05d6:	689b      	ldr	r3, [r3, #8]
 80a05d8:	9301      	str	r3, [sp, #4]
 80a05da:	bd08      	pop	{r3, pc}
 80a05dc:	080601c4 	.word	0x080601c4

080a05e0 <USB_USART_Send_Data>:
DYNALIB_FN(3, hal_usart, USB_USART_Send_Data, void(uint8_t))
 80a05e0:	b508      	push	{r3, lr}
 80a05e2:	4b02      	ldr	r3, [pc, #8]	; (80a05ec <USB_USART_Send_Data+0xc>)
 80a05e4:	681b      	ldr	r3, [r3, #0]
 80a05e6:	68db      	ldr	r3, [r3, #12]
 80a05e8:	9301      	str	r3, [sp, #4]
 80a05ea:	bd08      	pop	{r3, pc}
 80a05ec:	080601c4 	.word	0x080601c4

080a05f0 <HAL_USART_Init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, HAL_USART_Init, void(HAL_USART_Serial, Ring_Buffer*, Ring_Buffer*))
 80a05f0:	b508      	push	{r3, lr}
 80a05f2:	4b02      	ldr	r3, [pc, #8]	; (80a05fc <HAL_USART_Init+0xc>)
 80a05f4:	681b      	ldr	r3, [r3, #0]
 80a05f6:	699b      	ldr	r3, [r3, #24]
 80a05f8:	9301      	str	r3, [sp, #4]
 80a05fa:	bd08      	pop	{r3, pc}
 80a05fc:	080601c4 	.word	0x080601c4

080a0600 <HAL_USART_Write_Data>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, HAL_USART_Begin, void(HAL_USART_Serial, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, HAL_USART_End, void(HAL_USART_Serial))
DYNALIB_FN(BASE_IDX + 3, hal_usart, HAL_USART_Write_Data, uint32_t(HAL_USART_Serial, uint8_t))
 80a0600:	b508      	push	{r3, lr}
 80a0602:	4b02      	ldr	r3, [pc, #8]	; (80a060c <HAL_USART_Write_Data+0xc>)
 80a0604:	681b      	ldr	r3, [r3, #0]
 80a0606:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a0608:	9301      	str	r3, [sp, #4]
 80a060a:	bd08      	pop	{r3, pc}
 80a060c:	080601c4 	.word	0x080601c4

080a0610 <HAL_USART_Available_Data>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, HAL_USART_Available_Data, int32_t(HAL_USART_Serial))
 80a0610:	b508      	push	{r3, lr}
 80a0612:	4b02      	ldr	r3, [pc, #8]	; (80a061c <HAL_USART_Available_Data+0xc>)
 80a0614:	681b      	ldr	r3, [r3, #0]
 80a0616:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a0618:	9301      	str	r3, [sp, #4]
 80a061a:	bd08      	pop	{r3, pc}
 80a061c:	080601c4 	.word	0x080601c4

080a0620 <HAL_USART_Read_Data>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, HAL_USART_Read_Data, int32_t(HAL_USART_Serial))
 80a0620:	b508      	push	{r3, lr}
 80a0622:	4b02      	ldr	r3, [pc, #8]	; (80a062c <HAL_USART_Read_Data+0xc>)
 80a0624:	681b      	ldr	r3, [r3, #0]
 80a0626:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a0628:	9301      	str	r3, [sp, #4]
 80a062a:	bd08      	pop	{r3, pc}
 80a062c:	080601c4 	.word	0x080601c4

080a0630 <HAL_USART_Peek_Data>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, HAL_USART_Peek_Data, int32_t(HAL_USART_Serial))
 80a0630:	b508      	push	{r3, lr}
 80a0632:	4b02      	ldr	r3, [pc, #8]	; (80a063c <HAL_USART_Peek_Data+0xc>)
 80a0634:	681b      	ldr	r3, [r3, #0]
 80a0636:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a0638:	9301      	str	r3, [sp, #4]
 80a063a:	bd08      	pop	{r3, pc}
 80a063c:	080601c4 	.word	0x080601c4

080a0640 <HAL_USART_Flush_Data>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, HAL_USART_Flush_Data, void(HAL_USART_Serial))
 80a0640:	b508      	push	{r3, lr}
 80a0642:	4b02      	ldr	r3, [pc, #8]	; (80a064c <HAL_USART_Flush_Data+0xc>)
 80a0644:	681b      	ldr	r3, [r3, #0]
 80a0646:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a0648:	9301      	str	r3, [sp, #4]
 80a064a:	bd08      	pop	{r3, pc}
 80a064c:	080601c4 	.word	0x080601c4

080a0650 <HAL_USART_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, HAL_USART_Is_Enabled, bool(HAL_USART_Serial))
 80a0650:	b508      	push	{r3, lr}
 80a0652:	4b02      	ldr	r3, [pc, #8]	; (80a065c <HAL_USART_Is_Enabled+0xc>)
 80a0654:	681b      	ldr	r3, [r3, #0]
 80a0656:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a0658:	9301      	str	r3, [sp, #4]
 80a065a:	bd08      	pop	{r3, pc}
 80a065c:	080601c4 	.word	0x080601c4

080a0660 <HAL_USART_Available_Data_For_Write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, HAL_USART_Half_Duplex, void(HAL_USART_Serial, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, HAL_USART_Available_Data_For_Write, int32_t(HAL_USART_Serial))
 80a0660:	b508      	push	{r3, lr}
 80a0662:	4b02      	ldr	r3, [pc, #8]	; (80a066c <HAL_USART_Available_Data_For_Write+0xc>)
 80a0664:	681b      	ldr	r3, [r3, #0]
 80a0666:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a0668:	9301      	str	r3, [sp, #4]
 80a066a:	bd08      	pop	{r3, pc}
 80a066c:	080601c4 	.word	0x080601c4

080a0670 <USB_USART_Available_Data_For_Write>:

#ifdef USB_CDC_ENABLE
DYNALIB_FN(BASE_IDX + 11, hal_usart, USB_USART_Available_Data_For_Write, int32_t(void))
 80a0670:	b508      	push	{r3, lr}
 80a0672:	4b02      	ldr	r3, [pc, #8]	; (80a067c <USB_USART_Available_Data_For_Write+0xc>)
 80a0674:	681b      	ldr	r3, [r3, #0]
 80a0676:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a0678:	9301      	str	r3, [sp, #4]
 80a067a:	bd08      	pop	{r3, pc}
 80a067c:	080601c4 	.word	0x080601c4

080a0680 <USB_USART_Flush_Data>:
DYNALIB_FN(BASE_IDX + 12, hal_usart, USB_USART_Flush_Data, void(void))
 80a0680:	b508      	push	{r3, lr}
 80a0682:	4b02      	ldr	r3, [pc, #8]	; (80a068c <USB_USART_Flush_Data+0xc>)
 80a0684:	681b      	ldr	r3, [r3, #0]
 80a0686:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a0688:	9301      	str	r3, [sp, #4]
 80a068a:	bd08      	pop	{r3, pc}
 80a068c:	080601c4 	.word	0x080601c4

080a0690 <HAL_USART_BeginConfig>:
#define BASE_IDX2 (BASE_IDX+13)
#else
#define BASE_IDX2 (BASE_IDX+11)
#endif

DYNALIB_FN(BASE_IDX2 + 0, hal_usart,HAL_USART_BeginConfig,void(HAL_USART_Serial serial, uint32_t baud, uint32_t config, void *ptr))
 80a0690:	b508      	push	{r3, lr}
 80a0692:	4b02      	ldr	r3, [pc, #8]	; (80a069c <HAL_USART_BeginConfig+0xc>)
 80a0694:	681b      	ldr	r3, [r3, #0]
 80a0696:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a0698:	9301      	str	r3, [sp, #4]
 80a069a:	bd08      	pop	{r3, pc}
 80a069c:	080601c4 	.word	0x080601c4

080a06a0 <set_system_mode>:
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
 80a06a0:	b508      	push	{r3, lr}
 80a06a2:	4b02      	ldr	r3, [pc, #8]	; (80a06ac <set_system_mode+0xc>)
 80a06a4:	681b      	ldr	r3, [r3, #0]
 80a06a6:	685b      	ldr	r3, [r3, #4]
 80a06a8:	9301      	str	r3, [sp, #4]
 80a06aa:	bd08      	pop	{r3, pc}
 80a06ac:	080601a4 	.word	0x080601a4

080a06b0 <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
 80a06b0:	b508      	push	{r3, lr}
 80a06b2:	4b02      	ldr	r3, [pc, #8]	; (80a06bc <system_delay_ms+0xc>)
 80a06b4:	681b      	ldr	r3, [r3, #0]
 80a06b6:	695b      	ldr	r3, [r3, #20]
 80a06b8:	9301      	str	r3, [sp, #4]
 80a06ba:	bd08      	pop	{r3, pc}
 80a06bc:	080601a4 	.word	0x080601a4

080a06c0 <spark_function>:


DYNALIB_BEGIN(system_cloud)

DYNALIB_FN(0, system_cloud, spark_variable, bool(const char*, const void*, Spark_Data_TypeDef, spark_variable_t*))
DYNALIB_FN(1, system_cloud, spark_function, bool(const char*, p_user_function_int_str_t, void*))
 80a06c0:	b508      	push	{r3, lr}
 80a06c2:	4b02      	ldr	r3, [pc, #8]	; (80a06cc <spark_function+0xc>)
 80a06c4:	681b      	ldr	r3, [r3, #0]
 80a06c6:	685b      	ldr	r3, [r3, #4]
 80a06c8:	9301      	str	r3, [sp, #4]
 80a06ca:	bd08      	pop	{r3, pc}
 80a06cc:	080601cc 	.word	0x080601cc

080a06d0 <network_ready>:

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
 80a06d0:	b508      	push	{r3, lr}
 80a06d2:	4b02      	ldr	r3, [pc, #8]	; (80a06dc <network_ready+0xc>)
 80a06d4:	681b      	ldr	r3, [r3, #0]
 80a06d6:	691b      	ldr	r3, [r3, #16]
 80a06d8:	9301      	str	r3, [sp, #4]
 80a06da:	bd08      	pop	{r3, pc}
 80a06dc:	080601c8 	.word	0x080601c8

080a06e0 <free>:
#include "dynalib.h"

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
DYNALIB_FN(1, rt, free, void(void*))
 80a06e0:	b508      	push	{r3, lr}
 80a06e2:	4b02      	ldr	r3, [pc, #8]	; (80a06ec <free+0xc>)
 80a06e4:	681b      	ldr	r3, [r3, #0]
 80a06e6:	685b      	ldr	r3, [r3, #4]
 80a06e8:	9301      	str	r3, [sp, #4]
 80a06ea:	bd08      	pop	{r3, pc}
 80a06ec:	080601a0 	.word	0x080601a0

080a06f0 <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
 80a06f0:	b508      	push	{r3, lr}
 80a06f2:	4b02      	ldr	r3, [pc, #8]	; (80a06fc <realloc+0xc>)
 80a06f4:	681b      	ldr	r3, [r3, #0]
 80a06f6:	689b      	ldr	r3, [r3, #8]
 80a06f8:	9301      	str	r3, [sp, #4]
 80a06fa:	bd08      	pop	{r3, pc}
 80a06fc:	080601a0 	.word	0x080601a0

080a0700 <delay>:
  return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
 80a0700:	2100      	movs	r1, #0
 80a0702:	f7ff bfd5 	b.w	80a06b0 <system_delay_ms>
	...

080a0708 <_GLOBAL__sub_I_setADCSampleTime>:
{
public:
    typedef uint8_t flag_t;
    inline SleepNetworkFlag(SystemSleepNetwork f) : SleepNetworkFlag(static_cast<flag_t>(f)) {}

    inline SleepNetworkFlag(flag_t flag) : flag_(flag) {}
 80a0708:	4b06      	ldr	r3, [pc, #24]	; (80a0724 <_GLOBAL__sub_I_setADCSampleTime+0x1c>)
 80a070a:	2200      	movs	r2, #0
 80a070c:	4906      	ldr	r1, [pc, #24]	; (80a0728 <_GLOBAL__sub_I_setADCSampleTime+0x20>)
 80a070e:	701a      	strb	r2, [r3, #0]
 80a0710:	2301      	movs	r3, #1
 80a0712:	700b      	strb	r3, [r1, #0]

class PublishFlag
{
public:
	typedef uint8_t flag_t;
	PublishFlag(flag_t flag) : flag_(flag) {}
 80a0714:	4905      	ldr	r1, [pc, #20]	; (80a072c <_GLOBAL__sub_I_setADCSampleTime+0x24>)
 80a0716:	700a      	strb	r2, [r1, #0]
 80a0718:	4a05      	ldr	r2, [pc, #20]	; (80a0730 <_GLOBAL__sub_I_setADCSampleTime+0x28>)
 80a071a:	7013      	strb	r3, [r2, #0]
 80a071c:	4b05      	ldr	r3, [pc, #20]	; (80a0734 <_GLOBAL__sub_I_setADCSampleTime+0x2c>)
 80a071e:	2202      	movs	r2, #2
 80a0720:	701a      	strb	r2, [r3, #0]
 80a0722:	4770      	bx	lr
 80a0724:	2000039f 	.word	0x2000039f
 80a0728:	200003a0 	.word	0x200003a0
 80a072c:	2000039d 	.word	0x2000039d
 80a0730:	2000039e 	.word	0x2000039e
 80a0734:	2000039c 	.word	0x2000039c

080a0738 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt>:
 80a0738:	4b06      	ldr	r3, [pc, #24]	; (80a0754 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x1c>)
 80a073a:	2200      	movs	r2, #0
 80a073c:	4906      	ldr	r1, [pc, #24]	; (80a0758 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x20>)
 80a073e:	701a      	strb	r2, [r3, #0]
 80a0740:	2301      	movs	r3, #1
 80a0742:	700b      	strb	r3, [r1, #0]
 80a0744:	4905      	ldr	r1, [pc, #20]	; (80a075c <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x24>)
 80a0746:	700a      	strb	r2, [r1, #0]
 80a0748:	4a05      	ldr	r2, [pc, #20]	; (80a0760 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x28>)
 80a074a:	7013      	strb	r3, [r2, #0]
 80a074c:	4b05      	ldr	r3, [pc, #20]	; (80a0764 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x2c>)
 80a074e:	2202      	movs	r2, #2
 80a0750:	701a      	strb	r2, [r3, #0]
 80a0752:	4770      	bx	lr
 80a0754:	200003a4 	.word	0x200003a4
 80a0758:	200003a5 	.word	0x200003a5
 80a075c:	200003a2 	.word	0x200003a2
 80a0760:	200003a3 	.word	0x200003a3
 80a0764:	200003a1 	.word	0x200003a1

080a0768 <_ZN10CloudClass22call_raw_user_functionEPvPKcS0_>:
#include "spark_wiring_cloud.h"

int CloudClass::call_raw_user_function(void* data, const char* param, void* reserved)
{
 80a0768:	b510      	push	{r4, lr}
 80a076a:	b088      	sub	sp, #32
 80a076c:	4604      	mov	r4, r0
    user_function_int_str_t* fn = (user_function_int_str_t*)(data);
    String p(param);
 80a076e:	4668      	mov	r0, sp
 80a0770:	f000 fa1c 	bl	80a0bac <_ZN6StringC1EPKc>
    return (*fn)(p);
 80a0774:	4669      	mov	r1, sp
 80a0776:	a804      	add	r0, sp, #16
 80a0778:	f000 fa3a 	bl	80a0bf0 <_ZN6StringC1ERKS_>
 80a077c:	a804      	add	r0, sp, #16
 80a077e:	47a0      	blx	r4
 80a0780:	4604      	mov	r4, r0
 80a0782:	a804      	add	r0, sp, #16
 80a0784:	f000 f9d0 	bl	80a0b28 <_ZN6StringD1Ev>
 80a0788:	4668      	mov	r0, sp
 80a078a:	f000 f9cd 	bl	80a0b28 <_ZN6StringD1Ev>
}
 80a078e:	4620      	mov	r0, r4
 80a0790:	b008      	add	sp, #32
 80a0792:	bd10      	pop	{r4, pc}

080a0794 <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>:
    wiring_event_handler_t* fn = (wiring_event_handler_t*)(handler_data);
    (*fn)(event_name, data);
}

bool CloudClass::register_function(cloud_function_t fn, void* data, const char* funcKey)
{
 80a0794:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a0796:	4607      	mov	r7, r0
 80a0798:	460e      	mov	r6, r1
 80a079a:	4615      	mov	r5, r2
 80a079c:	b085      	sub	sp, #20
    const char *funcKey;
    cloud_function_t fn;
    void* data;

     cloud_function_descriptor() {
         memset(this, 0, sizeof(*this));
 80a079e:	2410      	movs	r4, #16
 80a07a0:	4622      	mov	r2, r4
 80a07a2:	4668      	mov	r0, sp
 80a07a4:	2100      	movs	r1, #0
 80a07a6:	f000 fea6 	bl	80a14f6 <memset>
    cloud_function_descriptor desc;
    memset(&desc, 0, sizeof(desc));
 80a07aa:	4622      	mov	r2, r4
 80a07ac:	4668      	mov	r0, sp
 80a07ae:	2100      	movs	r1, #0
 80a07b0:	f000 fea1 	bl	80a14f6 <memset>
    desc.size = sizeof(desc);
    desc.fn = fn;
    desc.data = (void*)data;
    desc.funcKey = funcKey;
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
 80a07b4:	2000      	movs	r0, #0
 80a07b6:	4669      	mov	r1, sp
 80a07b8:	4602      	mov	r2, r0

bool CloudClass::register_function(cloud_function_t fn, void* data, const char* funcKey)
{
    cloud_function_descriptor desc;
    memset(&desc, 0, sizeof(desc));
    desc.size = sizeof(desc);
 80a07ba:	f8ad 4000 	strh.w	r4, [sp]
    desc.fn = fn;
 80a07be:	9702      	str	r7, [sp, #8]
    desc.data = (void*)data;
 80a07c0:	9603      	str	r6, [sp, #12]
    desc.funcKey = funcKey;
 80a07c2:	9501      	str	r5, [sp, #4]
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
 80a07c4:	f7ff ff7c 	bl	80a06c0 <spark_function>
}
 80a07c8:	b005      	add	sp, #20
 80a07ca:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a07cc <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_>:
 80a07cc:	4b06      	ldr	r3, [pc, #24]	; (80a07e8 <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x1c>)
 80a07ce:	2200      	movs	r2, #0
 80a07d0:	4906      	ldr	r1, [pc, #24]	; (80a07ec <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x20>)
 80a07d2:	701a      	strb	r2, [r3, #0]
 80a07d4:	2301      	movs	r3, #1
 80a07d6:	700b      	strb	r3, [r1, #0]
 80a07d8:	4905      	ldr	r1, [pc, #20]	; (80a07f0 <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x24>)
 80a07da:	700a      	strb	r2, [r1, #0]
 80a07dc:	4a05      	ldr	r2, [pc, #20]	; (80a07f4 <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x28>)
 80a07de:	7013      	strb	r3, [r2, #0]
 80a07e0:	4b05      	ldr	r3, [pc, #20]	; (80a07f8 <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x2c>)
 80a07e2:	2202      	movs	r2, #2
 80a07e4:	701a      	strb	r2, [r3, #0]
 80a07e6:	4770      	bx	lr
 80a07e8:	200003a9 	.word	0x200003a9
 80a07ec:	200003aa 	.word	0x200003aa
 80a07f0:	200003a7 	.word	0x200003a7
 80a07f4:	200003a8 	.word	0x200003a8
 80a07f8:	200003a6 	.word	0x200003a6

080a07fc <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev>:
 80a07fc:	4b06      	ldr	r3, [pc, #24]	; (80a0818 <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x1c>)
 80a07fe:	2200      	movs	r2, #0
 80a0800:	4906      	ldr	r1, [pc, #24]	; (80a081c <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x20>)
 80a0802:	701a      	strb	r2, [r3, #0]
 80a0804:	2301      	movs	r3, #1
 80a0806:	700b      	strb	r3, [r1, #0]
 80a0808:	4905      	ldr	r1, [pc, #20]	; (80a0820 <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x24>)
 80a080a:	700a      	strb	r2, [r1, #0]
 80a080c:	4a05      	ldr	r2, [pc, #20]	; (80a0824 <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x28>)
 80a080e:	7013      	strb	r3, [r2, #0]
 80a0810:	4b05      	ldr	r3, [pc, #20]	; (80a0828 <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x2c>)
 80a0812:	2202      	movs	r2, #2
 80a0814:	701a      	strb	r2, [r3, #0]
 80a0816:	4770      	bx	lr
 80a0818:	200003ae 	.word	0x200003ae
 80a081c:	200003af 	.word	0x200003af
 80a0820:	200003ac 	.word	0x200003ac
 80a0824:	200003ad 	.word	0x200003ad
 80a0828:	200003ab 	.word	0x200003ab

080a082c <_ZN7TwoWireD1Ev>:
private:
  HAL_I2C_Interface _i2c;

public:
  TwoWire(HAL_I2C_Interface i2c);
  virtual ~TwoWire() {};
 80a082c:	4770      	bx	lr

080a082e <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a082e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0830:	4606      	mov	r6, r0
 80a0832:	4615      	mov	r5, r2
 80a0834:	460c      	mov	r4, r1
 80a0836:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a0838:	42bc      	cmp	r4, r7
 80a083a:	d006      	beq.n	80a084a <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a083c:	6833      	ldr	r3, [r6, #0]
 80a083e:	4630      	mov	r0, r6
 80a0840:	689b      	ldr	r3, [r3, #8]
 80a0842:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a0846:	4798      	blx	r3
 80a0848:	e7f6      	b.n	80a0838 <_ZN7TwoWire5writeEPKhj+0xa>
  }

  return quantity;
}
 80a084a:	4628      	mov	r0, r5
 80a084c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a084e <_ZN7TwoWire5writeEh>:
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
  return HAL_I2C_Write_Data(_i2c, data, NULL);
 80a084e:	7c00      	ldrb	r0, [r0, #16]
 80a0850:	2200      	movs	r2, #0
 80a0852:	f7ff be63 	b.w	80a051c <HAL_I2C_Write_Data>

080a0856 <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return HAL_I2C_Available_Data(_i2c, NULL);
 80a0856:	7c00      	ldrb	r0, [r0, #16]
 80a0858:	2100      	movs	r1, #0
 80a085a:	f7ff be67 	b.w	80a052c <HAL_I2C_Available_Data>

080a085e <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return HAL_I2C_Read_Data(_i2c, NULL);
 80a085e:	7c00      	ldrb	r0, [r0, #16]
 80a0860:	2100      	movs	r1, #0
 80a0862:	f7ff be6b 	b.w	80a053c <HAL_I2C_Read_Data>

080a0866 <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return HAL_I2C_Peek_Data(_i2c, NULL);
 80a0866:	7c00      	ldrb	r0, [r0, #16]
 80a0868:	2100      	movs	r1, #0
 80a086a:	f7ff be6f 	b.w	80a054c <HAL_I2C_Peek_Data>

080a086e <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  HAL_I2C_Flush_Data(_i2c, NULL);
 80a086e:	7c00      	ldrb	r0, [r0, #16]
 80a0870:	2100      	movs	r1, #0
 80a0872:	f7ff be73 	b.w	80a055c <HAL_I2C_Flush_Data>

080a0876 <_ZN7TwoWireD0Ev>:
 80a0876:	b510      	push	{r4, lr}
 80a0878:	4604      	mov	r4, r0
 80a087a:	f7ff fc0e 	bl	80a009a <_ZdlPv>
 80a087e:	4620      	mov	r0, r4
 80a0880:	bd10      	pop	{r4, pc}
	...

080a0884 <_ZN7TwoWireC1E17HAL_I2C_Interface>:
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a0884:	b510      	push	{r4, lr}
 80a0886:	4604      	mov	r4, r0
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a0888:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a088c:	6082      	str	r2, [r0, #8]
 80a088e:	4a05      	ldr	r2, [pc, #20]	; (80a08a4 <_ZN7TwoWireC1E17HAL_I2C_Interface+0x20>)
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a0890:	2300      	movs	r3, #0
 80a0892:	6043      	str	r3, [r0, #4]
 80a0894:	6002      	str	r2, [r0, #0]
{
  _i2c = i2c;
 80a0896:	7401      	strb	r1, [r0, #16]
  HAL_I2C_Init(_i2c, NULL);
 80a0898:	4608      	mov	r0, r1
 80a089a:	4619      	mov	r1, r3
 80a089c:	f7ff fe6e 	bl	80a057c <HAL_I2C_Init>

}
 80a08a0:	4620      	mov	r0, r4
 80a08a2:	bd10      	pop	{r4, pc}
 80a08a4:	080a16d0 	.word	0x080a16d0

080a08a8 <_ZN7TwoWire9isEnabledEv>:
  HAL_I2C_Set_Callback_On_Request(_i2c, function, NULL);
}

bool TwoWire::isEnabled()
{
  return HAL_I2C_Is_Enabled(_i2c, NULL);
 80a08a8:	7c00      	ldrb	r0, [r0, #16]
 80a08aa:	2100      	movs	r1, #0
 80a08ac:	f7ff be5e 	b.w	80a056c <HAL_I2C_Is_Enabled>

080a08b0 <_GLOBAL__sub_I__Z16allocate_handlertRSt8functionIFvvEE>:
 80a08b0:	4b06      	ldr	r3, [pc, #24]	; (80a08cc <_GLOBAL__sub_I__Z16allocate_handlertRSt8functionIFvvEE+0x1c>)
 80a08b2:	2200      	movs	r2, #0
 80a08b4:	4906      	ldr	r1, [pc, #24]	; (80a08d0 <_GLOBAL__sub_I__Z16allocate_handlertRSt8functionIFvvEE+0x20>)
 80a08b6:	701a      	strb	r2, [r3, #0]
 80a08b8:	2301      	movs	r3, #1
 80a08ba:	700b      	strb	r3, [r1, #0]
 80a08bc:	4905      	ldr	r1, [pc, #20]	; (80a08d4 <_GLOBAL__sub_I__Z16allocate_handlertRSt8functionIFvvEE+0x24>)
 80a08be:	700a      	strb	r2, [r1, #0]
 80a08c0:	4a05      	ldr	r2, [pc, #20]	; (80a08d8 <_GLOBAL__sub_I__Z16allocate_handlertRSt8functionIFvvEE+0x28>)
 80a08c2:	7013      	strb	r3, [r2, #0]
 80a08c4:	4b05      	ldr	r3, [pc, #20]	; (80a08dc <_GLOBAL__sub_I__Z16allocate_handlertRSt8functionIFvvEE+0x2c>)
 80a08c6:	2202      	movs	r2, #2
 80a08c8:	701a      	strb	r2, [r3, #0]
 80a08ca:	4770      	bx	lr
 80a08cc:	200003b3 	.word	0x200003b3
 80a08d0:	200003b4 	.word	0x200003b4
 80a08d4:	200003b1 	.word	0x200003b1
 80a08d8:	200003b2 	.word	0x200003b2
 80a08dc:	200003b0 	.word	0x200003b0

080a08e0 <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a08e0:	4770      	bx	lr

080a08e2 <_ZN9IPAddressD0Ev>:
 80a08e2:	b510      	push	{r4, lr}
 80a08e4:	4604      	mov	r4, r0
 80a08e6:	f7ff fbd8 	bl	80a009a <_ZdlPv>
 80a08ea:	4620      	mov	r0, r4
 80a08ec:	bd10      	pop	{r4, pc}

080a08ee <_ZNK9IPAddress7printToER5Print>:
#endif
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
 80a08ee:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a08f0:	460f      	mov	r7, r1
 80a08f2:	f100 0608 	add.w	r6, r0, #8
 80a08f6:	1d05      	adds	r5, r0, #4
 80a08f8:	2400      	movs	r4, #0
    size_t n = 0;
    for (int i = 0; i < 4; i++)
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a08fa:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 80a08fe:	4638      	mov	r0, r7
 80a0900:	220a      	movs	r2, #10
 80a0902:	f000 f8ac 	bl	80a0a5e <_ZN5Print5printEhi>
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a0906:	42ae      	cmp	r6, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a0908:	4404      	add	r4, r0
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a090a:	d007      	beq.n	80a091c <_ZNK9IPAddress7printToER5Print+0x2e>
    {
        if (n)
 80a090c:	2c00      	cmp	r4, #0
 80a090e:	d0f4      	beq.n	80a08fa <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a0910:	4638      	mov	r0, r7
 80a0912:	212e      	movs	r1, #46	; 0x2e
 80a0914:	f000 f85e 	bl	80a09d4 <_ZN5Print5printEc>
 80a0918:	4404      	add	r4, r0
 80a091a:	e7ee      	b.n	80a08fa <_ZNK9IPAddress7printToER5Print+0xc>
        n += p.print((*this)[i], DEC);
    }
    return n;
}
 80a091c:	4620      	mov	r0, r4
 80a091e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a0920 <_ZN9IPAddress8set_ipv4Ehhhh>:
    return address.ipv4!=0;
#endif
}

void IPAddress::set_ipv4(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
 80a0920:	b510      	push	{r4, lr}
 80a0922:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a0926:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 80a092a:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a092e:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
        return &address;
    }

    inline void setVersion(uint8_t version) {
#if HAL_IPv6
        address.v = version;
 80a0932:	2304      	movs	r3, #4
 80a0934:	6041      	str	r1, [r0, #4]
 80a0936:	7503      	strb	r3, [r0, #20]
 80a0938:	bd10      	pop	{r4, pc}
	...

080a093c <_ZN9IPAddressC1Ehhhh>:
{
    memcpy(&this->address, &address, sizeof(address));
}


IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a093c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a093e:	4604      	mov	r4, r0
 80a0940:	4d04      	ldr	r5, [pc, #16]	; (80a0954 <_ZN9IPAddressC1Ehhhh+0x18>)
 80a0942:	6005      	str	r5, [r0, #0]
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a0944:	f89d 5018 	ldrb.w	r5, [sp, #24]
 80a0948:	9500      	str	r5, [sp, #0]
 80a094a:	f7ff ffe9 	bl	80a0920 <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a094e:	4620      	mov	r0, r4
 80a0950:	b003      	add	sp, #12
 80a0952:	bd30      	pop	{r4, r5, pc}
 80a0954:	080a16f8 	.word	0x080a16f8

080a0958 <_GLOBAL__sub_I__ZN4PMICC2Ev>:
 80a0958:	4b06      	ldr	r3, [pc, #24]	; (80a0974 <_GLOBAL__sub_I__ZN4PMICC2Ev+0x1c>)
 80a095a:	2200      	movs	r2, #0
 80a095c:	4906      	ldr	r1, [pc, #24]	; (80a0978 <_GLOBAL__sub_I__ZN4PMICC2Ev+0x20>)
 80a095e:	701a      	strb	r2, [r3, #0]
 80a0960:	2301      	movs	r3, #1
 80a0962:	700b      	strb	r3, [r1, #0]
 80a0964:	4905      	ldr	r1, [pc, #20]	; (80a097c <_GLOBAL__sub_I__ZN4PMICC2Ev+0x24>)
 80a0966:	700a      	strb	r2, [r1, #0]
 80a0968:	4a05      	ldr	r2, [pc, #20]	; (80a0980 <_GLOBAL__sub_I__ZN4PMICC2Ev+0x28>)
 80a096a:	7013      	strb	r3, [r2, #0]
 80a096c:	4b05      	ldr	r3, [pc, #20]	; (80a0984 <_GLOBAL__sub_I__ZN4PMICC2Ev+0x2c>)
 80a096e:	2202      	movs	r2, #2
 80a0970:	701a      	strb	r2, [r3, #0]
 80a0972:	4770      	bx	lr
 80a0974:	200003b8 	.word	0x200003b8
 80a0978:	200003b9 	.word	0x200003b9
 80a097c:	200003b6 	.word	0x200003b6
 80a0980:	200003b7 	.word	0x200003b7
 80a0984:	200003b5 	.word	0x200003b5

080a0988 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a0988:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a098a:	4606      	mov	r6, r0
 80a098c:	460d      	mov	r5, r1
 80a098e:	188f      	adds	r7, r1, r2
  size_t n = 0;
 80a0990:	2400      	movs	r4, #0
  while (size--) {
 80a0992:	42bd      	cmp	r5, r7
 80a0994:	d00c      	beq.n	80a09b0 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a0996:	6833      	ldr	r3, [r6, #0]
 80a0998:	4630      	mov	r0, r6
 80a099a:	689b      	ldr	r3, [r3, #8]
 80a099c:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a09a0:	4798      	blx	r3
     if (chunk>=0)
 80a09a2:	2800      	cmp	r0, #0
 80a09a4:	db01      	blt.n	80a09aa <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a09a6:	4404      	add	r4, r0
 80a09a8:	e7f3      	b.n	80a0992 <_ZN5Print5writeEPKhj+0xa>
/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
     int chunk = write(*buffer++);
 80a09aa:	2c00      	cmp	r4, #0
 80a09ac:	bf08      	it	eq
 80a09ae:	4604      	moveq	r4, r0
             n = chunk;
         break;
     }
  }
  return n;
}
 80a09b0:	4620      	mov	r0, r4
 80a09b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a09b4 <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
 80a09b4:	b570      	push	{r4, r5, r6, lr}
 80a09b6:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a09b8:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
 80a09ba:	4608      	mov	r0, r1
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 80a09bc:	b149      	cbz	r1, 80a09d2 <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a09be:	f000 fdb4 	bl	80a152a <strlen>
 80a09c2:	682b      	ldr	r3, [r5, #0]
 80a09c4:	4602      	mov	r2, r0
 80a09c6:	4621      	mov	r1, r4
 80a09c8:	4628      	mov	r0, r5
    }
 80a09ca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 80a09ce:	68db      	ldr	r3, [r3, #12]
 80a09d0:	4718      	bx	r3
    }
 80a09d2:	bd70      	pop	{r4, r5, r6, pc}

080a09d4 <_ZN5Print5printEc>:
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
 80a09d4:	6803      	ldr	r3, [r0, #0]
 80a09d6:	689b      	ldr	r3, [r3, #8]
 80a09d8:	4718      	bx	r3

080a09da <_ZN5Print7printlnEv>:
 {
   return x.printTo(*this);
 }

size_t Print::println(void)
{
 80a09da:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
 80a09dc:	210d      	movs	r1, #13
 {
   return x.printTo(*this);
 }

size_t Print::println(void)
{
 80a09de:	4605      	mov	r5, r0
  size_t n = print('\r');
 80a09e0:	f7ff fff8 	bl	80a09d4 <_ZN5Print5printEc>
  n += print('\n');
 80a09e4:	210a      	movs	r1, #10
   return x.printTo(*this);
 }

size_t Print::println(void)
{
  size_t n = print('\r');
 80a09e6:	4604      	mov	r4, r0
  n += print('\n');
 80a09e8:	4628      	mov	r0, r5
 80a09ea:	f7ff fff3 	bl	80a09d4 <_ZN5Print5printEc>
  return n;
}
 80a09ee:	4420      	add	r0, r4
 80a09f0:	bd38      	pop	{r3, r4, r5, pc}

080a09f2 <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
 80a09f2:	b538      	push	{r3, r4, r5, lr}
 80a09f4:	4605      	mov	r5, r0
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a09f6:	f7ff ffdd 	bl	80a09b4 <_ZN5Print5writeEPKc>
 80a09fa:	4604      	mov	r4, r0
}

size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
 80a09fc:	4628      	mov	r0, r5
 80a09fe:	f7ff ffec 	bl	80a09da <_ZN5Print7printlnEv>
  return n;
}
 80a0a02:	4420      	add	r0, r4
 80a0a04:	bd38      	pop	{r3, r4, r5, pc}

080a0a06 <_ZN5Print11printNumberEmh>:
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a0a06:	2a01      	cmp	r2, #1
 80a0a08:	bf98      	it	ls
 80a0a0a:	220a      	movls	r2, #10
   return n;
 }

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a0a0c:	b530      	push	{r4, r5, lr}
 80a0a0e:	460b      	mov	r3, r1
 80a0a10:	b08b      	sub	sp, #44	; 0x2c
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a0a12:	2100      	movs	r1, #0
 80a0a14:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24
 80a0a18:	f10d 0423 	add.w	r4, sp, #35	; 0x23
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    unsigned long m = n;
    n /= base;
 80a0a1c:	fbb3 f5f2 	udiv	r5, r3, r2
    char c = m - base * n;
 80a0a20:	fb05 3312 	mls	r3, r5, r2, r3
 80a0a24:	b2db      	uxtb	r3, r3
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a0a26:	2b09      	cmp	r3, #9
 80a0a28:	bf94      	ite	ls
 80a0a2a:	3330      	addls	r3, #48	; 0x30
 80a0a2c:	3337      	addhi	r3, #55	; 0x37
 80a0a2e:	b2db      	uxtb	r3, r3
 80a0a30:	4621      	mov	r1, r4
 80a0a32:	f804 3901 	strb.w	r3, [r4], #-1
 80a0a36:	462b      	mov	r3, r5
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 80a0a38:	2d00      	cmp	r5, #0
 80a0a3a:	d1ef      	bne.n	80a0a1c <_ZN5Print11printNumberEmh+0x16>
    n /= base;
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 80a0a3c:	f7ff ffba 	bl	80a09b4 <_ZN5Print5writeEPKc>
}
 80a0a40:	b00b      	add	sp, #44	; 0x2c
 80a0a42:	bd30      	pop	{r4, r5, pc}

080a0a44 <_ZN5Print5printEmi>:
    return printNumber(n, base);
  }
}

size_t Print::print(unsigned long n, int base)
{
 80a0a44:	b510      	push	{r4, lr}
  if (base == 0) return write(n);
 80a0a46:	b92a      	cbnz	r2, 80a0a54 <_ZN5Print5printEmi+0x10>
  else return printNumber(n, base);
}
 80a0a48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  }
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
 80a0a4c:	6803      	ldr	r3, [r0, #0]
 80a0a4e:	b2c9      	uxtb	r1, r1
 80a0a50:	689b      	ldr	r3, [r3, #8]
 80a0a52:	4718      	bx	r3
  else return printNumber(n, base);
 80a0a54:	b2d2      	uxtb	r2, r2
}
 80a0a56:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 80a0a5a:	f7ff bfd4 	b.w	80a0a06 <_ZN5Print11printNumberEmh>

080a0a5e <_ZN5Print5printEhi>:
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
 80a0a5e:	f7ff bff1 	b.w	80a0a44 <_ZN5Print5printEmi>
	...

080a0a64 <_GLOBAL__sub_I__ZN5ServoC2Ev>:
 80a0a64:	4b06      	ldr	r3, [pc, #24]	; (80a0a80 <_GLOBAL__sub_I__ZN5ServoC2Ev+0x1c>)
 80a0a66:	2200      	movs	r2, #0
 80a0a68:	4906      	ldr	r1, [pc, #24]	; (80a0a84 <_GLOBAL__sub_I__ZN5ServoC2Ev+0x20>)
 80a0a6a:	701a      	strb	r2, [r3, #0]
 80a0a6c:	2301      	movs	r3, #1
 80a0a6e:	700b      	strb	r3, [r1, #0]
 80a0a70:	4905      	ldr	r1, [pc, #20]	; (80a0a88 <_GLOBAL__sub_I__ZN5ServoC2Ev+0x24>)
 80a0a72:	700a      	strb	r2, [r1, #0]
 80a0a74:	4a05      	ldr	r2, [pc, #20]	; (80a0a8c <_GLOBAL__sub_I__ZN5ServoC2Ev+0x28>)
 80a0a76:	7013      	strb	r3, [r2, #0]
 80a0a78:	4b05      	ldr	r3, [pc, #20]	; (80a0a90 <_GLOBAL__sub_I__ZN5ServoC2Ev+0x2c>)
 80a0a7a:	2202      	movs	r2, #2
 80a0a7c:	701a      	strb	r2, [r3, #0]
 80a0a7e:	4770      	bx	lr
 80a0a80:	200003bd 	.word	0x200003bd
 80a0a84:	200003be 	.word	0x200003be
 80a0a88:	200003bb 	.word	0x200003bb
 80a0a8c:	200003bc 	.word	0x200003bc
 80a0a90:	200003ba 	.word	0x200003ba

080a0a94 <_ZN8SPIClassD1Ev>:
   */
  unsigned dividerReference;

public:
  SPIClass(HAL_SPI_Interface spi);
  virtual ~SPIClass() {};
 80a0a94:	4770      	bx	lr

080a0a96 <_ZN8SPIClassD0Ev>:
 80a0a96:	b510      	push	{r4, lr}
 80a0a98:	4604      	mov	r4, r0
 80a0a9a:	f7ff fafe 	bl	80a009a <_ZdlPv>
 80a0a9e:	4620      	mov	r0, r4
 80a0aa0:	bd10      	pop	{r4, pc}
	...

080a0aa4 <_ZN8SPIClassC1E17HAL_SPI_Interface>:

#include "spark_wiring_spi.h"
#include "core_hal.h"
#include "spark_macros.h"

SPIClass::SPIClass(HAL_SPI_Interface spi)
 80a0aa4:	b510      	push	{r4, lr}
 80a0aa6:	4604      	mov	r4, r0
 80a0aa8:	4b04      	ldr	r3, [pc, #16]	; (80a0abc <_ZN8SPIClassC1E17HAL_SPI_Interface+0x18>)
{
  _spi = spi;
 80a0aaa:	7101      	strb	r1, [r0, #4]

#include "spark_wiring_spi.h"
#include "core_hal.h"
#include "spark_macros.h"

SPIClass::SPIClass(HAL_SPI_Interface spi)
 80a0aac:	6003      	str	r3, [r0, #0]
{
  _spi = spi;
  HAL_SPI_Init(_spi);
 80a0aae:	4608      	mov	r0, r1
 80a0ab0:	f7ff fd6e 	bl	80a0590 <HAL_SPI_Init>
  dividerReference = SPI_CLK_SYSTEM;     // 0 indicates the system clock
 80a0ab4:	2300      	movs	r3, #0
 80a0ab6:	60a3      	str	r3, [r4, #8]
}
 80a0ab8:	4620      	mov	r0, r4
 80a0aba:	bd10      	pop	{r4, pc}
 80a0abc:	080a1710 	.word	0x080a1710

080a0ac0 <_ZN8SPIClass9isEnabledEv>:
  //To Do
}

bool SPIClass::isEnabled()
{
  return HAL_SPI_Is_Enabled(_spi);
 80a0ac0:	7900      	ldrb	r0, [r0, #4]
 80a0ac2:	f7ff bd6d 	b.w	80a05a0 <HAL_SPI_Is_Enabled>
	...

080a0ac8 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface>:
 80a0ac8:	4b06      	ldr	r3, [pc, #24]	; (80a0ae4 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x1c>)
 80a0aca:	2200      	movs	r2, #0
 80a0acc:	4906      	ldr	r1, [pc, #24]	; (80a0ae8 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x20>)
 80a0ace:	701a      	strb	r2, [r3, #0]
 80a0ad0:	2301      	movs	r3, #1
 80a0ad2:	700b      	strb	r3, [r1, #0]
 80a0ad4:	4905      	ldr	r1, [pc, #20]	; (80a0aec <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x24>)
 80a0ad6:	700a      	strb	r2, [r1, #0]
 80a0ad8:	4a05      	ldr	r2, [pc, #20]	; (80a0af0 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x28>)
 80a0ada:	7013      	strb	r3, [r2, #0]
 80a0adc:	4b05      	ldr	r3, [pc, #20]	; (80a0af4 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x2c>)
 80a0ade:	2202      	movs	r2, #2
 80a0ae0:	701a      	strb	r2, [r3, #0]
 80a0ae2:	4770      	bx	lr
 80a0ae4:	200003c2 	.word	0x200003c2
 80a0ae8:	200003c3 	.word	0x200003c3
 80a0aec:	200003c0 	.word	0x200003c0
 80a0af0:	200003c1 	.word	0x200003c1
 80a0af4:	200003bf 	.word	0x200003bf

080a0af8 <_GLOBAL__sub_I__ZN6Stream9timedReadEv>:
 80a0af8:	4b06      	ldr	r3, [pc, #24]	; (80a0b14 <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x1c>)
 80a0afa:	2200      	movs	r2, #0
 80a0afc:	4906      	ldr	r1, [pc, #24]	; (80a0b18 <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x20>)
 80a0afe:	701a      	strb	r2, [r3, #0]
 80a0b00:	2301      	movs	r3, #1
 80a0b02:	700b      	strb	r3, [r1, #0]
 80a0b04:	4905      	ldr	r1, [pc, #20]	; (80a0b1c <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x24>)
 80a0b06:	700a      	strb	r2, [r1, #0]
 80a0b08:	4a05      	ldr	r2, [pc, #20]	; (80a0b20 <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x28>)
 80a0b0a:	7013      	strb	r3, [r2, #0]
 80a0b0c:	4b05      	ldr	r3, [pc, #20]	; (80a0b24 <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x2c>)
 80a0b0e:	2202      	movs	r2, #2
 80a0b10:	701a      	strb	r2, [r3, #0]
 80a0b12:	4770      	bx	lr
 80a0b14:	200003c7 	.word	0x200003c7
 80a0b18:	200003c8 	.word	0x200003c8
 80a0b1c:	200003c5 	.word	0x200003c5
 80a0b20:	200003c6 	.word	0x200003c6
 80a0b24:	200003c4 	.word	0x200003c4

080a0b28 <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
 80a0b28:	b510      	push	{r4, lr}
 80a0b2a:	4604      	mov	r4, r0
{
	free(buffer);
 80a0b2c:	6800      	ldr	r0, [r0, #0]
 80a0b2e:	f7ff fdd7 	bl	80a06e0 <free>
}
 80a0b32:	4620      	mov	r0, r4
 80a0b34:	bd10      	pop	{r4, pc}

080a0b36 <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
 80a0b36:	b510      	push	{r4, lr}
 80a0b38:	4604      	mov	r4, r0
	if (buffer) free(buffer);
 80a0b3a:	6800      	ldr	r0, [r0, #0]
 80a0b3c:	b108      	cbz	r0, 80a0b42 <_ZN6String10invalidateEv+0xc>
 80a0b3e:	f7ff fdcf 	bl	80a06e0 <free>
	buffer = NULL;
 80a0b42:	2300      	movs	r3, #0
 80a0b44:	6023      	str	r3, [r4, #0]
	capacity = len = 0;
 80a0b46:	60a3      	str	r3, [r4, #8]
 80a0b48:	6063      	str	r3, [r4, #4]
 80a0b4a:	bd10      	pop	{r4, pc}

080a0b4c <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
 80a0b4c:	b538      	push	{r3, r4, r5, lr}
 80a0b4e:	4604      	mov	r4, r0
 80a0b50:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
 80a0b52:	6800      	ldr	r0, [r0, #0]
 80a0b54:	3101      	adds	r1, #1
 80a0b56:	f7ff fdcb 	bl	80a06f0 <realloc>
	if (newbuffer) {
 80a0b5a:	b110      	cbz	r0, 80a0b62 <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
 80a0b5c:	e884 0021 	stmia.w	r4, {r0, r5}
		return 1;
 80a0b60:	2001      	movs	r0, #1
	}
	return 0;
}
 80a0b62:	bd38      	pop	{r3, r4, r5, pc}

080a0b64 <_ZN6String7reserveEj>:
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a0b64:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
 80a0b66:	6803      	ldr	r3, [r0, #0]
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a0b68:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
 80a0b6a:	b113      	cbz	r3, 80a0b72 <_ZN6String7reserveEj+0xe>
 80a0b6c:	6843      	ldr	r3, [r0, #4]
 80a0b6e:	428b      	cmp	r3, r1
 80a0b70:	d207      	bcs.n	80a0b82 <_ZN6String7reserveEj+0x1e>
	if (changeBuffer(size)) {
 80a0b72:	4620      	mov	r0, r4
 80a0b74:	f7ff ffea 	bl	80a0b4c <_ZN6String12changeBufferEj>
 80a0b78:	b120      	cbz	r0, 80a0b84 <_ZN6String7reserveEj+0x20>
		if (len == 0) buffer[0] = 0;
 80a0b7a:	68a3      	ldr	r3, [r4, #8]
 80a0b7c:	b90b      	cbnz	r3, 80a0b82 <_ZN6String7reserveEj+0x1e>
 80a0b7e:	6822      	ldr	r2, [r4, #0]
 80a0b80:	7013      	strb	r3, [r2, #0]
 80a0b82:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
 80a0b84:	bd10      	pop	{r4, pc}

080a0b86 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a0b86:	b570      	push	{r4, r5, r6, lr}
 80a0b88:	460e      	mov	r6, r1
	if (!reserve(length)) {
 80a0b8a:	4611      	mov	r1, r2
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a0b8c:	4604      	mov	r4, r0
 80a0b8e:	4615      	mov	r5, r2
	if (!reserve(length)) {
 80a0b90:	f7ff ffe8 	bl	80a0b64 <_ZN6String7reserveEj>
 80a0b94:	b918      	cbnz	r0, 80a0b9e <_ZN6String4copyEPKcj+0x18>
		invalidate();
 80a0b96:	4620      	mov	r0, r4
 80a0b98:	f7ff ffcd 	bl	80a0b36 <_ZN6String10invalidateEv>
		return *this;
 80a0b9c:	e004      	b.n	80a0ba8 <_ZN6String4copyEPKcj+0x22>
	}
	len = length;
 80a0b9e:	60a5      	str	r5, [r4, #8]
	strcpy(buffer, cstr);
 80a0ba0:	6820      	ldr	r0, [r4, #0]
 80a0ba2:	4631      	mov	r1, r6
 80a0ba4:	f000 fcb9 	bl	80a151a <strcpy>
	return *this;
}
 80a0ba8:	4620      	mov	r0, r4
 80a0baa:	bd70      	pop	{r4, r5, r6, pc}

080a0bac <_ZN6StringC1EPKc>:

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
 80a0bac:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a0bae:	2300      	movs	r3, #0

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
 80a0bb0:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a0bb2:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a0bb4:	6043      	str	r3, [r0, #4]
	len = 0;
 80a0bb6:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a0bb8:	7303      	strb	r3, [r0, #12]
/*********************************************/

String::String(const char *cstr)
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
 80a0bba:	460d      	mov	r5, r1
 80a0bbc:	b139      	cbz	r1, 80a0bce <_ZN6StringC1EPKc+0x22>
 80a0bbe:	4608      	mov	r0, r1
 80a0bc0:	f000 fcb3 	bl	80a152a <strlen>
 80a0bc4:	4629      	mov	r1, r5
 80a0bc6:	4602      	mov	r2, r0
 80a0bc8:	4620      	mov	r0, r4
 80a0bca:	f7ff ffdc 	bl	80a0b86 <_ZN6String4copyEPKcj>
}
 80a0bce:	4620      	mov	r0, r4
 80a0bd0:	bd38      	pop	{r3, r4, r5, pc}

080a0bd2 <_ZN6StringaSERKS_>:
}
#endif

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
 80a0bd2:	4288      	cmp	r0, r1
	rhs.len = 0;
}
#endif

String & String::operator = (const String &rhs)
{
 80a0bd4:	b510      	push	{r4, lr}
 80a0bd6:	460b      	mov	r3, r1
 80a0bd8:	4604      	mov	r4, r0
	if (this == &rhs) return *this;
 80a0bda:	d007      	beq.n	80a0bec <_ZN6StringaSERKS_+0x1a>

	if (rhs.buffer) copy(rhs.buffer, rhs.len);
 80a0bdc:	6809      	ldr	r1, [r1, #0]
 80a0bde:	b119      	cbz	r1, 80a0be8 <_ZN6StringaSERKS_+0x16>
 80a0be0:	689a      	ldr	r2, [r3, #8]
 80a0be2:	f7ff ffd0 	bl	80a0b86 <_ZN6String4copyEPKcj>
 80a0be6:	e001      	b.n	80a0bec <_ZN6StringaSERKS_+0x1a>
	else invalidate();
 80a0be8:	f7ff ffa5 	bl	80a0b36 <_ZN6String10invalidateEv>

	return *this;
}
 80a0bec:	4620      	mov	r0, r4
 80a0bee:	bd10      	pop	{r4, pc}

080a0bf0 <_ZN6StringC1ERKS_>:
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
}

String::String(const String &value)
 80a0bf0:	b510      	push	{r4, lr}
 80a0bf2:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a0bf4:	2300      	movs	r3, #0
 80a0bf6:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a0bf8:	6043      	str	r3, [r0, #4]
	len = 0;
 80a0bfa:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a0bfc:	7303      	strb	r3, [r0, #12]
}

String::String(const String &value)
{
	init();
	*this = value;
 80a0bfe:	f7ff ffe8 	bl	80a0bd2 <_ZN6StringaSERKS_>
}
 80a0c02:	4620      	mov	r0, r4
 80a0c04:	bd10      	pop	{r4, pc}

080a0c06 <_ZN6StringaSEPKc>:
	return *this;
}
#endif

String & String::operator = (const char *cstr)
{
 80a0c06:	b538      	push	{r3, r4, r5, lr}
 80a0c08:	4605      	mov	r5, r0
	if (cstr) copy(cstr, strlen(cstr));
 80a0c0a:	460c      	mov	r4, r1
 80a0c0c:	b141      	cbz	r1, 80a0c20 <_ZN6StringaSEPKc+0x1a>
 80a0c0e:	4608      	mov	r0, r1
 80a0c10:	f000 fc8b 	bl	80a152a <strlen>
 80a0c14:	4621      	mov	r1, r4
 80a0c16:	4602      	mov	r2, r0
 80a0c18:	4628      	mov	r0, r5
 80a0c1a:	f7ff ffb4 	bl	80a0b86 <_ZN6String4copyEPKcj>
 80a0c1e:	e001      	b.n	80a0c24 <_ZN6StringaSEPKc+0x1e>
	else invalidate();
 80a0c20:	f7ff ff89 	bl	80a0b36 <_ZN6String10invalidateEv>

	return *this;
}
 80a0c24:	4628      	mov	r0, r5
 80a0c26:	bd38      	pop	{r3, r4, r5, pc}

080a0c28 <_ZN6StringC1Ec>:
	init();
	move(rval);
}
#endif

String::String(char c)
 80a0c28:	b513      	push	{r0, r1, r4, lr}
 80a0c2a:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a0c2c:	2300      	movs	r3, #0

String::String(char c)
{
	init();
	char buf[2];
	buf[0] = c;
 80a0c2e:	f88d 1004 	strb.w	r1, [sp, #4]
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a0c32:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a0c34:	6043      	str	r3, [r0, #4]
	len = 0;
 80a0c36:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a0c38:	7303      	strb	r3, [r0, #12]
{
	init();
	char buf[2];
	buf[0] = c;
	buf[1] = 0;
	*this = buf;
 80a0c3a:	a901      	add	r1, sp, #4
String::String(char c)
{
	init();
	char buf[2];
	buf[0] = c;
	buf[1] = 0;
 80a0c3c:	f88d 3005 	strb.w	r3, [sp, #5]
	*this = buf;
 80a0c40:	f7ff ffe1 	bl	80a0c06 <_ZN6StringaSEPKc>
}
 80a0c44:	4620      	mov	r0, r4
 80a0c46:	b002      	add	sp, #8
 80a0c48:	bd10      	pop	{r4, pc}

080a0c4a <_ZN6String6concatEPKcj>:
{
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
 80a0c4a:	b570      	push	{r4, r5, r6, lr}
 80a0c4c:	4604      	mov	r4, r0
	unsigned int newlen = len + length;
 80a0c4e:	6883      	ldr	r3, [r0, #8]
	if (!cstr) return 0;
 80a0c50:	460e      	mov	r6, r1
 80a0c52:	b909      	cbnz	r1, 80a0c58 <_ZN6String6concatEPKcj+0xe>
 80a0c54:	2000      	movs	r0, #0
 80a0c56:	bd70      	pop	{r4, r5, r6, pc}
	if (length == 0) return 1;
 80a0c58:	b162      	cbz	r2, 80a0c74 <_ZN6String6concatEPKcj+0x2a>
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
 80a0c5a:	18d5      	adds	r5, r2, r3
	if (!cstr) return 0;
	if (length == 0) return 1;
	if (!reserve(newlen)) return 0;
 80a0c5c:	4629      	mov	r1, r5
 80a0c5e:	f7ff ff81 	bl	80a0b64 <_ZN6String7reserveEj>
 80a0c62:	2800      	cmp	r0, #0
 80a0c64:	d0f6      	beq.n	80a0c54 <_ZN6String6concatEPKcj+0xa>
	strcpy(buffer + len, cstr);
 80a0c66:	6820      	ldr	r0, [r4, #0]
 80a0c68:	68a3      	ldr	r3, [r4, #8]
 80a0c6a:	4631      	mov	r1, r6
 80a0c6c:	4418      	add	r0, r3
 80a0c6e:	f000 fc54 	bl	80a151a <strcpy>
	len = newlen;
 80a0c72:	60a5      	str	r5, [r4, #8]

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
	if (!cstr) return 0;
	if (length == 0) return 1;
 80a0c74:	2001      	movs	r0, #1
	if (!reserve(newlen)) return 0;
	strcpy(buffer + len, cstr);
	len = newlen;
	return 1;
}
 80a0c76:	bd70      	pop	{r4, r5, r6, pc}

080a0c78 <_ZN6String6concatEc>:
	if (!cstr) return 0;
	return concat(cstr, strlen(cstr));
}

unsigned char String::concat(char c)
{
 80a0c78:	b507      	push	{r0, r1, r2, lr}
	char buf[2];
	buf[0] = c;
	buf[1] = 0;
 80a0c7a:	2300      	movs	r3, #0
}

unsigned char String::concat(char c)
{
	char buf[2];
	buf[0] = c;
 80a0c7c:	f88d 1004 	strb.w	r1, [sp, #4]
	buf[1] = 0;
	return concat(buf, 1);
 80a0c80:	2201      	movs	r2, #1
 80a0c82:	a901      	add	r1, sp, #4

unsigned char String::concat(char c)
{
	char buf[2];
	buf[0] = c;
	buf[1] = 0;
 80a0c84:	f88d 3005 	strb.w	r3, [sp, #5]
	return concat(buf, 1);
 80a0c88:	f7ff ffdf 	bl	80a0c4a <_ZN6String6concatEPKcj>
}
 80a0c8c:	b003      	add	sp, #12
 80a0c8e:	f85d fb04 	ldr.w	pc, [sp], #4

080a0c92 <_ZplRK15StringSumHelperRK6String>:
/*********************************************/
/*  Concatenate                              */
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
 80a0c92:	460b      	mov	r3, r1
 80a0c94:	b510      	push	{r4, lr}
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
 80a0c96:	689a      	ldr	r2, [r3, #8]
 80a0c98:	6809      	ldr	r1, [r1, #0]
/*********************************************/
/*  Concatenate                              */
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
 80a0c9a:	4604      	mov	r4, r0
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
 80a0c9c:	f7ff ffd5 	bl	80a0c4a <_ZN6String6concatEPKcj>
 80a0ca0:	b910      	cbnz	r0, 80a0ca8 <_ZplRK15StringSumHelperRK6String+0x16>
 80a0ca2:	4620      	mov	r0, r4
 80a0ca4:	f7ff ff47 	bl	80a0b36 <_ZN6String10invalidateEv>
	return a;
}
 80a0ca8:	4620      	mov	r0, r4
 80a0caa:	bd10      	pop	{r4, pc}

080a0cac <_ZNK6String6equalsEPKc>:
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
 80a0cac:	b508      	push	{r3, lr}
	if (len == 0) return (cstr == NULL || *cstr == 0);
 80a0cae:	6882      	ldr	r2, [r0, #8]
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
 80a0cb0:	460b      	mov	r3, r1
	if (len == 0) return (cstr == NULL || *cstr == 0);
 80a0cb2:	b912      	cbnz	r2, 80a0cba <_ZNK6String6equalsEPKc+0xe>
 80a0cb4:	b919      	cbnz	r1, 80a0cbe <_ZNK6String6equalsEPKc+0x12>
 80a0cb6:	2001      	movs	r0, #1
 80a0cb8:	bd08      	pop	{r3, pc}
	if (cstr == NULL) return buffer[0] == 0;
 80a0cba:	b911      	cbnz	r1, 80a0cc2 <_ZNK6String6equalsEPKc+0x16>
 80a0cbc:	6803      	ldr	r3, [r0, #0]
 80a0cbe:	7818      	ldrb	r0, [r3, #0]
 80a0cc0:	e002      	b.n	80a0cc8 <_ZNK6String6equalsEPKc+0x1c>
	return strcmp(buffer, cstr) == 0;
 80a0cc2:	6800      	ldr	r0, [r0, #0]
 80a0cc4:	f000 fc1f 	bl	80a1506 <strcmp>
 80a0cc8:	fab0 f080 	clz	r0, r0
 80a0ccc:	0940      	lsrs	r0, r0, #5
}
 80a0cce:	bd08      	pop	{r3, pc}

080a0cd0 <_ZNK6String10startsWithERKS_j>:
	if (len < s2.len) return 0;
	return startsWith(s2, 0);
}

unsigned char String::startsWith( const String &s2, unsigned int offset ) const
{
 80a0cd0:	b510      	push	{r4, lr}
 80a0cd2:	4614      	mov	r4, r2
	if (offset > len - s2.len || !buffer || !s2.buffer) return 0;
 80a0cd4:	6883      	ldr	r3, [r0, #8]
 80a0cd6:	688a      	ldr	r2, [r1, #8]
 80a0cd8:	1a9b      	subs	r3, r3, r2
 80a0cda:	429c      	cmp	r4, r3
 80a0cdc:	d80a      	bhi.n	80a0cf4 <_ZNK6String10startsWithERKS_j+0x24>
 80a0cde:	6800      	ldr	r0, [r0, #0]
 80a0ce0:	b158      	cbz	r0, 80a0cfa <_ZNK6String10startsWithERKS_j+0x2a>
 80a0ce2:	6809      	ldr	r1, [r1, #0]
 80a0ce4:	b141      	cbz	r1, 80a0cf8 <_ZNK6String10startsWithERKS_j+0x28>
	return strncmp( &buffer[offset], s2.buffer, s2.len ) == 0;
 80a0ce6:	4420      	add	r0, r4
 80a0ce8:	f000 fc27 	bl	80a153a <strncmp>
 80a0cec:	fab0 f080 	clz	r0, r0
 80a0cf0:	0940      	lsrs	r0, r0, #5
 80a0cf2:	bd10      	pop	{r4, pc}
	return startsWith(s2, 0);
}

unsigned char String::startsWith( const String &s2, unsigned int offset ) const
{
	if (offset > len - s2.len || !buffer || !s2.buffer) return 0;
 80a0cf4:	2000      	movs	r0, #0
 80a0cf6:	bd10      	pop	{r4, pc}
 80a0cf8:	4608      	mov	r0, r1
	return strncmp( &buffer[offset], s2.buffer, s2.len ) == 0;
}
 80a0cfa:	bd10      	pop	{r4, pc}

080a0cfc <_ZNK6String10startsWithERKS_>:
	return 1;
}

unsigned char String::startsWith( const String &s2 ) const
{
	if (len < s2.len) return 0;
 80a0cfc:	6882      	ldr	r2, [r0, #8]
 80a0cfe:	688b      	ldr	r3, [r1, #8]
 80a0d00:	429a      	cmp	r2, r3
 80a0d02:	d302      	bcc.n	80a0d0a <_ZNK6String10startsWithERKS_+0xe>
	return startsWith(s2, 0);
 80a0d04:	2200      	movs	r2, #0
 80a0d06:	f7ff bfe3 	b.w	80a0cd0 <_ZNK6String10startsWithERKS_j>
}
 80a0d0a:	2000      	movs	r0, #0
 80a0d0c:	4770      	bx	lr

080a0d0e <_ZNK6StringixEj>:
	return buffer[index];
}

char String::operator[]( unsigned int index ) const
{
	if (index >= len || !buffer) return 0;
 80a0d0e:	6883      	ldr	r3, [r0, #8]
 80a0d10:	4299      	cmp	r1, r3
 80a0d12:	d203      	bcs.n	80a0d1c <_ZNK6StringixEj+0xe>
 80a0d14:	6800      	ldr	r0, [r0, #0]
 80a0d16:	b110      	cbz	r0, 80a0d1e <_ZNK6StringixEj+0x10>
	return buffer[index];
 80a0d18:	5c40      	ldrb	r0, [r0, r1]
 80a0d1a:	4770      	bx	lr
	return buffer[index];
}

char String::operator[]( unsigned int index ) const
{
	if (index >= len || !buffer) return 0;
 80a0d1c:	2000      	movs	r0, #0
	return buffer[index];
}
 80a0d1e:	4770      	bx	lr

080a0d20 <_ZNK6String6charAtEj>:
/*  Character Access                         */
/*********************************************/

char String::charAt(unsigned int loc) const
{
	return operator[](loc);
 80a0d20:	f7ff bff5 	b.w	80a0d0e <_ZNK6StringixEj>

080a0d24 <_ZNK6String9substringEjj>:
{
	return substring(left, len);
}

String String::substring(unsigned int left, unsigned int right) const
{
 80a0d24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a0d28:	461c      	mov	r4, r3
	if (left > right) {
 80a0d2a:	429a      	cmp	r2, r3
 80a0d2c:	bf88      	it	hi
 80a0d2e:	4613      	movhi	r3, r2
{
	return substring(left, len);
}

String String::substring(unsigned int left, unsigned int right) const
{
 80a0d30:	460e      	mov	r6, r1
 80a0d32:	4615      	mov	r5, r2
	if (left > right) {
 80a0d34:	bf88      	it	hi
 80a0d36:	4625      	movhi	r5, r4
		unsigned int temp = right;
		right = left;
		left = temp;
	}
	String out;
 80a0d38:	490d      	ldr	r1, [pc, #52]	; (80a0d70 <_ZNK6String9substringEjj+0x4c>)
	return substring(left, len);
}

String String::substring(unsigned int left, unsigned int right) const
{
	if (left > right) {
 80a0d3a:	bf88      	it	hi
 80a0d3c:	461c      	movhi	r4, r3
{
	return substring(left, len);
}

String String::substring(unsigned int left, unsigned int right) const
{
 80a0d3e:	4607      	mov	r7, r0
	if (left > right) {
		unsigned int temp = right;
		right = left;
		left = temp;
	}
	String out;
 80a0d40:	f7ff ff34 	bl	80a0bac <_ZN6StringC1EPKc>
	if (left > len) return out;
 80a0d44:	68b1      	ldr	r1, [r6, #8]
 80a0d46:	428d      	cmp	r5, r1
 80a0d48:	d80f      	bhi.n	80a0d6a <_ZNK6String9substringEjj+0x46>
 80a0d4a:	428c      	cmp	r4, r1
 80a0d4c:	bf28      	it	cs
 80a0d4e:	460c      	movcs	r4, r1
	if (right > len) right = len;
	char temp = buffer[right];  // save the replaced character
 80a0d50:	6833      	ldr	r3, [r6, #0]
	buffer[right] = '\0';
 80a0d52:	2200      	movs	r2, #0
		left = temp;
	}
	String out;
	if (left > len) return out;
	if (right > len) right = len;
	char temp = buffer[right];  // save the replaced character
 80a0d54:	f813 8004 	ldrb.w	r8, [r3, r4]
	buffer[right] = '\0';
 80a0d58:	551a      	strb	r2, [r3, r4]
	out = buffer + left;  // pointer arithmetic
 80a0d5a:	6831      	ldr	r1, [r6, #0]
 80a0d5c:	4638      	mov	r0, r7
 80a0d5e:	4429      	add	r1, r5
 80a0d60:	f7ff ff51 	bl	80a0c06 <_ZN6StringaSEPKc>
	buffer[right] = temp;  //restore character
 80a0d64:	6833      	ldr	r3, [r6, #0]
 80a0d66:	f803 8004 	strb.w	r8, [r3, r4]
	return out;
}
 80a0d6a:	4638      	mov	r0, r7
 80a0d6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a0d70:	080a16b4 	.word	0x080a16b4

080a0d74 <_ZNK6String9substringEj>:
	}
	return found;
}

String String::substring( unsigned int left ) const
{
 80a0d74:	b510      	push	{r4, lr}
 80a0d76:	4604      	mov	r4, r0
	return substring(left, len);
 80a0d78:	688b      	ldr	r3, [r1, #8]
 80a0d7a:	f7ff ffd3 	bl	80a0d24 <_ZNK6String9substringEjj>
}
 80a0d7e:	4620      	mov	r0, r4
 80a0d80:	bd10      	pop	{r4, pc}

080a0d82 <_ZN6String4trimEv>:
        }
        return *this;
}

String& String::trim(void)
{
 80a0d82:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!buffer || len == 0) return *this;
 80a0d86:	6807      	ldr	r7, [r0, #0]
        }
        return *this;
}

String& String::trim(void)
{
 80a0d88:	4605      	mov	r5, r0
	if (!buffer || len == 0) return *this;
 80a0d8a:	b317      	cbz	r7, 80a0dd2 <_ZN6String4trimEv+0x50>
 80a0d8c:	6884      	ldr	r4, [r0, #8]
 80a0d8e:	b304      	cbz	r4, 80a0dd2 <_ZN6String4trimEv+0x50>
 80a0d90:	46b8      	mov	r8, r7
 80a0d92:	4646      	mov	r6, r8
	char *begin = buffer;
	while (isspace(*begin)) begin++;
 80a0d94:	7830      	ldrb	r0, [r6, #0]
 80a0d96:	f108 0801 	add.w	r8, r8, #1
 80a0d9a:	f000 fb97 	bl	80a14cc <isspace>
 80a0d9e:	2800      	cmp	r0, #0
 80a0da0:	d1f7      	bne.n	80a0d92 <_ZN6String4trimEv+0x10>
	char *end = buffer + len - 1;
 80a0da2:	3c01      	subs	r4, #1
 80a0da4:	443c      	add	r4, r7
	while (isspace(*end) && end >= begin) end--;
 80a0da6:	7820      	ldrb	r0, [r4, #0]
 80a0da8:	f000 fb90 	bl	80a14cc <isspace>
 80a0dac:	b948      	cbnz	r0, 80a0dc2 <_ZN6String4trimEv+0x40>
	len = end + 1 - begin;
 80a0dae:	1c62      	adds	r2, r4, #1
 80a0db0:	1b92      	subs	r2, r2, r6
	if (begin > buffer) memcpy(buffer, begin, len);
 80a0db2:	42be      	cmp	r6, r7
	if (!buffer || len == 0) return *this;
	char *begin = buffer;
	while (isspace(*begin)) begin++;
	char *end = buffer + len - 1;
	while (isspace(*end) && end >= begin) end--;
	len = end + 1 - begin;
 80a0db4:	60aa      	str	r2, [r5, #8]
	if (begin > buffer) memcpy(buffer, begin, len);
 80a0db6:	d908      	bls.n	80a0dca <_ZN6String4trimEv+0x48>
 80a0db8:	4638      	mov	r0, r7
 80a0dba:	4631      	mov	r1, r6
 80a0dbc:	f000 fb90 	bl	80a14e0 <memcpy>
 80a0dc0:	e003      	b.n	80a0dca <_ZN6String4trimEv+0x48>
{
	if (!buffer || len == 0) return *this;
	char *begin = buffer;
	while (isspace(*begin)) begin++;
	char *end = buffer + len - 1;
	while (isspace(*end) && end >= begin) end--;
 80a0dc2:	42b4      	cmp	r4, r6
 80a0dc4:	d3f3      	bcc.n	80a0dae <_ZN6String4trimEv+0x2c>
 80a0dc6:	3c01      	subs	r4, #1
 80a0dc8:	e7ed      	b.n	80a0da6 <_ZN6String4trimEv+0x24>
	len = end + 1 - begin;
	if (begin > buffer) memcpy(buffer, begin, len);
	buffer[len] = 0;
 80a0dca:	682a      	ldr	r2, [r5, #0]
 80a0dcc:	68ab      	ldr	r3, [r5, #8]
 80a0dce:	2100      	movs	r1, #0
 80a0dd0:	54d1      	strb	r1, [r2, r3]
        return *this;
}
 80a0dd2:	4628      	mov	r0, r5
 80a0dd4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a0dd8 <_ZNK6String5toIntEv>:
/*  Parsing / Conversion                     */
/*********************************************/

long String::toInt(void) const
{
	if (buffer) return atol(buffer);
 80a0dd8:	6800      	ldr	r0, [r0, #0]
 80a0dda:	b108      	cbz	r0, 80a0de0 <_ZNK6String5toIntEv+0x8>
 80a0ddc:	f000 bb64 	b.w	80a14a8 <atol>
	return 0;
}
 80a0de0:	4770      	bx	lr
	...

080a0de4 <_GLOBAL__sub_I_System>:
 80a0de4:	4b07      	ldr	r3, [pc, #28]	; (80a0e04 <_GLOBAL__sub_I_System+0x20>)
 80a0de6:	2000      	movs	r0, #0
 80a0de8:	4a07      	ldr	r2, [pc, #28]	; (80a0e08 <_GLOBAL__sub_I_System+0x24>)
 80a0dea:	7018      	strb	r0, [r3, #0]
 80a0dec:	2301      	movs	r3, #1
 80a0dee:	7013      	strb	r3, [r2, #0]
 80a0df0:	4a06      	ldr	r2, [pc, #24]	; (80a0e0c <_GLOBAL__sub_I_System+0x28>)
 80a0df2:	7010      	strb	r0, [r2, #0]
 80a0df4:	4a06      	ldr	r2, [pc, #24]	; (80a0e10 <_GLOBAL__sub_I_System+0x2c>)
 80a0df6:	7013      	strb	r3, [r2, #0]
 80a0df8:	4b06      	ldr	r3, [pc, #24]	; (80a0e14 <_GLOBAL__sub_I_System+0x30>)
 80a0dfa:	2202      	movs	r2, #2
 80a0dfc:	701a      	strb	r2, [r3, #0]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a0dfe:	f7ff bc4f 	b.w	80a06a0 <set_system_mode>
 80a0e02:	bf00      	nop
 80a0e04:	200003cc 	.word	0x200003cc
 80a0e08:	200003cd 	.word	0x200003cd
 80a0e0c:	200003ca 	.word	0x200003ca
 80a0e10:	200003cb 	.word	0x200003cb
 80a0e14:	200003c9 	.word	0x200003c9

080a0e18 <_GLOBAL__sub_I__ZN9TCPServerC2Etm>:
{
public:
    typedef uint8_t flag_t;
    inline SleepNetworkFlag(SystemSleepNetwork f) : SleepNetworkFlag(static_cast<flag_t>(f)) {}

    inline SleepNetworkFlag(flag_t flag) : flag_(flag) {}
 80a0e18:	4b06      	ldr	r3, [pc, #24]	; (80a0e34 <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x1c>)
 80a0e1a:	2200      	movs	r2, #0
 80a0e1c:	4906      	ldr	r1, [pc, #24]	; (80a0e38 <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x20>)
 80a0e1e:	701a      	strb	r2, [r3, #0]
 80a0e20:	2301      	movs	r3, #1
 80a0e22:	700b      	strb	r3, [r1, #0]
 80a0e24:	4905      	ldr	r1, [pc, #20]	; (80a0e3c <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x24>)
 80a0e26:	700a      	strb	r2, [r1, #0]
 80a0e28:	4a05      	ldr	r2, [pc, #20]	; (80a0e40 <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x28>)
 80a0e2a:	7013      	strb	r3, [r2, #0]
 80a0e2c:	4b05      	ldr	r3, [pc, #20]	; (80a0e44 <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x2c>)
 80a0e2e:	2202      	movs	r2, #2
 80a0e30:	701a      	strb	r2, [r3, #0]
 80a0e32:	4770      	bx	lr
 80a0e34:	200003d1 	.word	0x200003d1
 80a0e38:	200003d2 	.word	0x200003d2
 80a0e3c:	200003cf 	.word	0x200003cf
 80a0e40:	200003d0 	.word	0x200003d0
 80a0e44:	200003ce 	.word	0x200003ce

080a0e48 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a0e48:	4b02      	ldr	r3, [pc, #8]	; (80a0e54 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
 80a0e4a:	681a      	ldr	r2, [r3, #0]
 80a0e4c:	4b02      	ldr	r3, [pc, #8]	; (80a0e58 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
 80a0e4e:	601a      	str	r2, [r3, #0]
 80a0e50:	4770      	bx	lr
 80a0e52:	bf00      	nop
 80a0e54:	2000030c 	.word	0x2000030c
 80a0e58:	200003d4 	.word	0x200003d4

080a0e5c <_GLOBAL__sub_I_tone>:
 80a0e5c:	4b06      	ldr	r3, [pc, #24]	; (80a0e78 <_GLOBAL__sub_I_tone+0x1c>)
 80a0e5e:	2200      	movs	r2, #0
 80a0e60:	4906      	ldr	r1, [pc, #24]	; (80a0e7c <_GLOBAL__sub_I_tone+0x20>)
 80a0e62:	701a      	strb	r2, [r3, #0]
 80a0e64:	2301      	movs	r3, #1
 80a0e66:	700b      	strb	r3, [r1, #0]
 80a0e68:	4905      	ldr	r1, [pc, #20]	; (80a0e80 <_GLOBAL__sub_I_tone+0x24>)
 80a0e6a:	700a      	strb	r2, [r1, #0]
 80a0e6c:	4a05      	ldr	r2, [pc, #20]	; (80a0e84 <_GLOBAL__sub_I_tone+0x28>)
 80a0e6e:	7013      	strb	r3, [r2, #0]
 80a0e70:	4b05      	ldr	r3, [pc, #20]	; (80a0e88 <_GLOBAL__sub_I_tone+0x2c>)
 80a0e72:	2202      	movs	r2, #2
 80a0e74:	701a      	strb	r2, [r3, #0]
 80a0e76:	4770      	bx	lr
 80a0e78:	200003db 	.word	0x200003db
 80a0e7c:	200003dc 	.word	0x200003dc
 80a0e80:	200003d9 	.word	0x200003d9
 80a0e84:	200003da 	.word	0x200003da
 80a0e88:	200003d8 	.word	0x200003d8

080a0e8c <_GLOBAL__sub_I__ZN3UDPC2Ev>:
 80a0e8c:	4b06      	ldr	r3, [pc, #24]	; (80a0ea8 <_GLOBAL__sub_I__ZN3UDPC2Ev+0x1c>)
 80a0e8e:	2200      	movs	r2, #0
 80a0e90:	4906      	ldr	r1, [pc, #24]	; (80a0eac <_GLOBAL__sub_I__ZN3UDPC2Ev+0x20>)
 80a0e92:	701a      	strb	r2, [r3, #0]
 80a0e94:	2301      	movs	r3, #1
 80a0e96:	700b      	strb	r3, [r1, #0]
 80a0e98:	4905      	ldr	r1, [pc, #20]	; (80a0eb0 <_GLOBAL__sub_I__ZN3UDPC2Ev+0x24>)
 80a0e9a:	700a      	strb	r2, [r1, #0]
 80a0e9c:	4a05      	ldr	r2, [pc, #20]	; (80a0eb4 <_GLOBAL__sub_I__ZN3UDPC2Ev+0x28>)
 80a0e9e:	7013      	strb	r3, [r2, #0]
 80a0ea0:	4b05      	ldr	r3, [pc, #20]	; (80a0eb8 <_GLOBAL__sub_I__ZN3UDPC2Ev+0x2c>)
 80a0ea2:	2202      	movs	r2, #2
 80a0ea4:	701a      	strb	r2, [r3, #0]
 80a0ea6:	4770      	bx	lr
 80a0ea8:	200003e0 	.word	0x200003e0
 80a0eac:	200003e1 	.word	0x200003e1
 80a0eb0:	200003de 	.word	0x200003de
 80a0eb4:	200003df 	.word	0x200003df
 80a0eb8:	200003dd 	.word	0x200003dd

080a0ebc <_ZN11USARTSerialD1Ev>:
private:
  HAL_USART_Serial _serial;
  bool _blocking;
public:
  USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer);
  virtual ~USARTSerial() {};
 80a0ebc:	4770      	bx	lr

080a0ebe <_ZN11USARTSerial14blockOnOverrunEb>:
    HAL_USART_Half_Duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a0ebe:	7441      	strb	r1, [r0, #17]
 80a0ec0:	4770      	bx	lr

080a0ec2 <_ZN11USARTSerial17availableForWriteEv>:
}


int USARTSerial::availableForWrite(void)
{
  return HAL_USART_Available_Data(_serial);
 80a0ec2:	7c00      	ldrb	r0, [r0, #16]
 80a0ec4:	f7ff bba4 	b.w	80a0610 <HAL_USART_Available_Data>

080a0ec8 <_ZN11USARTSerial9availableEv>:
}

int USARTSerial::available(void)
{
  return HAL_USART_Available_Data(_serial);
 80a0ec8:	7c00      	ldrb	r0, [r0, #16]
 80a0eca:	f7ff bba1 	b.w	80a0610 <HAL_USART_Available_Data>

080a0ece <_ZN11USARTSerial4peekEv>:
}

int USARTSerial::peek(void)
{
  return HAL_USART_Peek_Data(_serial);
 80a0ece:	7c00      	ldrb	r0, [r0, #16]
 80a0ed0:	f7ff bbae 	b.w	80a0630 <HAL_USART_Peek_Data>

080a0ed4 <_ZN11USARTSerial4readEv>:
}

int USARTSerial::read(void)
{
  return HAL_USART_Read_Data(_serial);
 80a0ed4:	7c00      	ldrb	r0, [r0, #16]
 80a0ed6:	f7ff bba3 	b.w	80a0620 <HAL_USART_Read_Data>

080a0eda <_ZN11USARTSerial5flushEv>:
}

void USARTSerial::flush()
{
  HAL_USART_Flush_Data(_serial);
 80a0eda:	7c00      	ldrb	r0, [r0, #16]
 80a0edc:	f7ff bbb0 	b.w	80a0640 <HAL_USART_Flush_Data>

080a0ee0 <_ZN11USARTSerialD0Ev>:
 80a0ee0:	b510      	push	{r4, lr}
 80a0ee2:	4604      	mov	r4, r0
 80a0ee4:	f7ff f8d9 	bl	80a009a <_ZdlPv>
 80a0ee8:	4620      	mov	r0, r4
 80a0eea:	bd10      	pop	{r4, pc}

080a0eec <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
 80a0eec:	b570      	push	{r4, r5, r6, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a0eee:	7c45      	ldrb	r5, [r0, #17]
{
  HAL_USART_Flush_Data(_serial);
}

size_t USARTSerial::write(uint8_t c)
{
 80a0ef0:	4604      	mov	r4, r0
 80a0ef2:	460e      	mov	r6, r1
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a0ef4:	b925      	cbnz	r5, 80a0f00 <_ZN11USARTSerial5writeEh+0x14>
 80a0ef6:	7c00      	ldrb	r0, [r0, #16]
 80a0ef8:	f7ff fbb2 	bl	80a0660 <HAL_USART_Available_Data_For_Write>
 80a0efc:	2800      	cmp	r0, #0
 80a0efe:	dd05      	ble.n	80a0f0c <_ZN11USARTSerial5writeEh+0x20>
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a0f00:	7c20      	ldrb	r0, [r4, #16]
 80a0f02:	4631      	mov	r1, r6
  }
  return 0;
}
 80a0f04:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
size_t USARTSerial::write(uint8_t c)
{
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a0f08:	f7ff bb7a 	b.w	80a0600 <HAL_USART_Write_Data>
  }
  return 0;
}
 80a0f0c:	4628      	mov	r0, r5
 80a0f0e:	bd70      	pop	{r4, r5, r6, pc}

080a0f10 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>:
#include "spark_wiring_usartserial.h"
#include "spark_wiring_constants.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a0f10:	b510      	push	{r4, lr}
 80a0f12:	4604      	mov	r4, r0
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a0f14:	2000      	movs	r0, #0
 80a0f16:	6060      	str	r0, [r4, #4]
 80a0f18:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80a0f1c:	60a0      	str	r0, [r4, #8]
 80a0f1e:	4806      	ldr	r0, [pc, #24]	; (80a0f38 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_+0x28>)
{
  _serial = serial;
 80a0f20:	7421      	strb	r1, [r4, #16]
#include "spark_wiring_usartserial.h"
#include "spark_wiring_constants.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a0f22:	6020      	str	r0, [r4, #0]
{
  _serial = serial;
  // Default is blocking mode
  _blocking = true;
 80a0f24:	2001      	movs	r0, #1
 80a0f26:	7460      	strb	r0, [r4, #17]
  HAL_USART_Init(serial, rx_buffer, tx_buffer);
 80a0f28:	4608      	mov	r0, r1
 80a0f2a:	4611      	mov	r1, r2
 80a0f2c:	461a      	mov	r2, r3
 80a0f2e:	f7ff fb5f 	bl	80a05f0 <HAL_USART_Init>
}
 80a0f32:	4620      	mov	r0, r4
 80a0f34:	bd10      	pop	{r4, pc}
 80a0f36:	bf00      	nop
 80a0f38:	080a1750 	.word	0x080a1750

080a0f3c <_ZN11USARTSerial5beginEmm>:
  begin(baud, SERIAL_8N1);
}

void USARTSerial::begin(unsigned long baud, uint32_t config)
{
  HAL_USART_BeginConfig(_serial, baud, config, 0);
 80a0f3c:	7c00      	ldrb	r0, [r0, #16]
 80a0f3e:	2300      	movs	r3, #0
 80a0f40:	f7ff bba6 	b.w	80a0690 <HAL_USART_BeginConfig>

080a0f44 <_ZN11USARTSerial5beginEm>:
}
// Public Methods //////////////////////////////////////////////////////////////

void USARTSerial::begin(unsigned long baud)
{
  begin(baud, SERIAL_8N1);
 80a0f44:	2200      	movs	r2, #0
 80a0f46:	f7ff bff9 	b.w	80a0f3c <_ZN11USARTSerial5beginEmm>

080a0f4a <_ZN11USARTSerial9isEnabledEv>:
USARTSerial::operator bool() {
  return true;
}

bool USARTSerial::isEnabled() {
  return HAL_USART_Is_Enabled(_serial);
 80a0f4a:	7c00      	ldrb	r0, [r0, #16]
 80a0f4c:	f7ff bb80 	b.w	80a0650 <HAL_USART_Is_Enabled>

080a0f50 <_Z22__fetch_global_Serial1v>:
// Preinstantiate Objects //////////////////////////////////////////////////////
static Ring_Buffer serial1_rx_buffer;
static Ring_Buffer serial1_tx_buffer;

USARTSerial& __fetch_global_Serial1()
{
 80a0f50:	b538      	push	{r3, r4, r5, lr}
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
 80a0f52:	4d0c      	ldr	r5, [pc, #48]	; (80a0f84 <_Z22__fetch_global_Serial1v+0x34>)
 80a0f54:	6829      	ldr	r1, [r5, #0]
 80a0f56:	f011 0401 	ands.w	r4, r1, #1
 80a0f5a:	d111      	bne.n	80a0f80 <_Z22__fetch_global_Serial1v+0x30>
 80a0f5c:	4628      	mov	r0, r5
 80a0f5e:	f7ff f89e 	bl	80a009e <__cxa_guard_acquire>
 80a0f62:	b168      	cbz	r0, 80a0f80 <_Z22__fetch_global_Serial1v+0x30>
 80a0f64:	4621      	mov	r1, r4
 80a0f66:	4a08      	ldr	r2, [pc, #32]	; (80a0f88 <_Z22__fetch_global_Serial1v+0x38>)
 80a0f68:	4b08      	ldr	r3, [pc, #32]	; (80a0f8c <_Z22__fetch_global_Serial1v+0x3c>)
 80a0f6a:	4809      	ldr	r0, [pc, #36]	; (80a0f90 <_Z22__fetch_global_Serial1v+0x40>)
 80a0f6c:	f7ff ffd0 	bl	80a0f10 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>
 80a0f70:	4628      	mov	r0, r5
 80a0f72:	f7ff f899 	bl	80a00a8 <__cxa_guard_release>
 80a0f76:	4806      	ldr	r0, [pc, #24]	; (80a0f90 <_Z22__fetch_global_Serial1v+0x40>)
 80a0f78:	4906      	ldr	r1, [pc, #24]	; (80a0f94 <_Z22__fetch_global_Serial1v+0x44>)
 80a0f7a:	4a07      	ldr	r2, [pc, #28]	; (80a0f98 <_Z22__fetch_global_Serial1v+0x48>)
 80a0f7c:	f000 f9ca 	bl	80a1314 <__aeabi_atexit>
	return serial1;
}
 80a0f80:	4803      	ldr	r0, [pc, #12]	; (80a0f90 <_Z22__fetch_global_Serial1v+0x40>)
 80a0f82:	bd38      	pop	{r3, r4, r5, pc}
 80a0f84:	2000047c 	.word	0x2000047c
 80a0f88:	20000480 	.word	0x20000480
 80a0f8c:	200003f8 	.word	0x200003f8
 80a0f90:	200003e4 	.word	0x200003e4
 80a0f94:	080a0ebd 	.word	0x080a0ebd
 80a0f98:	20000378 	.word	0x20000378

080a0f9c <_ZN9USBSerial14blockOnOverrunEb>:
  USB_USART_Flush_Data();
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a0f9c:	7401      	strb	r1, [r0, #16]
 80a0f9e:	4770      	bx	lr

080a0fa0 <_ZN9USBSerialD1Ev>:

#include "spark_wiring_stream.h"
#include "usb_hal.h"
#include "system_task.h"

class USBSerial : public Stream
 80a0fa0:	4770      	bx	lr

080a0fa2 <_ZN9USBSerial4readEv>:


// Read data from buffer
int USBSerial::read()
{
	return USB_USART_Receive_Data(false);
 80a0fa2:	2000      	movs	r0, #0
 80a0fa4:	f7ff bb14 	b.w	80a05d0 <USB_USART_Receive_Data>

080a0fa8 <_ZN9USBSerial4peekEv>:
  _blocking = block;
}

int USBSerial::peek()
{
	return USB_USART_Receive_Data(true);
 80a0fa8:	2001      	movs	r0, #1
 80a0faa:	f7ff bb11 	b.w	80a05d0 <USB_USART_Receive_Data>

080a0fae <_ZN9USBSerial17availableForWriteEv>:
	return USB_USART_Receive_Data(false);
}

int USBSerial::availableForWrite()
{
  return USB_USART_Available_Data_For_Write();
 80a0fae:	f7ff bb5f 	b.w	80a0670 <USB_USART_Available_Data_For_Write>

080a0fb2 <_ZN9USBSerial9availableEv>:
}

int USBSerial::available()
{
 80a0fb2:	b508      	push	{r3, lr}
	return USB_USART_Available_Data();
 80a0fb4:	f7ff fb04 	bl	80a05c0 <USB_USART_Available_Data>
}
 80a0fb8:	bd08      	pop	{r3, pc}

080a0fba <_ZN9USBSerial5writeEh>:

size_t USBSerial::write(uint8_t byte)
{
 80a0fba:	b538      	push	{r3, r4, r5, lr}
 80a0fbc:	4605      	mov	r5, r0
 80a0fbe:	460c      	mov	r4, r1
  if (USB_USART_Available_Data_For_Write() > 0 || _blocking) {
 80a0fc0:	f7ff fb56 	bl	80a0670 <USB_USART_Available_Data_For_Write>
 80a0fc4:	2800      	cmp	r0, #0
 80a0fc6:	dc01      	bgt.n	80a0fcc <_ZN9USBSerial5writeEh+0x12>
 80a0fc8:	7c28      	ldrb	r0, [r5, #16]
 80a0fca:	b118      	cbz	r0, 80a0fd4 <_ZN9USBSerial5writeEh+0x1a>
    USB_USART_Send_Data(byte);
 80a0fcc:	4620      	mov	r0, r4
 80a0fce:	f7ff fb07 	bl	80a05e0 <USB_USART_Send_Data>
    return 1;
 80a0fd2:	2001      	movs	r0, #1
  }
  return 0;
}
 80a0fd4:	bd38      	pop	{r3, r4, r5, pc}

080a0fd6 <_ZN9USBSerial5flushEv>:

void USBSerial::flush()
{
  USB_USART_Flush_Data();
 80a0fd6:	f7ff bb53 	b.w	80a0680 <USB_USART_Flush_Data>

080a0fda <_ZN9USBSerialD0Ev>:
 80a0fda:	b510      	push	{r4, lr}
 80a0fdc:	4604      	mov	r4, r0
 80a0fde:	f7ff f85c 	bl	80a009a <_ZdlPv>
 80a0fe2:	4620      	mov	r0, r4
 80a0fe4:	bd10      	pop	{r4, pc}
	...

080a0fe8 <_ZN9USBSerialC1Ev>:
 80a0fe8:	2200      	movs	r2, #0
 80a0fea:	6042      	str	r2, [r0, #4]
 80a0fec:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a0ff0:	6082      	str	r2, [r0, #8]
#include "spark_wiring_usbserial.h"

//
// Constructor
//
USBSerial::USBSerial()
 80a0ff2:	4a02      	ldr	r2, [pc, #8]	; (80a0ffc <_ZN9USBSerialC1Ev+0x14>)
 80a0ff4:	6002      	str	r2, [r0, #0]
{
  _blocking = true;
 80a0ff6:	2201      	movs	r2, #1
 80a0ff8:	7402      	strb	r2, [r0, #16]
}
 80a0ffa:	4770      	bx	lr
 80a0ffc:	080a1780 	.word	0x080a1780

080a1000 <_ZN9USBSerial5beginEl>:
// Public methods
//

void USBSerial::begin(long speed)
{
    USB_USART_Init((unsigned)speed);
 80a1000:	4608      	mov	r0, r1
 80a1002:	f7ff bad5 	b.w	80a05b0 <USB_USART_Init>
	...

080a1008 <_Z20_fetch_global_serialv>:
}

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL
USBSerial& _fetch_global_serial()
{
 80a1008:	b510      	push	{r4, lr}
	static USBSerial _globalSerial;
 80a100a:	4c0a      	ldr	r4, [pc, #40]	; (80a1034 <_Z20_fetch_global_serialv+0x2c>)
 80a100c:	6823      	ldr	r3, [r4, #0]
 80a100e:	07db      	lsls	r3, r3, #31
 80a1010:	d40e      	bmi.n	80a1030 <_Z20_fetch_global_serialv+0x28>
 80a1012:	4620      	mov	r0, r4
 80a1014:	f7ff f843 	bl	80a009e <__cxa_guard_acquire>
 80a1018:	b150      	cbz	r0, 80a1030 <_Z20_fetch_global_serialv+0x28>
 80a101a:	4807      	ldr	r0, [pc, #28]	; (80a1038 <_Z20_fetch_global_serialv+0x30>)
 80a101c:	f7ff ffe4 	bl	80a0fe8 <_ZN9USBSerialC1Ev>
 80a1020:	4620      	mov	r0, r4
 80a1022:	f7ff f841 	bl	80a00a8 <__cxa_guard_release>
 80a1026:	4804      	ldr	r0, [pc, #16]	; (80a1038 <_Z20_fetch_global_serialv+0x30>)
 80a1028:	4904      	ldr	r1, [pc, #16]	; (80a103c <_Z20_fetch_global_serialv+0x34>)
 80a102a:	4a05      	ldr	r2, [pc, #20]	; (80a1040 <_Z20_fetch_global_serialv+0x38>)
 80a102c:	f000 f972 	bl	80a1314 <__aeabi_atexit>
	return _globalSerial;
}
 80a1030:	4801      	ldr	r0, [pc, #4]	; (80a1038 <_Z20_fetch_global_serialv+0x30>)
 80a1032:	bd10      	pop	{r4, pc}
 80a1034:	20000518 	.word	0x20000518
 80a1038:	20000504 	.word	0x20000504
 80a103c:	080a0fa1 	.word	0x080a0fa1
 80a1040:	20000378 	.word	0x20000378

080a1044 <_ZN5spark9WiFiClassD1Ev>:
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
    ~WiFiClass() {}
 80a1044:	4770      	bx	lr

080a1046 <_ZN5spark9WiFiClass5readyEv>:
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
 80a1046:	2000      	movs	r0, #0
 80a1048:	4601      	mov	r1, r0
 80a104a:	4602      	mov	r2, r0
 80a104c:	f7ff bb40 	b.w	80a06d0 <network_ready>

080a1050 <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj>:
    void setIPAddressSource(IPAddressSource source) {
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
 80a1050:	4803      	ldr	r0, [pc, #12]	; (80a1060 <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x10>)
 80a1052:	4b04      	ldr	r3, [pc, #16]	; (80a1064 <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x14>)
one second timeout is reached). If the aforementioned "bug" is ever fixed by
TI, no changes need to be made to this function, as it would be implemented
the same way.
*****************************************************************************/

    WiFiClass WiFi;
 80a1054:	4904      	ldr	r1, [pc, #16]	; (80a1068 <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x18>)
 80a1056:	4a05      	ldr	r2, [pc, #20]	; (80a106c <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x1c>)
 80a1058:	6003      	str	r3, [r0, #0]
 80a105a:	f000 b95b 	b.w	80a1314 <__aeabi_atexit>
 80a105e:	bf00      	nop
 80a1060:	2000051c 	.word	0x2000051c
 80a1064:	080a17b0 	.word	0x080a17b0
 80a1068:	080a1045 	.word	0x080a1045
 80a106c:	20000378 	.word	0x20000378

080a1070 <serialEventRun>:

/**
 * Provides background processing of serial data.
 */
void serialEventRun()
{
 80a1070:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
 80a1072:	4b0f      	ldr	r3, [pc, #60]	; (80a10b0 <serialEventRun+0x40>)
 80a1074:	b133      	cbz	r3, 80a1084 <serialEventRun+0x14>
 80a1076:	f7ff ffc7 	bl	80a1008 <_Z20_fetch_global_serialv>
 80a107a:	6803      	ldr	r3, [r0, #0]
 80a107c:	691b      	ldr	r3, [r3, #16]
 80a107e:	4798      	blx	r3
 80a1080:	2800      	cmp	r0, #0
 80a1082:	dc0d      	bgt.n	80a10a0 <serialEventRun+0x30>
        serialEvent();

    if (serialEvent1 && Serial1.available()>0)
 80a1084:	4b0b      	ldr	r3, [pc, #44]	; (80a10b4 <serialEventRun+0x44>)
 80a1086:	b133      	cbz	r3, 80a1096 <serialEventRun+0x26>
 80a1088:	f7ff ff62 	bl	80a0f50 <_Z22__fetch_global_Serial1v>
 80a108c:	6803      	ldr	r3, [r0, #0]
 80a108e:	691b      	ldr	r3, [r3, #16]
 80a1090:	4798      	blx	r3
 80a1092:	2800      	cmp	r0, #0
 80a1094:	dc07      	bgt.n	80a10a6 <serialEventRun+0x36>
        serialEvent1();

#if Wiring_Serial2
    if (serialEventRun2) serialEventRun2();
 80a1096:	4b08      	ldr	r3, [pc, #32]	; (80a10b8 <serialEventRun+0x48>)
 80a1098:	b143      	cbz	r3, 80a10ac <serialEventRun+0x3c>
 80a109a:	f3af 8000 	nop.w
 80a109e:	bd08      	pop	{r3, pc}
 * Provides background processing of serial data.
 */
void serialEventRun()
{
    if (serialEvent && Serial.available()>0)
        serialEvent();
 80a10a0:	f3af 8000 	nop.w
 80a10a4:	e7ee      	b.n	80a1084 <serialEventRun+0x14>

    if (serialEvent1 && Serial1.available()>0)
        serialEvent1();
 80a10a6:	f3af 8000 	nop.w
 80a10aa:	e7f4      	b.n	80a1096 <serialEventRun+0x26>
 80a10ac:	bd08      	pop	{r3, pc}
 80a10ae:	bf00      	nop
	...

080a10bc <_post_loop>:
#if Wiring_Serial5
void serialEvent5() __attribute__((weak));
#endif

void _post_loop()
{
 80a10bc:	b508      	push	{r3, lr}
	serialEventRun();
 80a10be:	f7ff ffd7 	bl	80a1070 <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a10c2:	f7ff f9f3 	bl	80a04ac <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a10c6:	4b01      	ldr	r3, [pc, #4]	; (80a10cc <_post_loop+0x10>)
 80a10c8:	6018      	str	r0, [r3, #0]
 80a10ca:	bd08      	pop	{r3, pc}
 80a10cc:	20000528 	.word	0x20000528

080a10d0 <_Z33system_initialize_user_backup_ramv>:
 * the dynamically linked application module.
 */
void system_initialize_user_backup_ram()
{
    size_t len = &link_global_retained_end-&link_global_retained_start;
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a10d0:	4802      	ldr	r0, [pc, #8]	; (80a10dc <_Z33system_initialize_user_backup_ramv+0xc>)
 80a10d2:	4a03      	ldr	r2, [pc, #12]	; (80a10e0 <_Z33system_initialize_user_backup_ramv+0x10>)
 80a10d4:	4903      	ldr	r1, [pc, #12]	; (80a10e4 <_Z33system_initialize_user_backup_ramv+0x14>)
 80a10d6:	1a12      	subs	r2, r2, r0
 80a10d8:	f000 ba02 	b.w	80a14e0 <memcpy>
 80a10dc:	40024000 	.word	0x40024000
 80a10e0:	40024004 	.word	0x40024004
 80a10e4:	080a1910 	.word	0x080a1910

080a10e8 <module_user_init_hook>:

#endif


void module_user_init_hook()
{
 80a10e8:	b538      	push	{r3, r4, r5, lr}
#if PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ =  __backup_sram_signature==signature;
 80a10ea:	4c09      	ldr	r4, [pc, #36]	; (80a1110 <module_user_init_hook+0x28>)
 80a10ec:	4d09      	ldr	r5, [pc, #36]	; (80a1114 <module_user_init_hook+0x2c>)
 80a10ee:	6823      	ldr	r3, [r4, #0]
 80a10f0:	1b5a      	subs	r2, r3, r5
 80a10f2:	4253      	negs	r3, r2
 80a10f4:	4153      	adcs	r3, r2
 80a10f6:	4a08      	ldr	r2, [pc, #32]	; (80a1118 <module_user_init_hook+0x30>)
 80a10f8:	7013      	strb	r3, [r2, #0]
    if (!backup_ram_was_valid_) {
 80a10fa:	b913      	cbnz	r3, 80a1102 <module_user_init_hook+0x1a>
        system_initialize_user_backup_ram();
 80a10fc:	f7ff ffe8 	bl	80a10d0 <_Z33system_initialize_user_backup_ramv>
        __backup_sram_signature = signature;
 80a1100:	6025      	str	r5, [r4, #0]
    /* for dynamically linked user part, set the random seed if the user
     * app defines random_seed_from_cloud.
     */
// todo - add a RNG define for that capability
#if defined(STM32F2XX)
    if (random_seed_from_cloud) {
 80a1102:	4b06      	ldr	r3, [pc, #24]	; (80a111c <module_user_init_hook+0x34>)
 80a1104:	b11b      	cbz	r3, 80a110e <module_user_init_hook+0x26>
    		uint32_t seed = HAL_RNG_GetRandomNumber();
 80a1106:	f7ff f9c9 	bl	80a049c <HAL_RNG_GetRandomNumber>
    		random_seed_from_cloud(seed);
 80a110a:	f3af 8000 	nop.w
 80a110e:	bd38      	pop	{r3, r4, r5, pc}
 80a1110:	40024000 	.word	0x40024000
 80a1114:	9a271c1e 	.word	0x9a271c1e
 80a1118:	20000520 	.word	0x20000520
 80a111c:	00000000 	.word	0x00000000

080a1120 <pinAvailable>:

/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
 80a1120:	b510      	push	{r4, lr}
 80a1122:	4604      	mov	r4, r0

  // SPI safety check
#ifndef SPARK_WIRING_NO_SPI
  if(SPI.isEnabled() == true && (pin == SCK || pin == MOSI || pin == MISO))
 80a1124:	480f      	ldr	r0, [pc, #60]	; (80a1164 <pinAvailable+0x44>)
 80a1126:	f7ff fccb 	bl	80a0ac0 <_ZN8SPIClass9isEnabledEv>
 80a112a:	b128      	cbz	r0, 80a1138 <pinAvailable+0x18>
 80a112c:	f1a4 030d 	sub.w	r3, r4, #13
 80a1130:	2b02      	cmp	r3, #2
 80a1132:	d801      	bhi.n	80a1138 <pinAvailable+0x18>
  {
    return 0; // 'pin' is used
 80a1134:	2000      	movs	r0, #0
 80a1136:	bd10      	pop	{r4, pc}
  }
#endif
  // I2C safety check
#ifndef SPARK_WIRING_NO_I2C
  if(Wire.isEnabled() == true && (pin == SCL || pin == SDA))
 80a1138:	f000 f87c 	bl	80a1234 <_Z19__fetch_global_Wirev>
 80a113c:	f7ff fbb4 	bl	80a08a8 <_ZN7TwoWire9isEnabledEv>
 80a1140:	b108      	cbz	r0, 80a1146 <pinAvailable+0x26>
 80a1142:	2c01      	cmp	r4, #1
 80a1144:	d9f6      	bls.n	80a1134 <pinAvailable+0x14>
    return 0; // 'pin' is used
  }
#endif
#ifndef SPARK_WIRING_NO_USART_SERIAL
  // Serial1 safety check
  if(Serial1.isEnabled() == true && (pin == RX || pin == TX))
 80a1146:	f7ff ff03 	bl	80a0f50 <_Z22__fetch_global_Serial1v>
 80a114a:	f7ff fefe 	bl	80a0f4a <_ZN11USARTSerial9isEnabledEv>
 80a114e:	b118      	cbz	r0, 80a1158 <pinAvailable+0x38>
 80a1150:	f1a4 0312 	sub.w	r3, r4, #18
 80a1154:	2b01      	cmp	r3, #1
 80a1156:	d9ed      	bls.n	80a1134 <pinAvailable+0x14>
  {
    return 0; // 'pin' is used
  }
#endif

  if (pin >= TOTAL_PINS)
 80a1158:	2c17      	cmp	r4, #23
 80a115a:	bf8c      	ite	hi
 80a115c:	2000      	movhi	r0, #0
 80a115e:	2001      	movls	r0, #1
    return 0;
  else
    return 1; // 'pin' is available
}
 80a1160:	bd10      	pop	{r4, pc}
 80a1162:	bf00      	nop
 80a1164:	2000056c 	.word	0x2000056c

080a1168 <pinMode>:
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a1168:	2817      	cmp	r0, #23
/*
 * @brief Set the mode of the pin to OUTPUT, INPUT, INPUT_PULLUP,
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{
 80a116a:	b538      	push	{r3, r4, r5, lr}
 80a116c:	4605      	mov	r5, r0
 80a116e:	460c      	mov	r4, r1

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a1170:	d80a      	bhi.n	80a1188 <pinMode+0x20>
 80a1172:	29ff      	cmp	r1, #255	; 0xff
 80a1174:	d008      	beq.n	80a1188 <pinMode+0x20>
  {
    return;
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a1176:	f7ff ffd3 	bl	80a1120 <pinAvailable>
 80a117a:	b128      	cbz	r0, 80a1188 <pinMode+0x20>
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a117c:	4628      	mov	r0, r5
 80a117e:	4621      	mov	r1, r4
}
 80a1180:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a1184:	f7ff b9aa 	b.w	80a04dc <HAL_Pin_Mode>
 80a1188:	bd38      	pop	{r3, r4, r5, pc}

080a118a <_Z11analogWritett>:
/*
 * @brief Should take an integer 0-255 and create a 500Hz PWM signal with a duty cycle from 0-100%.
 * On Photon, DAC1 and DAC2 act as true analog outputs(values: 0 to 4095) using onchip DAC peripheral
 */
void analogWrite(pin_t pin, uint16_t value)
{
 80a118a:	b538      	push	{r3, r4, r5, lr}
 80a118c:	4604      	mov	r4, r0
 80a118e:	460d      	mov	r5, r1
    // Safety check
    if (!pinAvailable(pin))
 80a1190:	f7ff ffc6 	bl	80a1120 <pinAvailable>
 80a1194:	b1e8      	cbz	r0, 80a11d2 <_Z11analogWritett+0x48>
    {
        return;
    }

    if (HAL_Validate_Pin_Function(pin, PF_DAC) == PF_DAC)
 80a1196:	4620      	mov	r0, r4
 80a1198:	2104      	movs	r1, #4
 80a119a:	f7ff f997 	bl	80a04cc <HAL_Validate_Pin_Function>
 80a119e:	2804      	cmp	r0, #4
    {
        HAL_DAC_Write(pin, value);
 80a11a0:	4620      	mov	r0, r4
    if (!pinAvailable(pin))
    {
        return;
    }

    if (HAL_Validate_Pin_Function(pin, PF_DAC) == PF_DAC)
 80a11a2:	d104      	bne.n	80a11ae <_Z11analogWritett+0x24>
    {
        HAL_DAC_Write(pin, value);
 80a11a4:	4629      	mov	r1, r5
            return;
        }

        HAL_PWM_Write(pin, value);
    }
}
 80a11a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        return;
    }

    if (HAL_Validate_Pin_Function(pin, PF_DAC) == PF_DAC)
    {
        HAL_DAC_Write(pin, value);
 80a11aa:	f7ff b9a7 	b.w	80a04fc <HAL_DAC_Write>
    }
    else if (HAL_Validate_Pin_Function(pin, PF_TIMER) == PF_TIMER)
 80a11ae:	2102      	movs	r1, #2
 80a11b0:	f7ff f98c 	bl	80a04cc <HAL_Validate_Pin_Function>
 80a11b4:	2802      	cmp	r0, #2
 80a11b6:	d10c      	bne.n	80a11d2 <_Z11analogWritett+0x48>
    {
        PinMode mode = HAL_Get_Pin_Mode(pin);
 80a11b8:	4620      	mov	r0, r4
 80a11ba:	f7ff f997 	bl	80a04ec <HAL_Get_Pin_Mode>

        if (mode != OUTPUT && mode != AF_OUTPUT_PUSHPULL)
 80a11be:	2801      	cmp	r0, #1
 80a11c0:	d001      	beq.n	80a11c6 <_Z11analogWritett+0x3c>
 80a11c2:	2804      	cmp	r0, #4
 80a11c4:	d105      	bne.n	80a11d2 <_Z11analogWritett+0x48>
        {
            return;
        }

        HAL_PWM_Write(pin, value);
 80a11c6:	4620      	mov	r0, r4
 80a11c8:	b2e9      	uxtb	r1, r5
    }
}
 80a11ca:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        if (mode != OUTPUT && mode != AF_OUTPUT_PUSHPULL)
        {
            return;
        }

        HAL_PWM_Write(pin, value);
 80a11ce:	f7ff b99d 	b.w	80a050c <HAL_PWM_Write>
 80a11d2:	bd38      	pop	{r3, r4, r5, pc}

080a11d4 <_GLOBAL__sub_I_pinMode>:
{
public:
    typedef uint8_t flag_t;
    inline SleepNetworkFlag(SystemSleepNetwork f) : SleepNetworkFlag(static_cast<flag_t>(f)) {}

    inline SleepNetworkFlag(flag_t flag) : flag_(flag) {}
 80a11d4:	4b06      	ldr	r3, [pc, #24]	; (80a11f0 <_GLOBAL__sub_I_pinMode+0x1c>)
 80a11d6:	2200      	movs	r2, #0
 80a11d8:	4906      	ldr	r1, [pc, #24]	; (80a11f4 <_GLOBAL__sub_I_pinMode+0x20>)
 80a11da:	701a      	strb	r2, [r3, #0]
 80a11dc:	2301      	movs	r3, #1
 80a11de:	700b      	strb	r3, [r1, #0]

class PublishFlag
{
public:
	typedef uint8_t flag_t;
	PublishFlag(flag_t flag) : flag_(flag) {}
 80a11e0:	4905      	ldr	r1, [pc, #20]	; (80a11f8 <_GLOBAL__sub_I_pinMode+0x24>)
 80a11e2:	700a      	strb	r2, [r1, #0]
 80a11e4:	4a05      	ldr	r2, [pc, #20]	; (80a11fc <_GLOBAL__sub_I_pinMode+0x28>)
 80a11e6:	7013      	strb	r3, [r2, #0]
 80a11e8:	4b05      	ldr	r3, [pc, #20]	; (80a1200 <_GLOBAL__sub_I_pinMode+0x2c>)
 80a11ea:	2202      	movs	r2, #2
 80a11ec:	701a      	strb	r2, [r3, #0]
 80a11ee:	4770      	bx	lr
 80a11f0:	20000524 	.word	0x20000524
 80a11f4:	20000525 	.word	0x20000525
 80a11f8:	20000522 	.word	0x20000522
 80a11fc:	20000523 	.word	0x20000523
 80a1200:	20000521 	.word	0x20000521

080a1204 <_GLOBAL__sub_I_Particle>:
 80a1204:	4b06      	ldr	r3, [pc, #24]	; (80a1220 <_GLOBAL__sub_I_Particle+0x1c>)
 80a1206:	2200      	movs	r2, #0
 80a1208:	4906      	ldr	r1, [pc, #24]	; (80a1224 <_GLOBAL__sub_I_Particle+0x20>)
 80a120a:	701a      	strb	r2, [r3, #0]
 80a120c:	2301      	movs	r3, #1
 80a120e:	700b      	strb	r3, [r1, #0]
 80a1210:	4905      	ldr	r1, [pc, #20]	; (80a1228 <_GLOBAL__sub_I_Particle+0x24>)
 80a1212:	700a      	strb	r2, [r1, #0]
 80a1214:	4a05      	ldr	r2, [pc, #20]	; (80a122c <_GLOBAL__sub_I_Particle+0x28>)
 80a1216:	7013      	strb	r3, [r2, #0]
 80a1218:	4b05      	ldr	r3, [pc, #20]	; (80a1230 <_GLOBAL__sub_I_Particle+0x2c>)
 80a121a:	2202      	movs	r2, #2
 80a121c:	701a      	strb	r2, [r3, #0]
 80a121e:	4770      	bx	lr
 80a1220:	2000052f 	.word	0x2000052f
 80a1224:	20000530 	.word	0x20000530
 80a1228:	2000052d 	.word	0x2000052d
 80a122c:	2000052e 	.word	0x2000052e
 80a1230:	2000052c 	.word	0x2000052c

080a1234 <_Z19__fetch_global_Wirev>:
#include "i2c_hal.h"

#ifndef SPARK_WIRING_NO_I2C

TwoWire& __fetch_global_Wire()
{
 80a1234:	b538      	push	{r3, r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1);
 80a1236:	4d0b      	ldr	r5, [pc, #44]	; (80a1264 <_Z19__fetch_global_Wirev+0x30>)
 80a1238:	6829      	ldr	r1, [r5, #0]
 80a123a:	f011 0401 	ands.w	r4, r1, #1
 80a123e:	d10f      	bne.n	80a1260 <_Z19__fetch_global_Wirev+0x2c>
 80a1240:	4628      	mov	r0, r5
 80a1242:	f7fe ff2c 	bl	80a009e <__cxa_guard_acquire>
 80a1246:	b158      	cbz	r0, 80a1260 <_Z19__fetch_global_Wirev+0x2c>
 80a1248:	4621      	mov	r1, r4
 80a124a:	4807      	ldr	r0, [pc, #28]	; (80a1268 <_Z19__fetch_global_Wirev+0x34>)
 80a124c:	f7ff fb1a 	bl	80a0884 <_ZN7TwoWireC1E17HAL_I2C_Interface>
 80a1250:	4628      	mov	r0, r5
 80a1252:	f7fe ff29 	bl	80a00a8 <__cxa_guard_release>
 80a1256:	4804      	ldr	r0, [pc, #16]	; (80a1268 <_Z19__fetch_global_Wirev+0x34>)
 80a1258:	4904      	ldr	r1, [pc, #16]	; (80a126c <_Z19__fetch_global_Wirev+0x38>)
 80a125a:	4a05      	ldr	r2, [pc, #20]	; (80a1270 <_Z19__fetch_global_Wirev+0x3c>)
 80a125c:	f000 f85a 	bl	80a1314 <__aeabi_atexit>
	return wire;
}
 80a1260:	4801      	ldr	r0, [pc, #4]	; (80a1268 <_Z19__fetch_global_Wirev+0x34>)
 80a1262:	bd38      	pop	{r3, r4, r5, pc}
 80a1264:	20000534 	.word	0x20000534
 80a1268:	20000538 	.word	0x20000538
 80a126c:	080a082d 	.word	0x080a082d
 80a1270:	20000378 	.word	0x20000378

080a1274 <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a1274:	b513      	push	{r0, r1, r4, lr}
 80a1276:	4c08      	ldr	r4, [pc, #32]	; (80a1298 <_GLOBAL__sub_I_INADDR_NONE+0x24>)
 80a1278:	2100      	movs	r1, #0
 80a127a:	9100      	str	r1, [sp, #0]
 80a127c:	460a      	mov	r2, r1
 80a127e:	460b      	mov	r3, r1
 80a1280:	4620      	mov	r0, r4
 80a1282:	f7ff fb5b 	bl	80a093c <_ZN9IPAddressC1Ehhhh>
 80a1286:	4620      	mov	r0, r4
 80a1288:	4904      	ldr	r1, [pc, #16]	; (80a129c <_GLOBAL__sub_I_INADDR_NONE+0x28>)
 80a128a:	4a05      	ldr	r2, [pc, #20]	; (80a12a0 <_GLOBAL__sub_I_INADDR_NONE+0x2c>)
 80a128c:	b002      	add	sp, #8
 80a128e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a1292:	f000 b83f 	b.w	80a1314 <__aeabi_atexit>
 80a1296:	bf00      	nop
 80a1298:	2000054c 	.word	0x2000054c
 80a129c:	080a08e1 	.word	0x080a08e1
 80a12a0:	20000378 	.word	0x20000378

080a12a4 <_GLOBAL__sub_I_SPI>:
#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a12a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a12a6:	4b12      	ldr	r3, [pc, #72]	; (80a12f0 <_GLOBAL__sub_I_SPI+0x4c>)
 80a12a8:	2100      	movs	r1, #0
 80a12aa:	7019      	strb	r1, [r3, #0]
 80a12ac:	4b11      	ldr	r3, [pc, #68]	; (80a12f4 <_GLOBAL__sub_I_SPI+0x50>)
 80a12ae:	2401      	movs	r4, #1
 80a12b0:	701c      	strb	r4, [r3, #0]
 80a12b2:	4b11      	ldr	r3, [pc, #68]	; (80a12f8 <_GLOBAL__sub_I_SPI+0x54>)
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a12b4:	4f11      	ldr	r7, [pc, #68]	; (80a12fc <_GLOBAL__sub_I_SPI+0x58>)
 80a12b6:	7019      	strb	r1, [r3, #0]
 80a12b8:	4b11      	ldr	r3, [pc, #68]	; (80a1300 <_GLOBAL__sub_I_SPI+0x5c>)
 80a12ba:	2202      	movs	r2, #2
 80a12bc:	701c      	strb	r4, [r3, #0]
 80a12be:	4b11      	ldr	r3, [pc, #68]	; (80a1304 <_GLOBAL__sub_I_SPI+0x60>)
 80a12c0:	4e11      	ldr	r6, [pc, #68]	; (80a1308 <_GLOBAL__sub_I_SPI+0x64>)
 80a12c2:	4d12      	ldr	r5, [pc, #72]	; (80a130c <_GLOBAL__sub_I_SPI+0x68>)
 80a12c4:	4638      	mov	r0, r7
 80a12c6:	701a      	strb	r2, [r3, #0]
 80a12c8:	f7ff fbec 	bl	80a0aa4 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a12cc:	4638      	mov	r0, r7

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a12ce:	4f10      	ldr	r7, [pc, #64]	; (80a1310 <_GLOBAL__sub_I_SPI+0x6c>)
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a12d0:	462a      	mov	r2, r5
 80a12d2:	4631      	mov	r1, r6
 80a12d4:	f000 f81e 	bl	80a1314 <__aeabi_atexit>

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a12d8:	4621      	mov	r1, r4
 80a12da:	4638      	mov	r0, r7
 80a12dc:	f7ff fbe2 	bl	80a0aa4 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a12e0:	4638      	mov	r0, r7
 80a12e2:	4631      	mov	r1, r6
 80a12e4:	462a      	mov	r2, r5
 80a12e6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 80a12ea:	f000 b813 	b.w	80a1314 <__aeabi_atexit>
 80a12ee:	bf00      	nop
 80a12f0:	20000567 	.word	0x20000567
 80a12f4:	20000568 	.word	0x20000568
 80a12f8:	20000565 	.word	0x20000565
 80a12fc:	2000056c 	.word	0x2000056c
 80a1300:	20000566 	.word	0x20000566
 80a1304:	20000564 	.word	0x20000564
 80a1308:	080a0a95 	.word	0x080a0a95
 80a130c:	20000378 	.word	0x20000378
 80a1310:	20000578 	.word	0x20000578

080a1314 <__aeabi_atexit>:
 80a1314:	4603      	mov	r3, r0
 80a1316:	4608      	mov	r0, r1
 80a1318:	4619      	mov	r1, r3
 80a131a:	f000 b8c9 	b.w	80a14b0 <__cxa_atexit>
	...

080a1320 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE>:
 80a1320:	4b24      	ldr	r3, [pc, #144]	; (80a13b4 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x94>)
 80a1322:	681a      	ldr	r2, [r3, #0]
 80a1324:	07d0      	lsls	r0, r2, #31
 80a1326:	bf5c      	itt	pl
 80a1328:	2201      	movpl	r2, #1
 80a132a:	601a      	strpl	r2, [r3, #0]
 80a132c:	4b22      	ldr	r3, [pc, #136]	; (80a13b8 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x98>)
 80a132e:	681a      	ldr	r2, [r3, #0]
 80a1330:	07d1      	lsls	r1, r2, #31
 80a1332:	bf5c      	itt	pl
 80a1334:	2201      	movpl	r2, #1
 80a1336:	601a      	strpl	r2, [r3, #0]
 80a1338:	4b20      	ldr	r3, [pc, #128]	; (80a13bc <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x9c>)
 80a133a:	681a      	ldr	r2, [r3, #0]
 80a133c:	07d2      	lsls	r2, r2, #31
 80a133e:	bf5c      	itt	pl
 80a1340:	2201      	movpl	r2, #1
 80a1342:	601a      	strpl	r2, [r3, #0]
 80a1344:	4b1e      	ldr	r3, [pc, #120]	; (80a13c0 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xa0>)
 80a1346:	681a      	ldr	r2, [r3, #0]
 80a1348:	07d0      	lsls	r0, r2, #31
 80a134a:	bf5c      	itt	pl
 80a134c:	2201      	movpl	r2, #1
 80a134e:	601a      	strpl	r2, [r3, #0]
 80a1350:	4b1c      	ldr	r3, [pc, #112]	; (80a13c4 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xa4>)
 80a1352:	681a      	ldr	r2, [r3, #0]
 80a1354:	07d1      	lsls	r1, r2, #31
 80a1356:	bf5c      	itt	pl
 80a1358:	2201      	movpl	r2, #1
 80a135a:	601a      	strpl	r2, [r3, #0]
 80a135c:	4b1a      	ldr	r3, [pc, #104]	; (80a13c8 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xa8>)
 80a135e:	681a      	ldr	r2, [r3, #0]
 80a1360:	07d2      	lsls	r2, r2, #31
 80a1362:	bf5c      	itt	pl
 80a1364:	2201      	movpl	r2, #1
 80a1366:	601a      	strpl	r2, [r3, #0]
 80a1368:	4b18      	ldr	r3, [pc, #96]	; (80a13cc <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xac>)
 80a136a:	681a      	ldr	r2, [r3, #0]
 80a136c:	07d0      	lsls	r0, r2, #31
 80a136e:	bf5c      	itt	pl
 80a1370:	2201      	movpl	r2, #1
 80a1372:	601a      	strpl	r2, [r3, #0]
 80a1374:	4b16      	ldr	r3, [pc, #88]	; (80a13d0 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xb0>)
 80a1376:	681a      	ldr	r2, [r3, #0]
 80a1378:	07d1      	lsls	r1, r2, #31
 80a137a:	bf5c      	itt	pl
 80a137c:	2201      	movpl	r2, #1
 80a137e:	601a      	strpl	r2, [r3, #0]
 80a1380:	4b14      	ldr	r3, [pc, #80]	; (80a13d4 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xb4>)
 80a1382:	681a      	ldr	r2, [r3, #0]
 80a1384:	07d2      	lsls	r2, r2, #31
 80a1386:	bf5c      	itt	pl
 80a1388:	2201      	movpl	r2, #1
 80a138a:	601a      	strpl	r2, [r3, #0]
 80a138c:	4b12      	ldr	r3, [pc, #72]	; (80a13d8 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xb8>)
 80a138e:	681a      	ldr	r2, [r3, #0]
 80a1390:	07d0      	lsls	r0, r2, #31
 80a1392:	bf5c      	itt	pl
 80a1394:	2201      	movpl	r2, #1
 80a1396:	601a      	strpl	r2, [r3, #0]
 80a1398:	4b10      	ldr	r3, [pc, #64]	; (80a13dc <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xbc>)
 80a139a:	681a      	ldr	r2, [r3, #0]
 80a139c:	07d1      	lsls	r1, r2, #31
 80a139e:	bf5c      	itt	pl
 80a13a0:	2201      	movpl	r2, #1
 80a13a2:	601a      	strpl	r2, [r3, #0]
 80a13a4:	4b0e      	ldr	r3, [pc, #56]	; (80a13e0 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xc0>)
 80a13a6:	681a      	ldr	r2, [r3, #0]
 80a13a8:	07d2      	lsls	r2, r2, #31
 80a13aa:	bf5c      	itt	pl
 80a13ac:	2201      	movpl	r2, #1
 80a13ae:	601a      	strpl	r2, [r3, #0]
 80a13b0:	4770      	bx	lr
 80a13b2:	bf00      	nop
 80a13b4:	200005b0 	.word	0x200005b0
 80a13b8:	200005ac 	.word	0x200005ac
 80a13bc:	200005a8 	.word	0x200005a8
 80a13c0:	200005a4 	.word	0x200005a4
 80a13c4:	200005a0 	.word	0x200005a0
 80a13c8:	2000059c 	.word	0x2000059c
 80a13cc:	20000598 	.word	0x20000598
 80a13d0:	20000594 	.word	0x20000594
 80a13d4:	20000590 	.word	0x20000590
 80a13d8:	2000058c 	.word	0x2000058c
 80a13dc:	20000588 	.word	0x20000588
 80a13e0:	20000584 	.word	0x20000584

080a13e4 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE>:
 80a13e4:	4b24      	ldr	r3, [pc, #144]	; (80a1478 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x94>)
 80a13e6:	681a      	ldr	r2, [r3, #0]
 80a13e8:	07d0      	lsls	r0, r2, #31
 80a13ea:	bf5c      	itt	pl
 80a13ec:	2201      	movpl	r2, #1
 80a13ee:	601a      	strpl	r2, [r3, #0]
 80a13f0:	4b22      	ldr	r3, [pc, #136]	; (80a147c <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x98>)
 80a13f2:	681a      	ldr	r2, [r3, #0]
 80a13f4:	07d1      	lsls	r1, r2, #31
 80a13f6:	bf5c      	itt	pl
 80a13f8:	2201      	movpl	r2, #1
 80a13fa:	601a      	strpl	r2, [r3, #0]
 80a13fc:	4b20      	ldr	r3, [pc, #128]	; (80a1480 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x9c>)
 80a13fe:	681a      	ldr	r2, [r3, #0]
 80a1400:	07d2      	lsls	r2, r2, #31
 80a1402:	bf5c      	itt	pl
 80a1404:	2201      	movpl	r2, #1
 80a1406:	601a      	strpl	r2, [r3, #0]
 80a1408:	4b1e      	ldr	r3, [pc, #120]	; (80a1484 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xa0>)
 80a140a:	681a      	ldr	r2, [r3, #0]
 80a140c:	07d0      	lsls	r0, r2, #31
 80a140e:	bf5c      	itt	pl
 80a1410:	2201      	movpl	r2, #1
 80a1412:	601a      	strpl	r2, [r3, #0]
 80a1414:	4b1c      	ldr	r3, [pc, #112]	; (80a1488 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xa4>)
 80a1416:	681a      	ldr	r2, [r3, #0]
 80a1418:	07d1      	lsls	r1, r2, #31
 80a141a:	bf5c      	itt	pl
 80a141c:	2201      	movpl	r2, #1
 80a141e:	601a      	strpl	r2, [r3, #0]
 80a1420:	4b1a      	ldr	r3, [pc, #104]	; (80a148c <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xa8>)
 80a1422:	681a      	ldr	r2, [r3, #0]
 80a1424:	07d2      	lsls	r2, r2, #31
 80a1426:	bf5c      	itt	pl
 80a1428:	2201      	movpl	r2, #1
 80a142a:	601a      	strpl	r2, [r3, #0]
 80a142c:	4b18      	ldr	r3, [pc, #96]	; (80a1490 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xac>)
 80a142e:	681a      	ldr	r2, [r3, #0]
 80a1430:	07d0      	lsls	r0, r2, #31
 80a1432:	bf5c      	itt	pl
 80a1434:	2201      	movpl	r2, #1
 80a1436:	601a      	strpl	r2, [r3, #0]
 80a1438:	4b16      	ldr	r3, [pc, #88]	; (80a1494 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xb0>)
 80a143a:	681a      	ldr	r2, [r3, #0]
 80a143c:	07d1      	lsls	r1, r2, #31
 80a143e:	bf5c      	itt	pl
 80a1440:	2201      	movpl	r2, #1
 80a1442:	601a      	strpl	r2, [r3, #0]
 80a1444:	4b14      	ldr	r3, [pc, #80]	; (80a1498 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xb4>)
 80a1446:	681a      	ldr	r2, [r3, #0]
 80a1448:	07d2      	lsls	r2, r2, #31
 80a144a:	bf5c      	itt	pl
 80a144c:	2201      	movpl	r2, #1
 80a144e:	601a      	strpl	r2, [r3, #0]
 80a1450:	4b12      	ldr	r3, [pc, #72]	; (80a149c <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xb8>)
 80a1452:	681a      	ldr	r2, [r3, #0]
 80a1454:	07d0      	lsls	r0, r2, #31
 80a1456:	bf5c      	itt	pl
 80a1458:	2201      	movpl	r2, #1
 80a145a:	601a      	strpl	r2, [r3, #0]
 80a145c:	4b10      	ldr	r3, [pc, #64]	; (80a14a0 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xbc>)
 80a145e:	681a      	ldr	r2, [r3, #0]
 80a1460:	07d1      	lsls	r1, r2, #31
 80a1462:	bf5c      	itt	pl
 80a1464:	2201      	movpl	r2, #1
 80a1466:	601a      	strpl	r2, [r3, #0]
 80a1468:	4b0e      	ldr	r3, [pc, #56]	; (80a14a4 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xc0>)
 80a146a:	681a      	ldr	r2, [r3, #0]
 80a146c:	07d2      	lsls	r2, r2, #31
 80a146e:	bf5c      	itt	pl
 80a1470:	2201      	movpl	r2, #1
 80a1472:	601a      	strpl	r2, [r3, #0]
 80a1474:	4770      	bx	lr
 80a1476:	bf00      	nop
 80a1478:	200005e0 	.word	0x200005e0
 80a147c:	200005dc 	.word	0x200005dc
 80a1480:	200005d8 	.word	0x200005d8
 80a1484:	200005d4 	.word	0x200005d4
 80a1488:	200005d0 	.word	0x200005d0
 80a148c:	200005cc 	.word	0x200005cc
 80a1490:	200005c8 	.word	0x200005c8
 80a1494:	200005c4 	.word	0x200005c4
 80a1498:	200005c0 	.word	0x200005c0
 80a149c:	200005bc 	.word	0x200005bc
 80a14a0:	200005b8 	.word	0x200005b8
 80a14a4:	200005b4 	.word	0x200005b4

080a14a8 <atol>:
 80a14a8:	2100      	movs	r1, #0
 80a14aa:	220a      	movs	r2, #10
 80a14ac:	f000 b8e4 	b.w	80a1678 <strtol>

080a14b0 <__cxa_atexit>:
 80a14b0:	b538      	push	{r3, r4, r5, lr}
 80a14b2:	4605      	mov	r5, r0
 80a14b4:	4804      	ldr	r0, [pc, #16]	; (80a14c8 <__cxa_atexit+0x18>)
 80a14b6:	460c      	mov	r4, r1
 80a14b8:	4613      	mov	r3, r2
 80a14ba:	b120      	cbz	r0, 80a14c6 <__cxa_atexit+0x16>
 80a14bc:	2002      	movs	r0, #2
 80a14be:	4629      	mov	r1, r5
 80a14c0:	4622      	mov	r2, r4
 80a14c2:	f3af 8000 	nop.w
 80a14c6:	bd38      	pop	{r3, r4, r5, pc}
 80a14c8:	00000000 	.word	0x00000000

080a14cc <isspace>:
 80a14cc:	4b03      	ldr	r3, [pc, #12]	; (80a14dc <isspace+0x10>)
 80a14ce:	681b      	ldr	r3, [r3, #0]
 80a14d0:	4418      	add	r0, r3
 80a14d2:	7840      	ldrb	r0, [r0, #1]
 80a14d4:	f000 0008 	and.w	r0, r0, #8
 80a14d8:	4770      	bx	lr
 80a14da:	bf00      	nop
 80a14dc:	20000310 	.word	0x20000310

080a14e0 <memcpy>:
 80a14e0:	b510      	push	{r4, lr}
 80a14e2:	1e43      	subs	r3, r0, #1
 80a14e4:	440a      	add	r2, r1
 80a14e6:	4291      	cmp	r1, r2
 80a14e8:	d004      	beq.n	80a14f4 <memcpy+0x14>
 80a14ea:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a14ee:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a14f2:	e7f8      	b.n	80a14e6 <memcpy+0x6>
 80a14f4:	bd10      	pop	{r4, pc}

080a14f6 <memset>:
 80a14f6:	4603      	mov	r3, r0
 80a14f8:	4402      	add	r2, r0
 80a14fa:	4293      	cmp	r3, r2
 80a14fc:	d002      	beq.n	80a1504 <memset+0xe>
 80a14fe:	f803 1b01 	strb.w	r1, [r3], #1
 80a1502:	e7fa      	b.n	80a14fa <memset+0x4>
 80a1504:	4770      	bx	lr

080a1506 <strcmp>:
 80a1506:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a150a:	f811 3b01 	ldrb.w	r3, [r1], #1
 80a150e:	2a01      	cmp	r2, #1
 80a1510:	bf28      	it	cs
 80a1512:	429a      	cmpcs	r2, r3
 80a1514:	d0f7      	beq.n	80a1506 <strcmp>
 80a1516:	1ad0      	subs	r0, r2, r3
 80a1518:	4770      	bx	lr

080a151a <strcpy>:
 80a151a:	4603      	mov	r3, r0
 80a151c:	f811 2b01 	ldrb.w	r2, [r1], #1
 80a1520:	f803 2b01 	strb.w	r2, [r3], #1
 80a1524:	2a00      	cmp	r2, #0
 80a1526:	d1f9      	bne.n	80a151c <strcpy+0x2>
 80a1528:	4770      	bx	lr

080a152a <strlen>:
 80a152a:	4603      	mov	r3, r0
 80a152c:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a1530:	2a00      	cmp	r2, #0
 80a1532:	d1fb      	bne.n	80a152c <strlen+0x2>
 80a1534:	1a18      	subs	r0, r3, r0
 80a1536:	3801      	subs	r0, #1
 80a1538:	4770      	bx	lr

080a153a <strncmp>:
 80a153a:	b570      	push	{r4, r5, r6, lr}
 80a153c:	b1a2      	cbz	r2, 80a1568 <strncmp+0x2e>
 80a153e:	1e45      	subs	r5, r0, #1
 80a1540:	3901      	subs	r1, #1
 80a1542:	786b      	ldrb	r3, [r5, #1]
 80a1544:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80a1548:	1c6e      	adds	r6, r5, #1
 80a154a:	42a3      	cmp	r3, r4
 80a154c:	d106      	bne.n	80a155c <strncmp+0x22>
 80a154e:	f06f 0401 	mvn.w	r4, #1
 80a1552:	1b64      	subs	r4, r4, r5
 80a1554:	4414      	add	r4, r2
 80a1556:	42e0      	cmn	r0, r4
 80a1558:	d102      	bne.n	80a1560 <strncmp+0x26>
 80a155a:	461c      	mov	r4, r3
 80a155c:	1b18      	subs	r0, r3, r4
 80a155e:	bd70      	pop	{r4, r5, r6, pc}
 80a1560:	4635      	mov	r5, r6
 80a1562:	2b00      	cmp	r3, #0
 80a1564:	d1ed      	bne.n	80a1542 <strncmp+0x8>
 80a1566:	e7f8      	b.n	80a155a <strncmp+0x20>
 80a1568:	4610      	mov	r0, r2
 80a156a:	bd70      	pop	{r4, r5, r6, pc}

080a156c <_strtol_r>:
 80a156c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a1570:	460f      	mov	r7, r1
 80a1572:	4c40      	ldr	r4, [pc, #256]	; (80a1674 <_strtol_r+0x108>)
 80a1574:	f8d4 9000 	ldr.w	r9, [r4]
 80a1578:	463d      	mov	r5, r7
 80a157a:	f815 eb01 	ldrb.w	lr, [r5], #1
 80a157e:	eb09 040e 	add.w	r4, r9, lr
 80a1582:	7866      	ldrb	r6, [r4, #1]
 80a1584:	f006 0408 	and.w	r4, r6, #8
 80a1588:	f004 06ff 	and.w	r6, r4, #255	; 0xff
 80a158c:	b10c      	cbz	r4, 80a1592 <_strtol_r+0x26>
 80a158e:	462f      	mov	r7, r5
 80a1590:	e7f2      	b.n	80a1578 <_strtol_r+0xc>
 80a1592:	4674      	mov	r4, lr
 80a1594:	2c2d      	cmp	r4, #45	; 0x2d
 80a1596:	d103      	bne.n	80a15a0 <_strtol_r+0x34>
 80a1598:	1cbd      	adds	r5, r7, #2
 80a159a:	787c      	ldrb	r4, [r7, #1]
 80a159c:	2601      	movs	r6, #1
 80a159e:	e003      	b.n	80a15a8 <_strtol_r+0x3c>
 80a15a0:	2c2b      	cmp	r4, #43	; 0x2b
 80a15a2:	bf04      	itt	eq
 80a15a4:	787c      	ldrbeq	r4, [r7, #1]
 80a15a6:	1cbd      	addeq	r5, r7, #2
 80a15a8:	b113      	cbz	r3, 80a15b0 <_strtol_r+0x44>
 80a15aa:	2b10      	cmp	r3, #16
 80a15ac:	d10a      	bne.n	80a15c4 <_strtol_r+0x58>
 80a15ae:	e05a      	b.n	80a1666 <_strtol_r+0xfa>
 80a15b0:	2c30      	cmp	r4, #48	; 0x30
 80a15b2:	d156      	bne.n	80a1662 <_strtol_r+0xf6>
 80a15b4:	782c      	ldrb	r4, [r5, #0]
 80a15b6:	f004 04df 	and.w	r4, r4, #223	; 0xdf
 80a15ba:	2c58      	cmp	r4, #88	; 0x58
 80a15bc:	d14c      	bne.n	80a1658 <_strtol_r+0xec>
 80a15be:	786c      	ldrb	r4, [r5, #1]
 80a15c0:	2310      	movs	r3, #16
 80a15c2:	3502      	adds	r5, #2
 80a15c4:	2e00      	cmp	r6, #0
 80a15c6:	bf14      	ite	ne
 80a15c8:	f04f 4800 	movne.w	r8, #2147483648	; 0x80000000
 80a15cc:	f06f 4800 	mvneq.w	r8, #2147483648	; 0x80000000
 80a15d0:	fbb8 faf3 	udiv	sl, r8, r3
 80a15d4:	2700      	movs	r7, #0
 80a15d6:	46be      	mov	lr, r7
 80a15d8:	fb03 881a 	mls	r8, r3, sl, r8
 80a15dc:	eb09 0c04 	add.w	ip, r9, r4
 80a15e0:	f89c c001 	ldrb.w	ip, [ip, #1]
 80a15e4:	f01c 0f04 	tst.w	ip, #4
 80a15e8:	d001      	beq.n	80a15ee <_strtol_r+0x82>
 80a15ea:	3c30      	subs	r4, #48	; 0x30
 80a15ec:	e00b      	b.n	80a1606 <_strtol_r+0x9a>
 80a15ee:	f01c 0c03 	ands.w	ip, ip, #3
 80a15f2:	d01b      	beq.n	80a162c <_strtol_r+0xc0>
 80a15f4:	f1bc 0f01 	cmp.w	ip, #1
 80a15f8:	bf0c      	ite	eq
 80a15fa:	f04f 0c37 	moveq.w	ip, #55	; 0x37
 80a15fe:	f04f 0c57 	movne.w	ip, #87	; 0x57
 80a1602:	ebcc 0404 	rsb	r4, ip, r4
 80a1606:	429c      	cmp	r4, r3
 80a1608:	da10      	bge.n	80a162c <_strtol_r+0xc0>
 80a160a:	f1b7 3fff 	cmp.w	r7, #4294967295	; 0xffffffff
 80a160e:	d00a      	beq.n	80a1626 <_strtol_r+0xba>
 80a1610:	45d6      	cmp	lr, sl
 80a1612:	d806      	bhi.n	80a1622 <_strtol_r+0xb6>
 80a1614:	d101      	bne.n	80a161a <_strtol_r+0xae>
 80a1616:	4544      	cmp	r4, r8
 80a1618:	dc03      	bgt.n	80a1622 <_strtol_r+0xb6>
 80a161a:	fb03 4e0e 	mla	lr, r3, lr, r4
 80a161e:	2701      	movs	r7, #1
 80a1620:	e001      	b.n	80a1626 <_strtol_r+0xba>
 80a1622:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 80a1626:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a162a:	e7d7      	b.n	80a15dc <_strtol_r+0x70>
 80a162c:	1c7c      	adds	r4, r7, #1
 80a162e:	4673      	mov	r3, lr
 80a1630:	d10a      	bne.n	80a1648 <_strtol_r+0xdc>
 80a1632:	2e00      	cmp	r6, #0
 80a1634:	f04f 0122 	mov.w	r1, #34	; 0x22
 80a1638:	bf14      	ite	ne
 80a163a:	f04f 4300 	movne.w	r3, #2147483648	; 0x80000000
 80a163e:	f06f 4300 	mvneq.w	r3, #2147483648	; 0x80000000
 80a1642:	6001      	str	r1, [r0, #0]
 80a1644:	b92a      	cbnz	r2, 80a1652 <_strtol_r+0xe6>
 80a1646:	e011      	b.n	80a166c <_strtol_r+0x100>
 80a1648:	b10e      	cbz	r6, 80a164e <_strtol_r+0xe2>
 80a164a:	f1ce 0300 	rsb	r3, lr, #0
 80a164e:	b16a      	cbz	r2, 80a166c <_strtol_r+0x100>
 80a1650:	b107      	cbz	r7, 80a1654 <_strtol_r+0xe8>
 80a1652:	1e69      	subs	r1, r5, #1
 80a1654:	6011      	str	r1, [r2, #0]
 80a1656:	e009      	b.n	80a166c <_strtol_r+0x100>
 80a1658:	2430      	movs	r4, #48	; 0x30
 80a165a:	2b00      	cmp	r3, #0
 80a165c:	d1b2      	bne.n	80a15c4 <_strtol_r+0x58>
 80a165e:	2308      	movs	r3, #8
 80a1660:	e7b0      	b.n	80a15c4 <_strtol_r+0x58>
 80a1662:	230a      	movs	r3, #10
 80a1664:	e7ae      	b.n	80a15c4 <_strtol_r+0x58>
 80a1666:	2c30      	cmp	r4, #48	; 0x30
 80a1668:	d1ac      	bne.n	80a15c4 <_strtol_r+0x58>
 80a166a:	e7a3      	b.n	80a15b4 <_strtol_r+0x48>
 80a166c:	4618      	mov	r0, r3
 80a166e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a1672:	bf00      	nop
 80a1674:	20000310 	.word	0x20000310

080a1678 <strtol>:
 80a1678:	b530      	push	{r4, r5, lr}
 80a167a:	4605      	mov	r5, r0
 80a167c:	460c      	mov	r4, r1
 80a167e:	4613      	mov	r3, r2
 80a1680:	4a03      	ldr	r2, [pc, #12]	; (80a1690 <strtol+0x18>)
 80a1682:	4629      	mov	r1, r5
 80a1684:	6810      	ldr	r0, [r2, #0]
 80a1686:	4622      	mov	r2, r4
 80a1688:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 80a168c:	f7ff bf6e 	b.w	80a156c <_strtol_r>
 80a1690:	20000374 	.word	0x20000374

080a1694 <dynalib_user>:
 80a1694:	080a001d 080a005d 080a0089 080a008d     ....]...........
 80a16a4:	00000000 6e697270 6d002074 2065766f     ....print .move 
 80a16b4:	32003100 00303000 65766f6d 69727000     .1.2.00.move.pri
 80a16c4:	0000746e                                nt..

080a16c8 <_ZTV7TwoWire>:
	...
 80a16d0:	080a082d 080a0877 080a084f 080a082f     -...w...O.../...
 80a16e0:	080a0857 080a085f 080a0867 080a086f     W..._...g...o...

080a16f0 <_ZTV9IPAddress>:
	...
 80a16f8:	080a08ef 080a08e1 080a08e3 00000000     ................

080a1708 <_ZTV8SPIClass>:
	...
 80a1710:	080a0a95 080a0a97 2b25005a 3a643330     ........Z.%+03d:
 80a1720:	75323025 2d592500 252d6d25 48255464     %02u.%Y-%m-%dT%H
 80a1730:	3a4d253a 7a255325 63736100 656d6974     :%M:%S%z.asctime
	...

080a1748 <_ZTV11USARTSerial>:
	...
 80a1750:	080a0ebd 080a0ee1 080a0eed 080a0989     ................
 80a1760:	080a0ec9 080a0ed5 080a0ecf 080a0edb     ................
 80a1770:	080a0ebf 080a0ec3                       ........

080a1778 <_ZTV9USBSerial>:
	...
 80a1780:	080a0fa1 080a0fdb 080a0fbb 080a0989     ................
 80a1790:	080a0fb3 080a0fa3 080a0fa9 080a0fd7     ................
 80a17a0:	080a0faf 080a0f9d                       ........

080a17a8 <_ZTVN5spark9WiFiClassE>:
	...
 80a17b0:	080a1047                                G...

080a17b4 <_ctype_>:
 80a17b4:	20202000 20202020 28282020 20282828     .         ((((( 
 80a17c4:	20202020 20202020 20202020 20202020                     
 80a17d4:	10108820 10101010 10101010 10101010      ...............
 80a17e4:	04040410 04040404 10040404 10101010     ................
 80a17f4:	41411010 41414141 01010101 01010101     ..AAAAAA........
 80a1804:	01010101 01010101 01010101 10101010     ................
 80a1814:	42421010 42424242 02020202 02020202     ..BBBBBB........
 80a1824:	02020202 02020202 02020202 10101010     ................
 80a1834:	00000020 00000000 00000000 00000000      ...............
	...
 80a18b4:	00004300                                         .C.

080a18b7 <link_const_variable_data_end>:
	...

080a18b8 <link_constructors_location>:
 80a18b8:	080a0439 	.word	0x080a0439
 80a18bc:	080a0709 	.word	0x080a0709
 80a18c0:	080a0739 	.word	0x080a0739
 80a18c4:	080a07cd 	.word	0x080a07cd
 80a18c8:	080a07fd 	.word	0x080a07fd
 80a18cc:	080a08b1 	.word	0x080a08b1
 80a18d0:	080a0959 	.word	0x080a0959
 80a18d4:	080a0a65 	.word	0x080a0a65
 80a18d8:	080a0ac9 	.word	0x080a0ac9
 80a18dc:	080a0af9 	.word	0x080a0af9
 80a18e0:	080a0de5 	.word	0x080a0de5
 80a18e4:	080a0e19 	.word	0x080a0e19
 80a18e8:	080a0e49 	.word	0x080a0e49
 80a18ec:	080a0e5d 	.word	0x080a0e5d
 80a18f0:	080a0e8d 	.word	0x080a0e8d
 80a18f4:	080a1051 	.word	0x080a1051
 80a18f8:	080a11d5 	.word	0x080a11d5
 80a18fc:	080a1205 	.word	0x080a1205
 80a1900:	080a1275 	.word	0x080a1275
 80a1904:	080a12a5 	.word	0x080a12a5
 80a1908:	080a1321 	.word	0x080a1321
 80a190c:	080a13e5 	.word	0x080a13e5
