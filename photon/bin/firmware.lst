
/Users/nrobinson/comp-sci/photon/bin/firmware.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00001878  080a0018  080a0018  00008018  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .backup       00000004  40024000  080a1890  0000c000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .data         00000078  20000300  080a1894  00010300  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          0000026c  20000378  20000378  00018378  2**2
                  ALLOC
  5 .module_info_suffix 00000028  080a190c  080a190c  0001190c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .module_info_crc 00000004  080a1934  080a1934  00011934  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .debug_info   0007b321  00000000  00000000  00011938  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0001034b  00000000  00000000  0008cc59  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000b784  00000000  00000000  0009cfa4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00001830  00000000  00000000  000a8728  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00002478  00000000  00000000  000a9f58  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  000210d1  00000000  00000000  000ac3d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0001f06d  00000000  00000000  000cd4a1  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0006ca25  00000000  00000000  000ec50e  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00007814  00000000  00000000  00158f34  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080a0018 <user_part_module>:
 80a0018:	14 16 0a 08                                         ....

080a001c <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a001c:	4809      	ldr	r0, [pc, #36]	; (80a0044 <module_user_pre_init+0x28>)
 80a001e:	490a      	ldr	r1, [pc, #40]	; (80a0048 <module_user_pre_init+0x2c>)
extern constructor_ptr_t link_constructors_end;

/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {
 80a0020:	b508      	push	{r3, lr}

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0022:	4288      	cmp	r0, r1
 80a0024:	d005      	beq.n	80a0032 <module_user_pre_init+0x16>
 80a0026:	4a09      	ldr	r2, [pc, #36]	; (80a004c <module_user_pre_init+0x30>)
 80a0028:	4282      	cmp	r2, r0
 80a002a:	d002      	beq.n	80a0032 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a002c:	1a12      	subs	r2, r2, r0
 80a002e:	f001 fa17 	bl	80a1460 <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a0032:	4807      	ldr	r0, [pc, #28]	; (80a0050 <module_user_pre_init+0x34>)
 80a0034:	4a07      	ldr	r2, [pc, #28]	; (80a0054 <module_user_pre_init+0x38>)
 80a0036:	2100      	movs	r1, #0
 80a0038:	1a12      	subs	r2, r2, r0
 80a003a:	f001 fa1c 	bl	80a1476 <memset>
    return &link_heap_start;
}
 80a003e:	4806      	ldr	r0, [pc, #24]	; (80a0058 <module_user_pre_init+0x3c>)
 80a0040:	bd08      	pop	{r3, pc}
 80a0042:	bf00      	nop
 80a0044:	20000300 	.word	0x20000300
 80a0048:	080a1894 	.word	0x080a1894
 80a004c:	20000378 	.word	0x20000378
 80a0050:	20000378 	.word	0x20000378
 80a0054:	200005e4 	.word	0x200005e4
 80a0058:	200005e4 	.word	0x200005e4

080a005c <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a005c:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
 80a005e:	f001 f803 	bl	80a1068 <module_user_init_hook>

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0062:	4b07      	ldr	r3, [pc, #28]	; (80a0080 <module_user_init+0x24>)
 80a0064:	4c07      	ldr	r4, [pc, #28]	; (80a0084 <module_user_init+0x28>)
 80a0066:	461e      	mov	r6, r3
 80a0068:	1ae4      	subs	r4, r4, r3
 80a006a:	08a4      	lsrs	r4, r4, #2
 80a006c:	2500      	movs	r5, #0
 80a006e:	42a5      	cmp	r5, r4
 80a0070:	d004      	beq.n	80a007c <module_user_init+0x20>
    {
        link_constructors_location[ctor_num]();
 80a0072:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80a0076:	4798      	blx	r3
{
    module_user_init_hook();

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0078:	3501      	adds	r5, #1
 80a007a:	e7f8      	b.n	80a006e <module_user_init+0x12>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a007c:	bd70      	pop	{r4, r5, r6, pc}
 80a007e:	bf00      	nop
 80a0080:	080a1830 	.word	0x080a1830
 80a0084:	080a1888 	.word	0x080a1888

080a0088 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a0088:	f000 b90c 	b.w	80a02a4 <setup>

080a008c <module_user_loop>:
}

void module_user_loop() {
 80a008c:	b508      	push	{r3, lr}
    loop();
 80a008e:	f000 f95f 	bl	80a0350 <loop>
    _post_loop();
}
 80a0092:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    setup();
}

void module_user_loop() {
    loop();
    _post_loop();
 80a0096:	f000 bfd1 	b.w	80a103c <_post_loop>

080a009a <_ZdlPv>:
	return malloc(size);
}

void operator delete(void *p)
{
	free(p);
 80a009a:	f000 bae1 	b.w	80a0660 <free>

080a009e <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
 80a009e:	7800      	ldrb	r0, [r0, #0]
 80a00a0:	fab0 f080 	clz	r0, r0
 80a00a4:	0940      	lsrs	r0, r0, #5
 80a00a6:	4770      	bx	lr

080a00a8 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
 80a00a8:	2301      	movs	r3, #1
 80a00aa:	7003      	strb	r3, [r0, #0]
 80a00ac:	4770      	bx	lr
	...

080a00b0 <_Z4move6String>:

  return valuedata;
}

int move(String command)
{
 80a00b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a00b4:	4604      	mov	r4, r0
 80a00b6:	b09c      	sub	sp, #112	; 0x70
// 151 151 151 151
String nanoCommand = command.substring(0,7);
 80a00b8:	2307      	movs	r3, #7
 80a00ba:	4621      	mov	r1, r4
 80a00bc:	2200      	movs	r2, #0
 80a00be:	4668      	mov	r0, sp
 80a00c0:	f000 fdf0 	bl	80a0ca4 <_ZNK6String9substringEjj>
Serial.println(nanoCommand);
 80a00c4:	f000 ff60 	bl	80a0f88 <_Z20_fetch_global_serialv>
 80a00c8:	9900      	ldr	r1, [sp, #0]
 80a00ca:	f000 fc52 	bl	80a0972 <_ZN5Print7printlnEPKc>
String photonCommand = command.substring(8);
 80a00ce:	2208      	movs	r2, #8
 80a00d0:	4621      	mov	r1, r4
 80a00d2:	a804      	add	r0, sp, #16
 80a00d4:	f000 fe0e 	bl	80a0cf4 <_ZNK6String9substringEj>
Serial.println(photonCommand);
 80a00d8:	f000 ff56 	bl	80a0f88 <_Z20_fetch_global_serialv>
 80a00dc:	9904      	ldr	r1, [sp, #16]
 80a00de:	f000 fc48 	bl	80a0972 <_ZN5Print7printlnEPKc>
delay(100);
 80a00e2:	2064      	movs	r0, #100	; 0x64
 80a00e4:	f000 facc 	bl	80a0680 <delay>

    Serial1.println("move "+nanoCommand);
 80a00e8:	f000 fef2 	bl	80a0ed0 <_Z22__fetch_global_Serial1v>

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a00ec:	4965      	ldr	r1, [pc, #404]	; (80a0284 <_Z4move6String+0x1d4>)
 80a00ee:	4604      	mov	r4, r0
 80a00f0:	a818      	add	r0, sp, #96	; 0x60
 80a00f2:	f000 fd1b 	bl	80a0b2c <_ZN6StringC1EPKc>
 80a00f6:	4669      	mov	r1, sp
 80a00f8:	a818      	add	r0, sp, #96	; 0x60
 80a00fa:	f000 fd8a 	bl	80a0c12 <_ZplRK15StringSumHelperRK6String>
 80a00fe:	4603      	mov	r3, r0
    analogWrite(BLIN1, 0);
 80a0100:	4f61      	ldr	r7, [pc, #388]	; (80a0288 <_Z4move6String+0x1d8>)
Serial.println(nanoCommand);
String photonCommand = command.substring(8);
Serial.println(photonCommand);
delay(100);

    Serial1.println("move "+nanoCommand);
 80a0102:	6819      	ldr	r1, [r3, #0]
 80a0104:	4620      	mov	r0, r4
 80a0106:	f000 fc34 	bl	80a0972 <_ZN5Print7printlnEPKc>
    analogWrite(BLIN1, 0);
    analogWrite(BLIN2, 0);
 80a010a:	4e60      	ldr	r6, [pc, #384]	; (80a028c <_Z4move6String+0x1dc>)

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a010c:	a818      	add	r0, sp, #96	; 0x60
 80a010e:	f000 fccb 	bl	80a0aa8 <_ZN6StringD1Ev>
    analogWrite(BRIN1, 0);
 80a0112:	4d5f      	ldr	r5, [pc, #380]	; (80a0290 <_Z4move6String+0x1e0>)
String photonCommand = command.substring(8);
Serial.println(photonCommand);
delay(100);

    Serial1.println("move "+nanoCommand);
    analogWrite(BLIN1, 0);
 80a0114:	8838      	ldrh	r0, [r7, #0]
 80a0116:	2100      	movs	r1, #0
 80a0118:	f000 fff7 	bl	80a110a <_Z11analogWritett>
    analogWrite(BLIN2, 0);
    analogWrite(BRIN1, 0);
    analogWrite(BRIN2, 0);
 80a011c:	4c5d      	ldr	r4, [pc, #372]	; (80a0294 <_Z4move6String+0x1e4>)
Serial.println(photonCommand);
delay(100);

    Serial1.println("move "+nanoCommand);
    analogWrite(BLIN1, 0);
    analogWrite(BLIN2, 0);
 80a011e:	8830      	ldrh	r0, [r6, #0]
 80a0120:	2100      	movs	r1, #0
 80a0122:	f000 fff2 	bl	80a110a <_Z11analogWritett>
    analogWrite(BRIN1, 0);
 80a0126:	8828      	ldrh	r0, [r5, #0]
 80a0128:	2100      	movs	r1, #0
 80a012a:	f000 ffee 	bl	80a110a <_Z11analogWritett>
    analogWrite(BRIN2, 0);
 80a012e:	8820      	ldrh	r0, [r4, #0]
 80a0130:	2100      	movs	r1, #0
 80a0132:	f000 ffea 	bl	80a110a <_Z11analogWritett>

    // move 151 151
    String BLValue = photonCommand.substring(0,3);
 80a0136:	2303      	movs	r3, #3
 80a0138:	a808      	add	r0, sp, #32
 80a013a:	a904      	add	r1, sp, #16
 80a013c:	2200      	movs	r2, #0
 80a013e:	f000 fdb1 	bl	80a0ca4 <_ZNK6String9substringEjj>
    String BRValue = photonCommand.substring(4);
 80a0142:	2204      	movs	r2, #4
 80a0144:	a80c      	add	r0, sp, #48	; 0x30
 80a0146:	a904      	add	r1, sp, #16
 80a0148:	f000 fdd4 	bl	80a0cf4 <_ZNK6String9substringEj>
    String BLdir = String(BLValue.charAt(0));
 80a014c:	2100      	movs	r1, #0
 80a014e:	a808      	add	r0, sp, #32
 80a0150:	f000 fda6 	bl	80a0ca0 <_ZNK6String6charAtEj>
 80a0154:	4601      	mov	r1, r0
 80a0156:	a810      	add	r0, sp, #64	; 0x40
 80a0158:	f000 fd26 	bl	80a0ba8 <_ZN6StringC1Ec>
    String BRdir = String(BRValue.charAt(0));
 80a015c:	2100      	movs	r1, #0
 80a015e:	a80c      	add	r0, sp, #48	; 0x30
 80a0160:	f000 fd9e 	bl	80a0ca0 <_ZNK6String6charAtEj>
 80a0164:	4601      	mov	r1, r0
 80a0166:	a814      	add	r0, sp, #80	; 0x50
 80a0168:	f000 fd1e 	bl	80a0ba8 <_ZN6StringC1Ec>
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
 80a016c:	a810      	add	r0, sp, #64	; 0x40
 80a016e:	494a      	ldr	r1, [pc, #296]	; (80a0298 <_Z4move6String+0x1e8>)
 80a0170:	f000 fd5c 	bl	80a0c2c <_ZNK6String6equalsEPKc>

    // BL!
    if (BLdir == "1")
 80a0174:	b188      	cbz	r0, 80a019a <_Z4move6String+0xea>
    {
      int speedvar = BLValue.substring(1).toInt() * 5;
 80a0176:	a908      	add	r1, sp, #32
 80a0178:	2201      	movs	r2, #1
 80a017a:	a818      	add	r0, sp, #96	; 0x60
 80a017c:	f000 fdba 	bl	80a0cf4 <_ZNK6String9substringEj>
 80a0180:	a818      	add	r0, sp, #96	; 0x60
 80a0182:	f000 fde9 	bl	80a0d58 <_ZNK6String5toIntEv>
 80a0186:	4680      	mov	r8, r0
 80a0188:	a818      	add	r0, sp, #96	; 0x60
 80a018a:	f000 fc8d 	bl	80a0aa8 <_ZN6StringD1Ev>
 80a018e:	eb08 0188 	add.w	r1, r8, r8, lsl #2
      analogWrite(BLIN1, speedvar);
 80a0192:	8838      	ldrh	r0, [r7, #0]
 80a0194:	b289      	uxth	r1, r1
 80a0196:	f000 ffb8 	bl	80a110a <_Z11analogWritett>
 80a019a:	a810      	add	r0, sp, #64	; 0x40
 80a019c:	493f      	ldr	r1, [pc, #252]	; (80a029c <_Z4move6String+0x1ec>)
 80a019e:	f000 fd45 	bl	80a0c2c <_ZNK6String6equalsEPKc>
    }

    if (BLdir == "2")
 80a01a2:	b188      	cbz	r0, 80a01c8 <_Z4move6String+0x118>
    {
      int speedvar = BLValue.substring(1).toInt() * 5;
 80a01a4:	a908      	add	r1, sp, #32
 80a01a6:	2201      	movs	r2, #1
 80a01a8:	a818      	add	r0, sp, #96	; 0x60
 80a01aa:	f000 fda3 	bl	80a0cf4 <_ZNK6String9substringEj>
 80a01ae:	a818      	add	r0, sp, #96	; 0x60
 80a01b0:	f000 fdd2 	bl	80a0d58 <_ZNK6String5toIntEv>
 80a01b4:	4680      	mov	r8, r0
 80a01b6:	a818      	add	r0, sp, #96	; 0x60
 80a01b8:	f000 fc76 	bl	80a0aa8 <_ZN6StringD1Ev>
 80a01bc:	eb08 0188 	add.w	r1, r8, r8, lsl #2
      analogWrite(BLIN2, speedvar);
 80a01c0:	8830      	ldrh	r0, [r6, #0]
 80a01c2:	b289      	uxth	r1, r1
 80a01c4:	f000 ffa1 	bl	80a110a <_Z11analogWritett>
 80a01c8:	a810      	add	r0, sp, #64	; 0x40
 80a01ca:	4935      	ldr	r1, [pc, #212]	; (80a02a0 <_Z4move6String+0x1f0>)
 80a01cc:	f000 fd2e 	bl	80a0c2c <_ZNK6String6equalsEPKc>
    }

    if (BLdir == "0")
 80a01d0:	b138      	cbz	r0, 80a01e2 <_Z4move6String+0x132>
    {
      analogWrite(BLIN1, 0);
 80a01d2:	8838      	ldrh	r0, [r7, #0]
 80a01d4:	2100      	movs	r1, #0
 80a01d6:	f000 ff98 	bl	80a110a <_Z11analogWritett>
      analogWrite(BLIN2, 0);
 80a01da:	8830      	ldrh	r0, [r6, #0]
 80a01dc:	2100      	movs	r1, #0
 80a01de:	f000 ff94 	bl	80a110a <_Z11analogWritett>
 80a01e2:	a814      	add	r0, sp, #80	; 0x50
 80a01e4:	492c      	ldr	r1, [pc, #176]	; (80a0298 <_Z4move6String+0x1e8>)
 80a01e6:	f000 fd21 	bl	80a0c2c <_ZNK6String6equalsEPKc>
    }

    // BR!

    if (BRdir == "1")
 80a01ea:	b188      	cbz	r0, 80a0210 <_Z4move6String+0x160>
    {
      int speedvar = BRValue.substring(1).toInt() * 5;
 80a01ec:	a90c      	add	r1, sp, #48	; 0x30
 80a01ee:	2201      	movs	r2, #1
 80a01f0:	a818      	add	r0, sp, #96	; 0x60
 80a01f2:	f000 fd7f 	bl	80a0cf4 <_ZNK6String9substringEj>
 80a01f6:	a818      	add	r0, sp, #96	; 0x60
 80a01f8:	f000 fdae 	bl	80a0d58 <_ZNK6String5toIntEv>
 80a01fc:	4606      	mov	r6, r0
 80a01fe:	a818      	add	r0, sp, #96	; 0x60
 80a0200:	f000 fc52 	bl	80a0aa8 <_ZN6StringD1Ev>
 80a0204:	eb06 0186 	add.w	r1, r6, r6, lsl #2
      analogWrite(BRIN1, speedvar);
 80a0208:	8828      	ldrh	r0, [r5, #0]
 80a020a:	b289      	uxth	r1, r1
 80a020c:	f000 ff7d 	bl	80a110a <_Z11analogWritett>
 80a0210:	a814      	add	r0, sp, #80	; 0x50
 80a0212:	4922      	ldr	r1, [pc, #136]	; (80a029c <_Z4move6String+0x1ec>)
 80a0214:	f000 fd0a 	bl	80a0c2c <_ZNK6String6equalsEPKc>
    }

    if (BRdir == "2")
 80a0218:	b188      	cbz	r0, 80a023e <_Z4move6String+0x18e>
    {
      int speedvar = BRValue.substring(1).toInt() * 5;
 80a021a:	a90c      	add	r1, sp, #48	; 0x30
 80a021c:	2201      	movs	r2, #1
 80a021e:	a818      	add	r0, sp, #96	; 0x60
 80a0220:	f000 fd68 	bl	80a0cf4 <_ZNK6String9substringEj>
 80a0224:	a818      	add	r0, sp, #96	; 0x60
 80a0226:	f000 fd97 	bl	80a0d58 <_ZNK6String5toIntEv>
 80a022a:	4606      	mov	r6, r0
 80a022c:	a818      	add	r0, sp, #96	; 0x60
 80a022e:	f000 fc3b 	bl	80a0aa8 <_ZN6StringD1Ev>
 80a0232:	eb06 0186 	add.w	r1, r6, r6, lsl #2
      analogWrite(BRIN2, speedvar);
 80a0236:	8820      	ldrh	r0, [r4, #0]
 80a0238:	b289      	uxth	r1, r1
 80a023a:	f000 ff66 	bl	80a110a <_Z11analogWritett>
 80a023e:	a814      	add	r0, sp, #80	; 0x50
 80a0240:	4917      	ldr	r1, [pc, #92]	; (80a02a0 <_Z4move6String+0x1f0>)
 80a0242:	f000 fcf3 	bl	80a0c2c <_ZNK6String6equalsEPKc>
    }

    if (BRdir == "0")
 80a0246:	b138      	cbz	r0, 80a0258 <_Z4move6String+0x1a8>
    {
      analogWrite(BRIN1, 0);
 80a0248:	8828      	ldrh	r0, [r5, #0]
 80a024a:	2100      	movs	r1, #0
 80a024c:	f000 ff5d 	bl	80a110a <_Z11analogWritett>
      analogWrite(BRIN2, 0);
 80a0250:	8820      	ldrh	r0, [r4, #0]
 80a0252:	2100      	movs	r1, #0
 80a0254:	f000 ff59 	bl	80a110a <_Z11analogWritett>

    // move 151 151
    String BLValue = photonCommand.substring(0,3);
    String BRValue = photonCommand.substring(4);
    String BLdir = String(BLValue.charAt(0));
    String BRdir = String(BRValue.charAt(0));
 80a0258:	a814      	add	r0, sp, #80	; 0x50
 80a025a:	f000 fc25 	bl	80a0aa8 <_ZN6StringD1Ev>
    analogWrite(BRIN2, 0);

    // move 151 151
    String BLValue = photonCommand.substring(0,3);
    String BRValue = photonCommand.substring(4);
    String BLdir = String(BLValue.charAt(0));
 80a025e:	a810      	add	r0, sp, #64	; 0x40
 80a0260:	f000 fc22 	bl	80a0aa8 <_ZN6StringD1Ev>
    analogWrite(BRIN1, 0);
    analogWrite(BRIN2, 0);

    // move 151 151
    String BLValue = photonCommand.substring(0,3);
    String BRValue = photonCommand.substring(4);
 80a0264:	a80c      	add	r0, sp, #48	; 0x30
 80a0266:	f000 fc1f 	bl	80a0aa8 <_ZN6StringD1Ev>
    analogWrite(BLIN2, 0);
    analogWrite(BRIN1, 0);
    analogWrite(BRIN2, 0);

    // move 151 151
    String BLValue = photonCommand.substring(0,3);
 80a026a:	a808      	add	r0, sp, #32
 80a026c:	f000 fc1c 	bl	80a0aa8 <_ZN6StringD1Ev>
int move(String command)
{
// 151 151 151 151
String nanoCommand = command.substring(0,7);
Serial.println(nanoCommand);
String photonCommand = command.substring(8);
 80a0270:	a804      	add	r0, sp, #16
 80a0272:	f000 fc19 	bl	80a0aa8 <_ZN6StringD1Ev>
      analogWrite(BRIN1, 0);
      analogWrite(BRIN2, 0);
    }


return 1;
 80a0276:	4668      	mov	r0, sp
 80a0278:	f000 fc16 	bl	80a0aa8 <_ZN6StringD1Ev>
}
 80a027c:	2001      	movs	r0, #1
 80a027e:	b01c      	add	sp, #112	; 0x70
 80a0280:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a0284:	080a1628 	.word	0x080a1628
 80a0288:	20000304 	.word	0x20000304
 80a028c:	2000037c 	.word	0x2000037c
 80a0290:	20000300 	.word	0x20000300
 80a0294:	20000308 	.word	0x20000308
 80a0298:	080a162e 	.word	0x080a162e
 80a029c:	080a1630 	.word	0x080a1630
 80a02a0:	080a1633 	.word	0x080a1633

080a02a4 <setup>:

void setup()
{
 80a02a4:	b508      	push	{r3, lr}
Serial1.begin(9600);
 80a02a6:	f000 fe13 	bl	80a0ed0 <_Z22__fetch_global_Serial1v>
 80a02aa:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a02ae:	f000 fe09 	bl	80a0ec4 <_ZN11USARTSerial5beginEm>
Serial.begin(9600);
 80a02b2:	f000 fe69 	bl	80a0f88 <_Z20_fetch_global_serialv>
 80a02b6:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a02ba:	f000 fe61 	bl	80a0f80 <_ZN9USBSerial5beginEl>
pinMode(BLIN1, OUTPUT);
 80a02be:	4b0d      	ldr	r3, [pc, #52]	; (80a02f4 <setup+0x50>)
 80a02c0:	2101      	movs	r1, #1
 80a02c2:	8818      	ldrh	r0, [r3, #0]
 80a02c4:	f000 ff10 	bl	80a10e8 <pinMode>
pinMode(BLIN2, OUTPUT);
 80a02c8:	4b0b      	ldr	r3, [pc, #44]	; (80a02f8 <setup+0x54>)
 80a02ca:	2101      	movs	r1, #1
 80a02cc:	8818      	ldrh	r0, [r3, #0]
 80a02ce:	f000 ff0b 	bl	80a10e8 <pinMode>

pinMode(BRIN1, OUTPUT);
 80a02d2:	4b0a      	ldr	r3, [pc, #40]	; (80a02fc <setup+0x58>)
 80a02d4:	2101      	movs	r1, #1
 80a02d6:	8818      	ldrh	r0, [r3, #0]
 80a02d8:	f000 ff06 	bl	80a10e8 <pinMode>
pinMode(BRIN2, OUTPUT);
 80a02dc:	4b08      	ldr	r3, [pc, #32]	; (80a0300 <setup+0x5c>)
 80a02de:	2101      	movs	r1, #1
 80a02e0:	8818      	ldrh	r0, [r3, #0]
 80a02e2:	f000 ff01 	bl	80a10e8 <pinMode>

Particle.function("move", move);
}
 80a02e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        return _function(name, args...);
    }

    static bool _function(const char *funcKey, user_function_int_str_t* func)
    {
        return CLOUD_FN(register_function(call_raw_user_function, (void*)func, funcKey), false);
 80a02ea:	4806      	ldr	r0, [pc, #24]	; (80a0304 <setup+0x60>)
 80a02ec:	4906      	ldr	r1, [pc, #24]	; (80a0308 <setup+0x64>)
 80a02ee:	4a07      	ldr	r2, [pc, #28]	; (80a030c <setup+0x68>)
 80a02f0:	f000 ba10 	b.w	80a0714 <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
 80a02f4:	20000304 	.word	0x20000304
 80a02f8:	2000037c 	.word	0x2000037c
 80a02fc:	20000300 	.word	0x20000300
 80a0300:	20000308 	.word	0x20000308
 80a0304:	080a06e9 	.word	0x080a06e9
 80a0308:	080a00b1 	.word	0x080a00b1
 80a030c:	080a1635 	.word	0x080a1635

080a0310 <_Z12parseCommand6String>:

void parseCommand(String command)
{
 80a0310:	b530      	push	{r4, r5, lr}
 80a0312:	4604      	mov	r4, r0
 80a0314:	b085      	sub	sp, #20
if (command.startsWith("move"))
 80a0316:	490d      	ldr	r1, [pc, #52]	; (80a034c <_Z12parseCommand6String+0x3c>)
 80a0318:	4668      	mov	r0, sp
 80a031a:	f000 fc07 	bl	80a0b2c <_ZN6StringC1EPKc>
 80a031e:	4620      	mov	r0, r4
 80a0320:	4669      	mov	r1, sp
 80a0322:	f000 fcab 	bl	80a0c7c <_ZNK6String10startsWithERKS_>
 80a0326:	4605      	mov	r5, r0
 80a0328:	4668      	mov	r0, sp
 80a032a:	f000 fbbd 	bl	80a0aa8 <_ZN6StringD1Ev>
 80a032e:	b155      	cbz	r5, 80a0346 <_Z12parseCommand6String+0x36>
{
  move(command.substring(5));
 80a0330:	4668      	mov	r0, sp
 80a0332:	4621      	mov	r1, r4
 80a0334:	2205      	movs	r2, #5
 80a0336:	f000 fcdd 	bl	80a0cf4 <_ZNK6String9substringEj>
 80a033a:	4668      	mov	r0, sp
 80a033c:	f7ff feb8 	bl	80a00b0 <_Z4move6String>
 80a0340:	4668      	mov	r0, sp
 80a0342:	f000 fbb1 	bl	80a0aa8 <_ZN6StringD1Ev>
}

}
 80a0346:	b005      	add	sp, #20
 80a0348:	bd30      	pop	{r4, r5, pc}
 80a034a:	bf00      	nop
 80a034c:	080a1635 	.word	0x080a1635

080a0350 <loop>:

void loop()
{
 80a0350:	b51f      	push	{r0, r1, r2, r3, r4, lr}

    while (Serial.available())
 80a0352:	f000 fe19 	bl	80a0f88 <_Z20_fetch_global_serialv>
 80a0356:	6803      	ldr	r3, [r0, #0]
 80a0358:	691b      	ldr	r3, [r3, #16]
 80a035a:	4798      	blx	r3
 80a035c:	b160      	cbz	r0, 80a0378 <loop+0x28>
    {
      delay(3);
 80a035e:	2003      	movs	r0, #3
 80a0360:	f000 f98e 	bl	80a0680 <delay>
      char c = Serial.read();
 80a0364:	f000 fe10 	bl	80a0f88 <_Z20_fetch_global_serialv>
 80a0368:	6803      	ldr	r3, [r0, #0]
 80a036a:	695b      	ldr	r3, [r3, #20]
 80a036c:	4798      	blx	r3

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
	String & operator += (char c)			{concat(c); return (*this);}
 80a036e:	b2c1      	uxtb	r1, r0
 80a0370:	480f      	ldr	r0, [pc, #60]	; (80a03b0 <loop+0x60>)
 80a0372:	f000 fc41 	bl	80a0bf8 <_ZN6String6concatEc>
 80a0376:	e7ec      	b.n	80a0352 <loop+0x2>
      readString += c;
    }

    readString.trim();
 80a0378:	4c0d      	ldr	r4, [pc, #52]	; (80a03b0 <loop+0x60>)
 80a037a:	4620      	mov	r0, r4
 80a037c:	f000 fcc1 	bl	80a0d02 <_ZN6String4trimEv>

    if (readString.length() > 0)
 80a0380:	68a3      	ldr	r3, [r4, #8]
 80a0382:	b193      	cbz	r3, 80a03aa <loop+0x5a>
    {
      parseCommand(readString);
 80a0384:	4621      	mov	r1, r4
 80a0386:	4668      	mov	r0, sp
 80a0388:	f000 fbf2 	bl	80a0b70 <_ZN6StringC1ERKS_>
 80a038c:	4668      	mov	r0, sp
 80a038e:	f7ff ffbf 	bl	80a0310 <_Z12parseCommand6String>
 80a0392:	4668      	mov	r0, sp
 80a0394:	f000 fb88 	bl	80a0aa8 <_ZN6StringD1Ev>
      Serial.println(readString);
 80a0398:	f000 fdf6 	bl	80a0f88 <_Z20_fetch_global_serialv>
 80a039c:	6821      	ldr	r1, [r4, #0]
 80a039e:	f000 fae8 	bl	80a0972 <_ZN5Print7printlnEPKc>

      readString = "";
 80a03a2:	4620      	mov	r0, r4
 80a03a4:	4903      	ldr	r1, [pc, #12]	; (80a03b4 <loop+0x64>)
 80a03a6:	f000 fbee 	bl	80a0b86 <_ZN6StringaSEPKc>
    }
}
 80a03aa:	b004      	add	sp, #16
 80a03ac:	bd10      	pop	{r4, pc}
 80a03ae:	bf00      	nop
 80a03b0:	2000038c 	.word	0x2000038c
 80a03b4:	080a162d 	.word	0x080a162d

080a03b8 <_GLOBAL__sub_I_BLIN1>:
{
public:
    typedef uint8_t flag_t;
    inline SleepNetworkFlag(SystemSleepNetwork f) : SleepNetworkFlag(static_cast<flag_t>(f)) {}

    inline SleepNetworkFlag(flag_t flag) : flag_(flag) {}
 80a03b8:	4b0e      	ldr	r3, [pc, #56]	; (80a03f4 <_GLOBAL__sub_I_BLIN1+0x3c>)
 80a03ba:	2200      	movs	r2, #0
 80a03bc:	490e      	ldr	r1, [pc, #56]	; (80a03f8 <_GLOBAL__sub_I_BLIN1+0x40>)
 80a03be:	b510      	push	{r4, lr}
 80a03c0:	701a      	strb	r2, [r3, #0]
 80a03c2:	2301      	movs	r3, #1
 80a03c4:	700b      	strb	r3, [r1, #0]

class PublishFlag
{
public:
	typedef uint8_t flag_t;
	PublishFlag(flag_t flag) : flag_(flag) {}
 80a03c6:	490d      	ldr	r1, [pc, #52]	; (80a03fc <_GLOBAL__sub_I_BLIN1+0x44>)
int BLIN2 = D0;

int BRIN1 = D2;
int BRIN2 = D3;

String readString;
 80a03c8:	4c0d      	ldr	r4, [pc, #52]	; (80a0400 <_GLOBAL__sub_I_BLIN1+0x48>)
 80a03ca:	700a      	strb	r2, [r1, #0]
 80a03cc:	4a0d      	ldr	r2, [pc, #52]	; (80a0404 <_GLOBAL__sub_I_BLIN1+0x4c>)
 80a03ce:	7013      	strb	r3, [r2, #0]
 80a03d0:	4b0d      	ldr	r3, [pc, #52]	; (80a0408 <_GLOBAL__sub_I_BLIN1+0x50>)
 80a03d2:	2202      	movs	r2, #2
 80a03d4:	701a      	strb	r2, [r3, #0]
inline int32_t pinReadFast(pin_t _pin)
{
	return ((PIN_MAP[_pin].gpio_peripheral->IDR & PIN_MAP[_pin].gpio_pin) == 0 ? LOW : HIGH);
}
#elif defined(STM32F2XX)
static STM32_Pin_Info* PIN_MAP = HAL_Pin_Map();
 80a03d6:	f000 f831 	bl	80a043c <HAL_Pin_Map>
 80a03da:	4b0c      	ldr	r3, [pc, #48]	; (80a040c <_GLOBAL__sub_I_BLIN1+0x54>)
 80a03dc:	490c      	ldr	r1, [pc, #48]	; (80a0410 <_GLOBAL__sub_I_BLIN1+0x58>)
 80a03de:	6018      	str	r0, [r3, #0]
 80a03e0:	4620      	mov	r0, r4
 80a03e2:	f000 fba3 	bl	80a0b2c <_ZN6StringC1EPKc>
 80a03e6:	4620      	mov	r0, r4
      parseCommand(readString);
      Serial.println(readString);

      readString = "";
    }
}
 80a03e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
int BLIN2 = D0;

int BRIN1 = D2;
int BRIN2 = D3;

String readString;
 80a03ec:	4909      	ldr	r1, [pc, #36]	; (80a0414 <_GLOBAL__sub_I_BLIN1+0x5c>)
 80a03ee:	4a0a      	ldr	r2, [pc, #40]	; (80a0418 <_GLOBAL__sub_I_BLIN1+0x60>)
 80a03f0:	f000 bf50 	b.w	80a1294 <__aeabi_atexit>
 80a03f4:	20000383 	.word	0x20000383
 80a03f8:	20000388 	.word	0x20000388
 80a03fc:	20000381 	.word	0x20000381
 80a0400:	2000038c 	.word	0x2000038c
 80a0404:	20000382 	.word	0x20000382
 80a0408:	20000380 	.word	0x20000380
 80a040c:	20000384 	.word	0x20000384
 80a0410:	080a162d 	.word	0x080a162d
 80a0414:	080a0aa9 	.word	0x080a0aa9
 80a0418:	20000378 	.word	0x20000378

080a041c <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
 80a041c:	b508      	push	{r3, lr}
 80a041e:	4b02      	ldr	r3, [pc, #8]	; (80a0428 <HAL_RNG_GetRandomNumber+0xc>)
 80a0420:	681b      	ldr	r3, [r3, #0]
 80a0422:	685b      	ldr	r3, [r3, #4]
 80a0424:	9301      	str	r3, [sp, #4]
 80a0426:	bd08      	pop	{r3, pc}
 80a0428:	0806019c 	.word	0x0806019c

080a042c <HAL_Timer_Get_Milli_Seconds>:
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
 80a042c:	b508      	push	{r3, lr}
 80a042e:	4b02      	ldr	r3, [pc, #8]	; (80a0438 <HAL_Timer_Get_Milli_Seconds+0xc>)
 80a0430:	681b      	ldr	r3, [r3, #0]
 80a0432:	695b      	ldr	r3, [r3, #20]
 80a0434:	9301      	str	r3, [sp, #4]
 80a0436:	bd08      	pop	{r3, pc}
 80a0438:	0806019c 	.word	0x0806019c

080a043c <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, STM32_Pin_Info*(void))
 80a043c:	b508      	push	{r3, lr}
 80a043e:	4b02      	ldr	r3, [pc, #8]	; (80a0448 <HAL_Pin_Map+0xc>)
 80a0440:	681b      	ldr	r3, [r3, #0]
 80a0442:	681b      	ldr	r3, [r3, #0]
 80a0444:	9301      	str	r3, [sp, #4]
 80a0446:	bd08      	pop	{r3, pc}
 80a0448:	080601b0 	.word	0x080601b0

080a044c <HAL_Validate_Pin_Function>:
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
 80a044c:	b508      	push	{r3, lr}
 80a044e:	4b02      	ldr	r3, [pc, #8]	; (80a0458 <HAL_Validate_Pin_Function+0xc>)
 80a0450:	681b      	ldr	r3, [r3, #0]
 80a0452:	685b      	ldr	r3, [r3, #4]
 80a0454:	9301      	str	r3, [sp, #4]
 80a0456:	bd08      	pop	{r3, pc}
 80a0458:	080601b0 	.word	0x080601b0

080a045c <HAL_Pin_Mode>:
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
 80a045c:	b508      	push	{r3, lr}
 80a045e:	4b02      	ldr	r3, [pc, #8]	; (80a0468 <HAL_Pin_Mode+0xc>)
 80a0460:	681b      	ldr	r3, [r3, #0]
 80a0462:	689b      	ldr	r3, [r3, #8]
 80a0464:	9301      	str	r3, [sp, #4]
 80a0466:	bd08      	pop	{r3, pc}
 80a0468:	080601b0 	.word	0x080601b0

080a046c <HAL_Get_Pin_Mode>:
DYNALIB_FN(3, hal_gpio, HAL_Get_Pin_Mode, PinMode(pin_t))
 80a046c:	b508      	push	{r3, lr}
 80a046e:	4b02      	ldr	r3, [pc, #8]	; (80a0478 <HAL_Get_Pin_Mode+0xc>)
 80a0470:	681b      	ldr	r3, [r3, #0]
 80a0472:	68db      	ldr	r3, [r3, #12]
 80a0474:	9301      	str	r3, [sp, #4]
 80a0476:	bd08      	pop	{r3, pc}
 80a0478:	080601b0 	.word	0x080601b0

080a047c <HAL_DAC_Write>:
DYNALIB_FN(6, hal_gpio, HAL_Interrupts_Attach, void(uint16_t, HAL_InterruptHandler, void*, InterruptMode, HAL_InterruptExtraConfiguration*))
DYNALIB_FN(7, hal_gpio, HAL_Interrupts_Detach, void(uint16_t))
DYNALIB_FN(8, hal_gpio, HAL_Interrupts_Enable_All, void(void))
DYNALIB_FN(9, hal_gpio, HAL_Interrupts_Disable_All, void(void))

DYNALIB_FN(10, hal_gpio, HAL_DAC_Write, void(pin_t, uint16_t))
 80a047c:	b508      	push	{r3, lr}
 80a047e:	4b02      	ldr	r3, [pc, #8]	; (80a0488 <HAL_DAC_Write+0xc>)
 80a0480:	681b      	ldr	r3, [r3, #0]
 80a0482:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a0484:	9301      	str	r3, [sp, #4]
 80a0486:	bd08      	pop	{r3, pc}
 80a0488:	080601b0 	.word	0x080601b0

080a048c <HAL_PWM_Write>:
DYNALIB_FN(11, hal_gpio, HAL_ADC_Set_Sample_Time, void(uint8_t))
DYNALIB_FN(12, hal_gpio, HAL_ADC_Read, int32_t(uint16_t))

DYNALIB_FN(13, hal_gpio, HAL_PWM_Write, void(uint16_t, uint8_t))
 80a048c:	b508      	push	{r3, lr}
 80a048e:	4b02      	ldr	r3, [pc, #8]	; (80a0498 <HAL_PWM_Write+0xc>)
 80a0490:	681b      	ldr	r3, [r3, #0]
 80a0492:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a0494:	9301      	str	r3, [sp, #4]
 80a0496:	bd08      	pop	{r3, pc}
 80a0498:	080601b0 	.word	0x080601b0

080a049c <HAL_I2C_Write_Data>:
DYNALIB_FN(BASE_IDX + 3, hal_i2c, HAL_I2C_Begin, void(HAL_I2C_Interface, I2C_Mode, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 4, hal_i2c, HAL_I2C_End, void(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, HAL_I2C_Request_Data, uint32_t(HAL_I2C_Interface, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 6, hal_i2c, HAL_I2C_Begin_Transmission, void(HAL_I2C_Interface, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 7, hal_i2c, HAL_I2C_End_Transmission, uint8_t(HAL_I2C_Interface, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 8, hal_i2c, HAL_I2C_Write_Data, uint32_t(HAL_I2C_Interface, uint8_t, void*))
 80a049c:	b508      	push	{r3, lr}
 80a049e:	4b02      	ldr	r3, [pc, #8]	; (80a04a8 <HAL_I2C_Write_Data+0xc>)
 80a04a0:	681b      	ldr	r3, [r3, #0]
 80a04a2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a04a4:	9301      	str	r3, [sp, #4]
 80a04a6:	bd08      	pop	{r3, pc}
 80a04a8:	080601ac 	.word	0x080601ac

080a04ac <HAL_I2C_Available_Data>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, HAL_I2C_Available_Data, int32_t(HAL_I2C_Interface, void*))
 80a04ac:	b508      	push	{r3, lr}
 80a04ae:	4b02      	ldr	r3, [pc, #8]	; (80a04b8 <HAL_I2C_Available_Data+0xc>)
 80a04b0:	681b      	ldr	r3, [r3, #0]
 80a04b2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a04b4:	9301      	str	r3, [sp, #4]
 80a04b6:	bd08      	pop	{r3, pc}
 80a04b8:	080601ac 	.word	0x080601ac

080a04bc <HAL_I2C_Read_Data>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, HAL_I2C_Read_Data, int32_t(HAL_I2C_Interface, void*))
 80a04bc:	b508      	push	{r3, lr}
 80a04be:	4b02      	ldr	r3, [pc, #8]	; (80a04c8 <HAL_I2C_Read_Data+0xc>)
 80a04c0:	681b      	ldr	r3, [r3, #0]
 80a04c2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a04c4:	9301      	str	r3, [sp, #4]
 80a04c6:	bd08      	pop	{r3, pc}
 80a04c8:	080601ac 	.word	0x080601ac

080a04cc <HAL_I2C_Peek_Data>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, HAL_I2C_Peek_Data, int32_t(HAL_I2C_Interface, void*))
 80a04cc:	b508      	push	{r3, lr}
 80a04ce:	4b02      	ldr	r3, [pc, #8]	; (80a04d8 <HAL_I2C_Peek_Data+0xc>)
 80a04d0:	681b      	ldr	r3, [r3, #0]
 80a04d2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a04d4:	9301      	str	r3, [sp, #4]
 80a04d6:	bd08      	pop	{r3, pc}
 80a04d8:	080601ac 	.word	0x080601ac

080a04dc <HAL_I2C_Flush_Data>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, HAL_I2C_Flush_Data, void(HAL_I2C_Interface, void*))
 80a04dc:	b508      	push	{r3, lr}
 80a04de:	4b02      	ldr	r3, [pc, #8]	; (80a04e8 <HAL_I2C_Flush_Data+0xc>)
 80a04e0:	681b      	ldr	r3, [r3, #0]
 80a04e2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a04e4:	9301      	str	r3, [sp, #4]
 80a04e6:	bd08      	pop	{r3, pc}
 80a04e8:	080601ac 	.word	0x080601ac

080a04ec <HAL_I2C_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, HAL_I2C_Is_Enabled, bool(HAL_I2C_Interface, void*))
 80a04ec:	b508      	push	{r3, lr}
 80a04ee:	4b02      	ldr	r3, [pc, #8]	; (80a04f8 <HAL_I2C_Is_Enabled+0xc>)
 80a04f0:	681b      	ldr	r3, [r3, #0]
 80a04f2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80a04f4:	9301      	str	r3, [sp, #4]
 80a04f6:	bd08      	pop	{r3, pc}
 80a04f8:	080601ac 	.word	0x080601ac

080a04fc <HAL_I2C_Init>:
DYNALIB_FN(BASE_IDX + 14, hal_i2c, HAL_I2C_Set_Callback_On_Receive, void(HAL_I2C_Interface, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, HAL_I2C_Set_Callback_On_Request, void(HAL_I2C_Interface, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, HAL_I2C_Init, void(HAL_I2C_Interface, void*))
 80a04fc:	b508      	push	{r3, lr}
 80a04fe:	4b03      	ldr	r3, [pc, #12]	; (80a050c <HAL_I2C_Init+0x10>)
 80a0500:	681b      	ldr	r3, [r3, #0]
 80a0502:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a0506:	9301      	str	r3, [sp, #4]
 80a0508:	bd08      	pop	{r3, pc}
 80a050a:	0000      	.short	0x0000
 80a050c:	080601ac 	.word	0x080601ac

080a0510 <HAL_SPI_Init>:
DYNALIB_FN(2, hal_spi, HAL_SPI_Set_Bit_Order, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(3, hal_spi, HAL_SPI_Set_Data_Mode, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(4, hal_spi, HAL_SPI_Set_Clock_Divider, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(5, hal_spi, HAL_SPI_Send_Receive_Data, uint16_t(HAL_SPI_Interface, uint16_t))
DYNALIB_FN(6, hal_spi, HAL_SPI_Is_Enabled_Old, bool(void))
DYNALIB_FN(7, hal_spi, HAL_SPI_Init, void(HAL_SPI_Interface))
 80a0510:	b508      	push	{r3, lr}
 80a0512:	4b02      	ldr	r3, [pc, #8]	; (80a051c <HAL_SPI_Init+0xc>)
 80a0514:	681b      	ldr	r3, [r3, #0]
 80a0516:	69db      	ldr	r3, [r3, #28]
 80a0518:	9301      	str	r3, [sp, #4]
 80a051a:	bd08      	pop	{r3, pc}
 80a051c:	080601b4 	.word	0x080601b4

080a0520 <HAL_SPI_Is_Enabled>:
DYNALIB_FN(8, hal_spi, HAL_SPI_Is_Enabled, bool(HAL_SPI_Interface))
 80a0520:	b508      	push	{r3, lr}
 80a0522:	4b02      	ldr	r3, [pc, #8]	; (80a052c <HAL_SPI_Is_Enabled+0xc>)
 80a0524:	681b      	ldr	r3, [r3, #0]
 80a0526:	6a1b      	ldr	r3, [r3, #32]
 80a0528:	9301      	str	r3, [sp, #4]
 80a052a:	bd08      	pop	{r3, pc}
 80a052c:	080601b4 	.word	0x080601b4

080a0530 <USB_USART_Init>:
// GNINRAW

DYNALIB_BEGIN(hal_usart)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usart, USB_USART_Init, void(uint32_t))
 80a0530:	b508      	push	{r3, lr}
 80a0532:	4b02      	ldr	r3, [pc, #8]	; (80a053c <USB_USART_Init+0xc>)
 80a0534:	681b      	ldr	r3, [r3, #0]
 80a0536:	681b      	ldr	r3, [r3, #0]
 80a0538:	9301      	str	r3, [sp, #4]
 80a053a:	bd08      	pop	{r3, pc}
 80a053c:	080601c4 	.word	0x080601c4

080a0540 <USB_USART_Available_Data>:
DYNALIB_FN(1, hal_usart, USB_USART_Available_Data, uint8_t(void))
 80a0540:	b508      	push	{r3, lr}
 80a0542:	4b02      	ldr	r3, [pc, #8]	; (80a054c <USB_USART_Available_Data+0xc>)
 80a0544:	681b      	ldr	r3, [r3, #0]
 80a0546:	685b      	ldr	r3, [r3, #4]
 80a0548:	9301      	str	r3, [sp, #4]
 80a054a:	bd08      	pop	{r3, pc}
 80a054c:	080601c4 	.word	0x080601c4

080a0550 <USB_USART_Receive_Data>:
DYNALIB_FN(2, hal_usart, USB_USART_Receive_Data, int32_t(uint8_t))
 80a0550:	b508      	push	{r3, lr}
 80a0552:	4b02      	ldr	r3, [pc, #8]	; (80a055c <USB_USART_Receive_Data+0xc>)
 80a0554:	681b      	ldr	r3, [r3, #0]
 80a0556:	689b      	ldr	r3, [r3, #8]
 80a0558:	9301      	str	r3, [sp, #4]
 80a055a:	bd08      	pop	{r3, pc}
 80a055c:	080601c4 	.word	0x080601c4

080a0560 <USB_USART_Send_Data>:
DYNALIB_FN(3, hal_usart, USB_USART_Send_Data, void(uint8_t))
 80a0560:	b508      	push	{r3, lr}
 80a0562:	4b02      	ldr	r3, [pc, #8]	; (80a056c <USB_USART_Send_Data+0xc>)
 80a0564:	681b      	ldr	r3, [r3, #0]
 80a0566:	68db      	ldr	r3, [r3, #12]
 80a0568:	9301      	str	r3, [sp, #4]
 80a056a:	bd08      	pop	{r3, pc}
 80a056c:	080601c4 	.word	0x080601c4

080a0570 <HAL_USART_Init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, HAL_USART_Init, void(HAL_USART_Serial, Ring_Buffer*, Ring_Buffer*))
 80a0570:	b508      	push	{r3, lr}
 80a0572:	4b02      	ldr	r3, [pc, #8]	; (80a057c <HAL_USART_Init+0xc>)
 80a0574:	681b      	ldr	r3, [r3, #0]
 80a0576:	699b      	ldr	r3, [r3, #24]
 80a0578:	9301      	str	r3, [sp, #4]
 80a057a:	bd08      	pop	{r3, pc}
 80a057c:	080601c4 	.word	0x080601c4

080a0580 <HAL_USART_Write_Data>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, HAL_USART_Begin, void(HAL_USART_Serial, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, HAL_USART_End, void(HAL_USART_Serial))
DYNALIB_FN(BASE_IDX + 3, hal_usart, HAL_USART_Write_Data, uint32_t(HAL_USART_Serial, uint8_t))
 80a0580:	b508      	push	{r3, lr}
 80a0582:	4b02      	ldr	r3, [pc, #8]	; (80a058c <HAL_USART_Write_Data+0xc>)
 80a0584:	681b      	ldr	r3, [r3, #0]
 80a0586:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a0588:	9301      	str	r3, [sp, #4]
 80a058a:	bd08      	pop	{r3, pc}
 80a058c:	080601c4 	.word	0x080601c4

080a0590 <HAL_USART_Available_Data>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, HAL_USART_Available_Data, int32_t(HAL_USART_Serial))
 80a0590:	b508      	push	{r3, lr}
 80a0592:	4b02      	ldr	r3, [pc, #8]	; (80a059c <HAL_USART_Available_Data+0xc>)
 80a0594:	681b      	ldr	r3, [r3, #0]
 80a0596:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a0598:	9301      	str	r3, [sp, #4]
 80a059a:	bd08      	pop	{r3, pc}
 80a059c:	080601c4 	.word	0x080601c4

080a05a0 <HAL_USART_Read_Data>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, HAL_USART_Read_Data, int32_t(HAL_USART_Serial))
 80a05a0:	b508      	push	{r3, lr}
 80a05a2:	4b02      	ldr	r3, [pc, #8]	; (80a05ac <HAL_USART_Read_Data+0xc>)
 80a05a4:	681b      	ldr	r3, [r3, #0]
 80a05a6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a05a8:	9301      	str	r3, [sp, #4]
 80a05aa:	bd08      	pop	{r3, pc}
 80a05ac:	080601c4 	.word	0x080601c4

080a05b0 <HAL_USART_Peek_Data>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, HAL_USART_Peek_Data, int32_t(HAL_USART_Serial))
 80a05b0:	b508      	push	{r3, lr}
 80a05b2:	4b02      	ldr	r3, [pc, #8]	; (80a05bc <HAL_USART_Peek_Data+0xc>)
 80a05b4:	681b      	ldr	r3, [r3, #0]
 80a05b6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a05b8:	9301      	str	r3, [sp, #4]
 80a05ba:	bd08      	pop	{r3, pc}
 80a05bc:	080601c4 	.word	0x080601c4

080a05c0 <HAL_USART_Flush_Data>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, HAL_USART_Flush_Data, void(HAL_USART_Serial))
 80a05c0:	b508      	push	{r3, lr}
 80a05c2:	4b02      	ldr	r3, [pc, #8]	; (80a05cc <HAL_USART_Flush_Data+0xc>)
 80a05c4:	681b      	ldr	r3, [r3, #0]
 80a05c6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a05c8:	9301      	str	r3, [sp, #4]
 80a05ca:	bd08      	pop	{r3, pc}
 80a05cc:	080601c4 	.word	0x080601c4

080a05d0 <HAL_USART_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, HAL_USART_Is_Enabled, bool(HAL_USART_Serial))
 80a05d0:	b508      	push	{r3, lr}
 80a05d2:	4b02      	ldr	r3, [pc, #8]	; (80a05dc <HAL_USART_Is_Enabled+0xc>)
 80a05d4:	681b      	ldr	r3, [r3, #0]
 80a05d6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a05d8:	9301      	str	r3, [sp, #4]
 80a05da:	bd08      	pop	{r3, pc}
 80a05dc:	080601c4 	.word	0x080601c4

080a05e0 <HAL_USART_Available_Data_For_Write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, HAL_USART_Half_Duplex, void(HAL_USART_Serial, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, HAL_USART_Available_Data_For_Write, int32_t(HAL_USART_Serial))
 80a05e0:	b508      	push	{r3, lr}
 80a05e2:	4b02      	ldr	r3, [pc, #8]	; (80a05ec <HAL_USART_Available_Data_For_Write+0xc>)
 80a05e4:	681b      	ldr	r3, [r3, #0]
 80a05e6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a05e8:	9301      	str	r3, [sp, #4]
 80a05ea:	bd08      	pop	{r3, pc}
 80a05ec:	080601c4 	.word	0x080601c4

080a05f0 <USB_USART_Available_Data_For_Write>:

#ifdef USB_CDC_ENABLE
DYNALIB_FN(BASE_IDX + 11, hal_usart, USB_USART_Available_Data_For_Write, int32_t(void))
 80a05f0:	b508      	push	{r3, lr}
 80a05f2:	4b02      	ldr	r3, [pc, #8]	; (80a05fc <USB_USART_Available_Data_For_Write+0xc>)
 80a05f4:	681b      	ldr	r3, [r3, #0]
 80a05f6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a05f8:	9301      	str	r3, [sp, #4]
 80a05fa:	bd08      	pop	{r3, pc}
 80a05fc:	080601c4 	.word	0x080601c4

080a0600 <USB_USART_Flush_Data>:
DYNALIB_FN(BASE_IDX + 12, hal_usart, USB_USART_Flush_Data, void(void))
 80a0600:	b508      	push	{r3, lr}
 80a0602:	4b02      	ldr	r3, [pc, #8]	; (80a060c <USB_USART_Flush_Data+0xc>)
 80a0604:	681b      	ldr	r3, [r3, #0]
 80a0606:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a0608:	9301      	str	r3, [sp, #4]
 80a060a:	bd08      	pop	{r3, pc}
 80a060c:	080601c4 	.word	0x080601c4

080a0610 <HAL_USART_BeginConfig>:
#define BASE_IDX2 (BASE_IDX+13)
#else
#define BASE_IDX2 (BASE_IDX+11)
#endif

DYNALIB_FN(BASE_IDX2 + 0, hal_usart,HAL_USART_BeginConfig,void(HAL_USART_Serial serial, uint32_t baud, uint32_t config, void *ptr))
 80a0610:	b508      	push	{r3, lr}
 80a0612:	4b02      	ldr	r3, [pc, #8]	; (80a061c <HAL_USART_BeginConfig+0xc>)
 80a0614:	681b      	ldr	r3, [r3, #0]
 80a0616:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a0618:	9301      	str	r3, [sp, #4]
 80a061a:	bd08      	pop	{r3, pc}
 80a061c:	080601c4 	.word	0x080601c4

080a0620 <set_system_mode>:
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
 80a0620:	b508      	push	{r3, lr}
 80a0622:	4b02      	ldr	r3, [pc, #8]	; (80a062c <set_system_mode+0xc>)
 80a0624:	681b      	ldr	r3, [r3, #0]
 80a0626:	685b      	ldr	r3, [r3, #4]
 80a0628:	9301      	str	r3, [sp, #4]
 80a062a:	bd08      	pop	{r3, pc}
 80a062c:	080601a4 	.word	0x080601a4

080a0630 <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
 80a0630:	b508      	push	{r3, lr}
 80a0632:	4b02      	ldr	r3, [pc, #8]	; (80a063c <system_delay_ms+0xc>)
 80a0634:	681b      	ldr	r3, [r3, #0]
 80a0636:	695b      	ldr	r3, [r3, #20]
 80a0638:	9301      	str	r3, [sp, #4]
 80a063a:	bd08      	pop	{r3, pc}
 80a063c:	080601a4 	.word	0x080601a4

080a0640 <spark_function>:


DYNALIB_BEGIN(system_cloud)

DYNALIB_FN(0, system_cloud, spark_variable, bool(const char*, const void*, Spark_Data_TypeDef, spark_variable_t*))
DYNALIB_FN(1, system_cloud, spark_function, bool(const char*, p_user_function_int_str_t, void*))
 80a0640:	b508      	push	{r3, lr}
 80a0642:	4b02      	ldr	r3, [pc, #8]	; (80a064c <spark_function+0xc>)
 80a0644:	681b      	ldr	r3, [r3, #0]
 80a0646:	685b      	ldr	r3, [r3, #4]
 80a0648:	9301      	str	r3, [sp, #4]
 80a064a:	bd08      	pop	{r3, pc}
 80a064c:	080601cc 	.word	0x080601cc

080a0650 <network_ready>:

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
 80a0650:	b508      	push	{r3, lr}
 80a0652:	4b02      	ldr	r3, [pc, #8]	; (80a065c <network_ready+0xc>)
 80a0654:	681b      	ldr	r3, [r3, #0]
 80a0656:	691b      	ldr	r3, [r3, #16]
 80a0658:	9301      	str	r3, [sp, #4]
 80a065a:	bd08      	pop	{r3, pc}
 80a065c:	080601c8 	.word	0x080601c8

080a0660 <free>:
#include "dynalib.h"

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
DYNALIB_FN(1, rt, free, void(void*))
 80a0660:	b508      	push	{r3, lr}
 80a0662:	4b02      	ldr	r3, [pc, #8]	; (80a066c <free+0xc>)
 80a0664:	681b      	ldr	r3, [r3, #0]
 80a0666:	685b      	ldr	r3, [r3, #4]
 80a0668:	9301      	str	r3, [sp, #4]
 80a066a:	bd08      	pop	{r3, pc}
 80a066c:	080601a0 	.word	0x080601a0

080a0670 <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
 80a0670:	b508      	push	{r3, lr}
 80a0672:	4b02      	ldr	r3, [pc, #8]	; (80a067c <realloc+0xc>)
 80a0674:	681b      	ldr	r3, [r3, #0]
 80a0676:	689b      	ldr	r3, [r3, #8]
 80a0678:	9301      	str	r3, [sp, #4]
 80a067a:	bd08      	pop	{r3, pc}
 80a067c:	080601a0 	.word	0x080601a0

080a0680 <delay>:
  return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
 80a0680:	2100      	movs	r1, #0
 80a0682:	f7ff bfd5 	b.w	80a0630 <system_delay_ms>
	...

080a0688 <_GLOBAL__sub_I_setADCSampleTime>:
{
public:
    typedef uint8_t flag_t;
    inline SleepNetworkFlag(SystemSleepNetwork f) : SleepNetworkFlag(static_cast<flag_t>(f)) {}

    inline SleepNetworkFlag(flag_t flag) : flag_(flag) {}
 80a0688:	4b06      	ldr	r3, [pc, #24]	; (80a06a4 <_GLOBAL__sub_I_setADCSampleTime+0x1c>)
 80a068a:	2200      	movs	r2, #0
 80a068c:	4906      	ldr	r1, [pc, #24]	; (80a06a8 <_GLOBAL__sub_I_setADCSampleTime+0x20>)
 80a068e:	701a      	strb	r2, [r3, #0]
 80a0690:	2301      	movs	r3, #1
 80a0692:	700b      	strb	r3, [r1, #0]

class PublishFlag
{
public:
	typedef uint8_t flag_t;
	PublishFlag(flag_t flag) : flag_(flag) {}
 80a0694:	4905      	ldr	r1, [pc, #20]	; (80a06ac <_GLOBAL__sub_I_setADCSampleTime+0x24>)
 80a0696:	700a      	strb	r2, [r1, #0]
 80a0698:	4a05      	ldr	r2, [pc, #20]	; (80a06b0 <_GLOBAL__sub_I_setADCSampleTime+0x28>)
 80a069a:	7013      	strb	r3, [r2, #0]
 80a069c:	4b05      	ldr	r3, [pc, #20]	; (80a06b4 <_GLOBAL__sub_I_setADCSampleTime+0x2c>)
 80a069e:	2202      	movs	r2, #2
 80a06a0:	701a      	strb	r2, [r3, #0]
 80a06a2:	4770      	bx	lr
 80a06a4:	2000039f 	.word	0x2000039f
 80a06a8:	200003a0 	.word	0x200003a0
 80a06ac:	2000039d 	.word	0x2000039d
 80a06b0:	2000039e 	.word	0x2000039e
 80a06b4:	2000039c 	.word	0x2000039c

080a06b8 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt>:
 80a06b8:	4b06      	ldr	r3, [pc, #24]	; (80a06d4 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x1c>)
 80a06ba:	2200      	movs	r2, #0
 80a06bc:	4906      	ldr	r1, [pc, #24]	; (80a06d8 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x20>)
 80a06be:	701a      	strb	r2, [r3, #0]
 80a06c0:	2301      	movs	r3, #1
 80a06c2:	700b      	strb	r3, [r1, #0]
 80a06c4:	4905      	ldr	r1, [pc, #20]	; (80a06dc <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x24>)
 80a06c6:	700a      	strb	r2, [r1, #0]
 80a06c8:	4a05      	ldr	r2, [pc, #20]	; (80a06e0 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x28>)
 80a06ca:	7013      	strb	r3, [r2, #0]
 80a06cc:	4b05      	ldr	r3, [pc, #20]	; (80a06e4 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x2c>)
 80a06ce:	2202      	movs	r2, #2
 80a06d0:	701a      	strb	r2, [r3, #0]
 80a06d2:	4770      	bx	lr
 80a06d4:	200003a4 	.word	0x200003a4
 80a06d8:	200003a5 	.word	0x200003a5
 80a06dc:	200003a2 	.word	0x200003a2
 80a06e0:	200003a3 	.word	0x200003a3
 80a06e4:	200003a1 	.word	0x200003a1

080a06e8 <_ZN10CloudClass22call_raw_user_functionEPvPKcS0_>:
#include "spark_wiring_cloud.h"

int CloudClass::call_raw_user_function(void* data, const char* param, void* reserved)
{
 80a06e8:	b510      	push	{r4, lr}
 80a06ea:	b088      	sub	sp, #32
 80a06ec:	4604      	mov	r4, r0
    user_function_int_str_t* fn = (user_function_int_str_t*)(data);
    String p(param);
 80a06ee:	4668      	mov	r0, sp
 80a06f0:	f000 fa1c 	bl	80a0b2c <_ZN6StringC1EPKc>
    return (*fn)(p);
 80a06f4:	4669      	mov	r1, sp
 80a06f6:	a804      	add	r0, sp, #16
 80a06f8:	f000 fa3a 	bl	80a0b70 <_ZN6StringC1ERKS_>
 80a06fc:	a804      	add	r0, sp, #16
 80a06fe:	47a0      	blx	r4
 80a0700:	4604      	mov	r4, r0
 80a0702:	a804      	add	r0, sp, #16
 80a0704:	f000 f9d0 	bl	80a0aa8 <_ZN6StringD1Ev>
 80a0708:	4668      	mov	r0, sp
 80a070a:	f000 f9cd 	bl	80a0aa8 <_ZN6StringD1Ev>
}
 80a070e:	4620      	mov	r0, r4
 80a0710:	b008      	add	sp, #32
 80a0712:	bd10      	pop	{r4, pc}

080a0714 <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>:
    wiring_event_handler_t* fn = (wiring_event_handler_t*)(handler_data);
    (*fn)(event_name, data);
}

bool CloudClass::register_function(cloud_function_t fn, void* data, const char* funcKey)
{
 80a0714:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a0716:	4607      	mov	r7, r0
 80a0718:	460e      	mov	r6, r1
 80a071a:	4615      	mov	r5, r2
 80a071c:	b085      	sub	sp, #20
    const char *funcKey;
    cloud_function_t fn;
    void* data;

     cloud_function_descriptor() {
         memset(this, 0, sizeof(*this));
 80a071e:	2410      	movs	r4, #16
 80a0720:	4622      	mov	r2, r4
 80a0722:	4668      	mov	r0, sp
 80a0724:	2100      	movs	r1, #0
 80a0726:	f000 fea6 	bl	80a1476 <memset>
    cloud_function_descriptor desc;
    memset(&desc, 0, sizeof(desc));
 80a072a:	4622      	mov	r2, r4
 80a072c:	4668      	mov	r0, sp
 80a072e:	2100      	movs	r1, #0
 80a0730:	f000 fea1 	bl	80a1476 <memset>
    desc.size = sizeof(desc);
    desc.fn = fn;
    desc.data = (void*)data;
    desc.funcKey = funcKey;
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
 80a0734:	2000      	movs	r0, #0
 80a0736:	4669      	mov	r1, sp
 80a0738:	4602      	mov	r2, r0

bool CloudClass::register_function(cloud_function_t fn, void* data, const char* funcKey)
{
    cloud_function_descriptor desc;
    memset(&desc, 0, sizeof(desc));
    desc.size = sizeof(desc);
 80a073a:	f8ad 4000 	strh.w	r4, [sp]
    desc.fn = fn;
 80a073e:	9702      	str	r7, [sp, #8]
    desc.data = (void*)data;
 80a0740:	9603      	str	r6, [sp, #12]
    desc.funcKey = funcKey;
 80a0742:	9501      	str	r5, [sp, #4]
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
 80a0744:	f7ff ff7c 	bl	80a0640 <spark_function>
}
 80a0748:	b005      	add	sp, #20
 80a074a:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a074c <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_>:
 80a074c:	4b06      	ldr	r3, [pc, #24]	; (80a0768 <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x1c>)
 80a074e:	2200      	movs	r2, #0
 80a0750:	4906      	ldr	r1, [pc, #24]	; (80a076c <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x20>)
 80a0752:	701a      	strb	r2, [r3, #0]
 80a0754:	2301      	movs	r3, #1
 80a0756:	700b      	strb	r3, [r1, #0]
 80a0758:	4905      	ldr	r1, [pc, #20]	; (80a0770 <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x24>)
 80a075a:	700a      	strb	r2, [r1, #0]
 80a075c:	4a05      	ldr	r2, [pc, #20]	; (80a0774 <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x28>)
 80a075e:	7013      	strb	r3, [r2, #0]
 80a0760:	4b05      	ldr	r3, [pc, #20]	; (80a0778 <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x2c>)
 80a0762:	2202      	movs	r2, #2
 80a0764:	701a      	strb	r2, [r3, #0]
 80a0766:	4770      	bx	lr
 80a0768:	200003a9 	.word	0x200003a9
 80a076c:	200003aa 	.word	0x200003aa
 80a0770:	200003a7 	.word	0x200003a7
 80a0774:	200003a8 	.word	0x200003a8
 80a0778:	200003a6 	.word	0x200003a6

080a077c <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev>:
 80a077c:	4b06      	ldr	r3, [pc, #24]	; (80a0798 <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x1c>)
 80a077e:	2200      	movs	r2, #0
 80a0780:	4906      	ldr	r1, [pc, #24]	; (80a079c <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x20>)
 80a0782:	701a      	strb	r2, [r3, #0]
 80a0784:	2301      	movs	r3, #1
 80a0786:	700b      	strb	r3, [r1, #0]
 80a0788:	4905      	ldr	r1, [pc, #20]	; (80a07a0 <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x24>)
 80a078a:	700a      	strb	r2, [r1, #0]
 80a078c:	4a05      	ldr	r2, [pc, #20]	; (80a07a4 <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x28>)
 80a078e:	7013      	strb	r3, [r2, #0]
 80a0790:	4b05      	ldr	r3, [pc, #20]	; (80a07a8 <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x2c>)
 80a0792:	2202      	movs	r2, #2
 80a0794:	701a      	strb	r2, [r3, #0]
 80a0796:	4770      	bx	lr
 80a0798:	200003ae 	.word	0x200003ae
 80a079c:	200003af 	.word	0x200003af
 80a07a0:	200003ac 	.word	0x200003ac
 80a07a4:	200003ad 	.word	0x200003ad
 80a07a8:	200003ab 	.word	0x200003ab

080a07ac <_ZN7TwoWireD1Ev>:
private:
  HAL_I2C_Interface _i2c;

public:
  TwoWire(HAL_I2C_Interface i2c);
  virtual ~TwoWire() {};
 80a07ac:	4770      	bx	lr

080a07ae <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a07ae:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a07b0:	4606      	mov	r6, r0
 80a07b2:	4615      	mov	r5, r2
 80a07b4:	460c      	mov	r4, r1
 80a07b6:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a07b8:	42bc      	cmp	r4, r7
 80a07ba:	d006      	beq.n	80a07ca <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a07bc:	6833      	ldr	r3, [r6, #0]
 80a07be:	4630      	mov	r0, r6
 80a07c0:	689b      	ldr	r3, [r3, #8]
 80a07c2:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a07c6:	4798      	blx	r3
 80a07c8:	e7f6      	b.n	80a07b8 <_ZN7TwoWire5writeEPKhj+0xa>
  }

  return quantity;
}
 80a07ca:	4628      	mov	r0, r5
 80a07cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a07ce <_ZN7TwoWire5writeEh>:
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
  return HAL_I2C_Write_Data(_i2c, data, NULL);
 80a07ce:	7c00      	ldrb	r0, [r0, #16]
 80a07d0:	2200      	movs	r2, #0
 80a07d2:	f7ff be63 	b.w	80a049c <HAL_I2C_Write_Data>

080a07d6 <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return HAL_I2C_Available_Data(_i2c, NULL);
 80a07d6:	7c00      	ldrb	r0, [r0, #16]
 80a07d8:	2100      	movs	r1, #0
 80a07da:	f7ff be67 	b.w	80a04ac <HAL_I2C_Available_Data>

080a07de <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return HAL_I2C_Read_Data(_i2c, NULL);
 80a07de:	7c00      	ldrb	r0, [r0, #16]
 80a07e0:	2100      	movs	r1, #0
 80a07e2:	f7ff be6b 	b.w	80a04bc <HAL_I2C_Read_Data>

080a07e6 <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return HAL_I2C_Peek_Data(_i2c, NULL);
 80a07e6:	7c00      	ldrb	r0, [r0, #16]
 80a07e8:	2100      	movs	r1, #0
 80a07ea:	f7ff be6f 	b.w	80a04cc <HAL_I2C_Peek_Data>

080a07ee <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  HAL_I2C_Flush_Data(_i2c, NULL);
 80a07ee:	7c00      	ldrb	r0, [r0, #16]
 80a07f0:	2100      	movs	r1, #0
 80a07f2:	f7ff be73 	b.w	80a04dc <HAL_I2C_Flush_Data>

080a07f6 <_ZN7TwoWireD0Ev>:
 80a07f6:	b510      	push	{r4, lr}
 80a07f8:	4604      	mov	r4, r0
 80a07fa:	f7ff fc4e 	bl	80a009a <_ZdlPv>
 80a07fe:	4620      	mov	r0, r4
 80a0800:	bd10      	pop	{r4, pc}
	...

080a0804 <_ZN7TwoWireC1E17HAL_I2C_Interface>:
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a0804:	b510      	push	{r4, lr}
 80a0806:	4604      	mov	r4, r0
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a0808:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a080c:	6082      	str	r2, [r0, #8]
 80a080e:	4a05      	ldr	r2, [pc, #20]	; (80a0824 <_ZN7TwoWireC1E17HAL_I2C_Interface+0x20>)
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a0810:	2300      	movs	r3, #0
 80a0812:	6043      	str	r3, [r0, #4]
 80a0814:	6002      	str	r2, [r0, #0]
{
  _i2c = i2c;
 80a0816:	7401      	strb	r1, [r0, #16]
  HAL_I2C_Init(_i2c, NULL);
 80a0818:	4608      	mov	r0, r1
 80a081a:	4619      	mov	r1, r3
 80a081c:	f7ff fe6e 	bl	80a04fc <HAL_I2C_Init>

}
 80a0820:	4620      	mov	r0, r4
 80a0822:	bd10      	pop	{r4, pc}
 80a0824:	080a1648 	.word	0x080a1648

080a0828 <_ZN7TwoWire9isEnabledEv>:
  HAL_I2C_Set_Callback_On_Request(_i2c, function, NULL);
}

bool TwoWire::isEnabled()
{
  return HAL_I2C_Is_Enabled(_i2c, NULL);
 80a0828:	7c00      	ldrb	r0, [r0, #16]
 80a082a:	2100      	movs	r1, #0
 80a082c:	f7ff be5e 	b.w	80a04ec <HAL_I2C_Is_Enabled>

080a0830 <_GLOBAL__sub_I__Z16allocate_handlertRSt8functionIFvvEE>:
 80a0830:	4b06      	ldr	r3, [pc, #24]	; (80a084c <_GLOBAL__sub_I__Z16allocate_handlertRSt8functionIFvvEE+0x1c>)
 80a0832:	2200      	movs	r2, #0
 80a0834:	4906      	ldr	r1, [pc, #24]	; (80a0850 <_GLOBAL__sub_I__Z16allocate_handlertRSt8functionIFvvEE+0x20>)
 80a0836:	701a      	strb	r2, [r3, #0]
 80a0838:	2301      	movs	r3, #1
 80a083a:	700b      	strb	r3, [r1, #0]
 80a083c:	4905      	ldr	r1, [pc, #20]	; (80a0854 <_GLOBAL__sub_I__Z16allocate_handlertRSt8functionIFvvEE+0x24>)
 80a083e:	700a      	strb	r2, [r1, #0]
 80a0840:	4a05      	ldr	r2, [pc, #20]	; (80a0858 <_GLOBAL__sub_I__Z16allocate_handlertRSt8functionIFvvEE+0x28>)
 80a0842:	7013      	strb	r3, [r2, #0]
 80a0844:	4b05      	ldr	r3, [pc, #20]	; (80a085c <_GLOBAL__sub_I__Z16allocate_handlertRSt8functionIFvvEE+0x2c>)
 80a0846:	2202      	movs	r2, #2
 80a0848:	701a      	strb	r2, [r3, #0]
 80a084a:	4770      	bx	lr
 80a084c:	200003b3 	.word	0x200003b3
 80a0850:	200003b4 	.word	0x200003b4
 80a0854:	200003b1 	.word	0x200003b1
 80a0858:	200003b2 	.word	0x200003b2
 80a085c:	200003b0 	.word	0x200003b0

080a0860 <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a0860:	4770      	bx	lr

080a0862 <_ZN9IPAddressD0Ev>:
 80a0862:	b510      	push	{r4, lr}
 80a0864:	4604      	mov	r4, r0
 80a0866:	f7ff fc18 	bl	80a009a <_ZdlPv>
 80a086a:	4620      	mov	r0, r4
 80a086c:	bd10      	pop	{r4, pc}

080a086e <_ZNK9IPAddress7printToER5Print>:
#endif
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
 80a086e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0870:	460f      	mov	r7, r1
 80a0872:	f100 0608 	add.w	r6, r0, #8
 80a0876:	1d05      	adds	r5, r0, #4
 80a0878:	2400      	movs	r4, #0
    size_t n = 0;
    for (int i = 0; i < 4; i++)
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a087a:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 80a087e:	4638      	mov	r0, r7
 80a0880:	220a      	movs	r2, #10
 80a0882:	f000 f8ac 	bl	80a09de <_ZN5Print5printEhi>
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a0886:	42ae      	cmp	r6, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a0888:	4404      	add	r4, r0
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a088a:	d007      	beq.n	80a089c <_ZNK9IPAddress7printToER5Print+0x2e>
    {
        if (n)
 80a088c:	2c00      	cmp	r4, #0
 80a088e:	d0f4      	beq.n	80a087a <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a0890:	4638      	mov	r0, r7
 80a0892:	212e      	movs	r1, #46	; 0x2e
 80a0894:	f000 f85e 	bl	80a0954 <_ZN5Print5printEc>
 80a0898:	4404      	add	r4, r0
 80a089a:	e7ee      	b.n	80a087a <_ZNK9IPAddress7printToER5Print+0xc>
        n += p.print((*this)[i], DEC);
    }
    return n;
}
 80a089c:	4620      	mov	r0, r4
 80a089e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a08a0 <_ZN9IPAddress8set_ipv4Ehhhh>:
    return address.ipv4!=0;
#endif
}

void IPAddress::set_ipv4(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
 80a08a0:	b510      	push	{r4, lr}
 80a08a2:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a08a6:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 80a08aa:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a08ae:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
        return &address;
    }

    inline void setVersion(uint8_t version) {
#if HAL_IPv6
        address.v = version;
 80a08b2:	2304      	movs	r3, #4
 80a08b4:	6041      	str	r1, [r0, #4]
 80a08b6:	7503      	strb	r3, [r0, #20]
 80a08b8:	bd10      	pop	{r4, pc}
	...

080a08bc <_ZN9IPAddressC1Ehhhh>:
{
    memcpy(&this->address, &address, sizeof(address));
}


IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a08bc:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a08be:	4604      	mov	r4, r0
 80a08c0:	4d04      	ldr	r5, [pc, #16]	; (80a08d4 <_ZN9IPAddressC1Ehhhh+0x18>)
 80a08c2:	6005      	str	r5, [r0, #0]
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a08c4:	f89d 5018 	ldrb.w	r5, [sp, #24]
 80a08c8:	9500      	str	r5, [sp, #0]
 80a08ca:	f7ff ffe9 	bl	80a08a0 <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a08ce:	4620      	mov	r0, r4
 80a08d0:	b003      	add	sp, #12
 80a08d2:	bd30      	pop	{r4, r5, pc}
 80a08d4:	080a1670 	.word	0x080a1670

080a08d8 <_GLOBAL__sub_I__ZN4PMICC2Ev>:
 80a08d8:	4b06      	ldr	r3, [pc, #24]	; (80a08f4 <_GLOBAL__sub_I__ZN4PMICC2Ev+0x1c>)
 80a08da:	2200      	movs	r2, #0
 80a08dc:	4906      	ldr	r1, [pc, #24]	; (80a08f8 <_GLOBAL__sub_I__ZN4PMICC2Ev+0x20>)
 80a08de:	701a      	strb	r2, [r3, #0]
 80a08e0:	2301      	movs	r3, #1
 80a08e2:	700b      	strb	r3, [r1, #0]
 80a08e4:	4905      	ldr	r1, [pc, #20]	; (80a08fc <_GLOBAL__sub_I__ZN4PMICC2Ev+0x24>)
 80a08e6:	700a      	strb	r2, [r1, #0]
 80a08e8:	4a05      	ldr	r2, [pc, #20]	; (80a0900 <_GLOBAL__sub_I__ZN4PMICC2Ev+0x28>)
 80a08ea:	7013      	strb	r3, [r2, #0]
 80a08ec:	4b05      	ldr	r3, [pc, #20]	; (80a0904 <_GLOBAL__sub_I__ZN4PMICC2Ev+0x2c>)
 80a08ee:	2202      	movs	r2, #2
 80a08f0:	701a      	strb	r2, [r3, #0]
 80a08f2:	4770      	bx	lr
 80a08f4:	200003b8 	.word	0x200003b8
 80a08f8:	200003b9 	.word	0x200003b9
 80a08fc:	200003b6 	.word	0x200003b6
 80a0900:	200003b7 	.word	0x200003b7
 80a0904:	200003b5 	.word	0x200003b5

080a0908 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a0908:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a090a:	4606      	mov	r6, r0
 80a090c:	460d      	mov	r5, r1
 80a090e:	188f      	adds	r7, r1, r2
  size_t n = 0;
 80a0910:	2400      	movs	r4, #0
  while (size--) {
 80a0912:	42bd      	cmp	r5, r7
 80a0914:	d00c      	beq.n	80a0930 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a0916:	6833      	ldr	r3, [r6, #0]
 80a0918:	4630      	mov	r0, r6
 80a091a:	689b      	ldr	r3, [r3, #8]
 80a091c:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a0920:	4798      	blx	r3
     if (chunk>=0)
 80a0922:	2800      	cmp	r0, #0
 80a0924:	db01      	blt.n	80a092a <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a0926:	4404      	add	r4, r0
 80a0928:	e7f3      	b.n	80a0912 <_ZN5Print5writeEPKhj+0xa>
/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
     int chunk = write(*buffer++);
 80a092a:	2c00      	cmp	r4, #0
 80a092c:	bf08      	it	eq
 80a092e:	4604      	moveq	r4, r0
             n = chunk;
         break;
     }
  }
  return n;
}
 80a0930:	4620      	mov	r0, r4
 80a0932:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a0934 <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
 80a0934:	b570      	push	{r4, r5, r6, lr}
 80a0936:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a0938:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
 80a093a:	4608      	mov	r0, r1
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 80a093c:	b149      	cbz	r1, 80a0952 <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a093e:	f000 fdb4 	bl	80a14aa <strlen>
 80a0942:	682b      	ldr	r3, [r5, #0]
 80a0944:	4602      	mov	r2, r0
 80a0946:	4621      	mov	r1, r4
 80a0948:	4628      	mov	r0, r5
    }
 80a094a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 80a094e:	68db      	ldr	r3, [r3, #12]
 80a0950:	4718      	bx	r3
    }
 80a0952:	bd70      	pop	{r4, r5, r6, pc}

080a0954 <_ZN5Print5printEc>:
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
 80a0954:	6803      	ldr	r3, [r0, #0]
 80a0956:	689b      	ldr	r3, [r3, #8]
 80a0958:	4718      	bx	r3

080a095a <_ZN5Print7printlnEv>:
 {
   return x.printTo(*this);
 }

size_t Print::println(void)
{
 80a095a:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
 80a095c:	210d      	movs	r1, #13
 {
   return x.printTo(*this);
 }

size_t Print::println(void)
{
 80a095e:	4605      	mov	r5, r0
  size_t n = print('\r');
 80a0960:	f7ff fff8 	bl	80a0954 <_ZN5Print5printEc>
  n += print('\n');
 80a0964:	210a      	movs	r1, #10
   return x.printTo(*this);
 }

size_t Print::println(void)
{
  size_t n = print('\r');
 80a0966:	4604      	mov	r4, r0
  n += print('\n');
 80a0968:	4628      	mov	r0, r5
 80a096a:	f7ff fff3 	bl	80a0954 <_ZN5Print5printEc>
  return n;
}
 80a096e:	4420      	add	r0, r4
 80a0970:	bd38      	pop	{r3, r4, r5, pc}

080a0972 <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
 80a0972:	b538      	push	{r3, r4, r5, lr}
 80a0974:	4605      	mov	r5, r0
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a0976:	f7ff ffdd 	bl	80a0934 <_ZN5Print5writeEPKc>
 80a097a:	4604      	mov	r4, r0
}

size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
 80a097c:	4628      	mov	r0, r5
 80a097e:	f7ff ffec 	bl	80a095a <_ZN5Print7printlnEv>
  return n;
}
 80a0982:	4420      	add	r0, r4
 80a0984:	bd38      	pop	{r3, r4, r5, pc}

080a0986 <_ZN5Print11printNumberEmh>:
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a0986:	2a01      	cmp	r2, #1
 80a0988:	bf98      	it	ls
 80a098a:	220a      	movls	r2, #10
   return n;
 }

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a098c:	b530      	push	{r4, r5, lr}
 80a098e:	460b      	mov	r3, r1
 80a0990:	b08b      	sub	sp, #44	; 0x2c
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a0992:	2100      	movs	r1, #0
 80a0994:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24
 80a0998:	f10d 0423 	add.w	r4, sp, #35	; 0x23
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    unsigned long m = n;
    n /= base;
 80a099c:	fbb3 f5f2 	udiv	r5, r3, r2
    char c = m - base * n;
 80a09a0:	fb05 3312 	mls	r3, r5, r2, r3
 80a09a4:	b2db      	uxtb	r3, r3
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a09a6:	2b09      	cmp	r3, #9
 80a09a8:	bf94      	ite	ls
 80a09aa:	3330      	addls	r3, #48	; 0x30
 80a09ac:	3337      	addhi	r3, #55	; 0x37
 80a09ae:	b2db      	uxtb	r3, r3
 80a09b0:	4621      	mov	r1, r4
 80a09b2:	f804 3901 	strb.w	r3, [r4], #-1
 80a09b6:	462b      	mov	r3, r5
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 80a09b8:	2d00      	cmp	r5, #0
 80a09ba:	d1ef      	bne.n	80a099c <_ZN5Print11printNumberEmh+0x16>
    n /= base;
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 80a09bc:	f7ff ffba 	bl	80a0934 <_ZN5Print5writeEPKc>
}
 80a09c0:	b00b      	add	sp, #44	; 0x2c
 80a09c2:	bd30      	pop	{r4, r5, pc}

080a09c4 <_ZN5Print5printEmi>:
    return printNumber(n, base);
  }
}

size_t Print::print(unsigned long n, int base)
{
 80a09c4:	b510      	push	{r4, lr}
  if (base == 0) return write(n);
 80a09c6:	b92a      	cbnz	r2, 80a09d4 <_ZN5Print5printEmi+0x10>
  else return printNumber(n, base);
}
 80a09c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  }
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
 80a09cc:	6803      	ldr	r3, [r0, #0]
 80a09ce:	b2c9      	uxtb	r1, r1
 80a09d0:	689b      	ldr	r3, [r3, #8]
 80a09d2:	4718      	bx	r3
  else return printNumber(n, base);
 80a09d4:	b2d2      	uxtb	r2, r2
}
 80a09d6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 80a09da:	f7ff bfd4 	b.w	80a0986 <_ZN5Print11printNumberEmh>

080a09de <_ZN5Print5printEhi>:
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
 80a09de:	f7ff bff1 	b.w	80a09c4 <_ZN5Print5printEmi>
	...

080a09e4 <_GLOBAL__sub_I__ZN5ServoC2Ev>:
 80a09e4:	4b06      	ldr	r3, [pc, #24]	; (80a0a00 <_GLOBAL__sub_I__ZN5ServoC2Ev+0x1c>)
 80a09e6:	2200      	movs	r2, #0
 80a09e8:	4906      	ldr	r1, [pc, #24]	; (80a0a04 <_GLOBAL__sub_I__ZN5ServoC2Ev+0x20>)
 80a09ea:	701a      	strb	r2, [r3, #0]
 80a09ec:	2301      	movs	r3, #1
 80a09ee:	700b      	strb	r3, [r1, #0]
 80a09f0:	4905      	ldr	r1, [pc, #20]	; (80a0a08 <_GLOBAL__sub_I__ZN5ServoC2Ev+0x24>)
 80a09f2:	700a      	strb	r2, [r1, #0]
 80a09f4:	4a05      	ldr	r2, [pc, #20]	; (80a0a0c <_GLOBAL__sub_I__ZN5ServoC2Ev+0x28>)
 80a09f6:	7013      	strb	r3, [r2, #0]
 80a09f8:	4b05      	ldr	r3, [pc, #20]	; (80a0a10 <_GLOBAL__sub_I__ZN5ServoC2Ev+0x2c>)
 80a09fa:	2202      	movs	r2, #2
 80a09fc:	701a      	strb	r2, [r3, #0]
 80a09fe:	4770      	bx	lr
 80a0a00:	200003bd 	.word	0x200003bd
 80a0a04:	200003be 	.word	0x200003be
 80a0a08:	200003bb 	.word	0x200003bb
 80a0a0c:	200003bc 	.word	0x200003bc
 80a0a10:	200003ba 	.word	0x200003ba

080a0a14 <_ZN8SPIClassD1Ev>:
   */
  unsigned dividerReference;

public:
  SPIClass(HAL_SPI_Interface spi);
  virtual ~SPIClass() {};
 80a0a14:	4770      	bx	lr

080a0a16 <_ZN8SPIClassD0Ev>:
 80a0a16:	b510      	push	{r4, lr}
 80a0a18:	4604      	mov	r4, r0
 80a0a1a:	f7ff fb3e 	bl	80a009a <_ZdlPv>
 80a0a1e:	4620      	mov	r0, r4
 80a0a20:	bd10      	pop	{r4, pc}
	...

080a0a24 <_ZN8SPIClassC1E17HAL_SPI_Interface>:

#include "spark_wiring_spi.h"
#include "core_hal.h"
#include "spark_macros.h"

SPIClass::SPIClass(HAL_SPI_Interface spi)
 80a0a24:	b510      	push	{r4, lr}
 80a0a26:	4604      	mov	r4, r0
 80a0a28:	4b04      	ldr	r3, [pc, #16]	; (80a0a3c <_ZN8SPIClassC1E17HAL_SPI_Interface+0x18>)
{
  _spi = spi;
 80a0a2a:	7101      	strb	r1, [r0, #4]

#include "spark_wiring_spi.h"
#include "core_hal.h"
#include "spark_macros.h"

SPIClass::SPIClass(HAL_SPI_Interface spi)
 80a0a2c:	6003      	str	r3, [r0, #0]
{
  _spi = spi;
  HAL_SPI_Init(_spi);
 80a0a2e:	4608      	mov	r0, r1
 80a0a30:	f7ff fd6e 	bl	80a0510 <HAL_SPI_Init>
  dividerReference = SPI_CLK_SYSTEM;     // 0 indicates the system clock
 80a0a34:	2300      	movs	r3, #0
 80a0a36:	60a3      	str	r3, [r4, #8]
}
 80a0a38:	4620      	mov	r0, r4
 80a0a3a:	bd10      	pop	{r4, pc}
 80a0a3c:	080a1688 	.word	0x080a1688

080a0a40 <_ZN8SPIClass9isEnabledEv>:
  //To Do
}

bool SPIClass::isEnabled()
{
  return HAL_SPI_Is_Enabled(_spi);
 80a0a40:	7900      	ldrb	r0, [r0, #4]
 80a0a42:	f7ff bd6d 	b.w	80a0520 <HAL_SPI_Is_Enabled>
	...

080a0a48 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface>:
 80a0a48:	4b06      	ldr	r3, [pc, #24]	; (80a0a64 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x1c>)
 80a0a4a:	2200      	movs	r2, #0
 80a0a4c:	4906      	ldr	r1, [pc, #24]	; (80a0a68 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x20>)
 80a0a4e:	701a      	strb	r2, [r3, #0]
 80a0a50:	2301      	movs	r3, #1
 80a0a52:	700b      	strb	r3, [r1, #0]
 80a0a54:	4905      	ldr	r1, [pc, #20]	; (80a0a6c <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x24>)
 80a0a56:	700a      	strb	r2, [r1, #0]
 80a0a58:	4a05      	ldr	r2, [pc, #20]	; (80a0a70 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x28>)
 80a0a5a:	7013      	strb	r3, [r2, #0]
 80a0a5c:	4b05      	ldr	r3, [pc, #20]	; (80a0a74 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x2c>)
 80a0a5e:	2202      	movs	r2, #2
 80a0a60:	701a      	strb	r2, [r3, #0]
 80a0a62:	4770      	bx	lr
 80a0a64:	200003c2 	.word	0x200003c2
 80a0a68:	200003c3 	.word	0x200003c3
 80a0a6c:	200003c0 	.word	0x200003c0
 80a0a70:	200003c1 	.word	0x200003c1
 80a0a74:	200003bf 	.word	0x200003bf

080a0a78 <_GLOBAL__sub_I__ZN6Stream9timedReadEv>:
 80a0a78:	4b06      	ldr	r3, [pc, #24]	; (80a0a94 <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x1c>)
 80a0a7a:	2200      	movs	r2, #0
 80a0a7c:	4906      	ldr	r1, [pc, #24]	; (80a0a98 <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x20>)
 80a0a7e:	701a      	strb	r2, [r3, #0]
 80a0a80:	2301      	movs	r3, #1
 80a0a82:	700b      	strb	r3, [r1, #0]
 80a0a84:	4905      	ldr	r1, [pc, #20]	; (80a0a9c <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x24>)
 80a0a86:	700a      	strb	r2, [r1, #0]
 80a0a88:	4a05      	ldr	r2, [pc, #20]	; (80a0aa0 <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x28>)
 80a0a8a:	7013      	strb	r3, [r2, #0]
 80a0a8c:	4b05      	ldr	r3, [pc, #20]	; (80a0aa4 <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x2c>)
 80a0a8e:	2202      	movs	r2, #2
 80a0a90:	701a      	strb	r2, [r3, #0]
 80a0a92:	4770      	bx	lr
 80a0a94:	200003c7 	.word	0x200003c7
 80a0a98:	200003c8 	.word	0x200003c8
 80a0a9c:	200003c5 	.word	0x200003c5
 80a0aa0:	200003c6 	.word	0x200003c6
 80a0aa4:	200003c4 	.word	0x200003c4

080a0aa8 <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
 80a0aa8:	b510      	push	{r4, lr}
 80a0aaa:	4604      	mov	r4, r0
{
	free(buffer);
 80a0aac:	6800      	ldr	r0, [r0, #0]
 80a0aae:	f7ff fdd7 	bl	80a0660 <free>
}
 80a0ab2:	4620      	mov	r0, r4
 80a0ab4:	bd10      	pop	{r4, pc}

080a0ab6 <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
 80a0ab6:	b510      	push	{r4, lr}
 80a0ab8:	4604      	mov	r4, r0
	if (buffer) free(buffer);
 80a0aba:	6800      	ldr	r0, [r0, #0]
 80a0abc:	b108      	cbz	r0, 80a0ac2 <_ZN6String10invalidateEv+0xc>
 80a0abe:	f7ff fdcf 	bl	80a0660 <free>
	buffer = NULL;
 80a0ac2:	2300      	movs	r3, #0
 80a0ac4:	6023      	str	r3, [r4, #0]
	capacity = len = 0;
 80a0ac6:	60a3      	str	r3, [r4, #8]
 80a0ac8:	6063      	str	r3, [r4, #4]
 80a0aca:	bd10      	pop	{r4, pc}

080a0acc <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
 80a0acc:	b538      	push	{r3, r4, r5, lr}
 80a0ace:	4604      	mov	r4, r0
 80a0ad0:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
 80a0ad2:	6800      	ldr	r0, [r0, #0]
 80a0ad4:	3101      	adds	r1, #1
 80a0ad6:	f7ff fdcb 	bl	80a0670 <realloc>
	if (newbuffer) {
 80a0ada:	b110      	cbz	r0, 80a0ae2 <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
 80a0adc:	e884 0021 	stmia.w	r4, {r0, r5}
		return 1;
 80a0ae0:	2001      	movs	r0, #1
	}
	return 0;
}
 80a0ae2:	bd38      	pop	{r3, r4, r5, pc}

080a0ae4 <_ZN6String7reserveEj>:
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a0ae4:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
 80a0ae6:	6803      	ldr	r3, [r0, #0]
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a0ae8:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
 80a0aea:	b113      	cbz	r3, 80a0af2 <_ZN6String7reserveEj+0xe>
 80a0aec:	6843      	ldr	r3, [r0, #4]
 80a0aee:	428b      	cmp	r3, r1
 80a0af0:	d207      	bcs.n	80a0b02 <_ZN6String7reserveEj+0x1e>
	if (changeBuffer(size)) {
 80a0af2:	4620      	mov	r0, r4
 80a0af4:	f7ff ffea 	bl	80a0acc <_ZN6String12changeBufferEj>
 80a0af8:	b120      	cbz	r0, 80a0b04 <_ZN6String7reserveEj+0x20>
		if (len == 0) buffer[0] = 0;
 80a0afa:	68a3      	ldr	r3, [r4, #8]
 80a0afc:	b90b      	cbnz	r3, 80a0b02 <_ZN6String7reserveEj+0x1e>
 80a0afe:	6822      	ldr	r2, [r4, #0]
 80a0b00:	7013      	strb	r3, [r2, #0]
 80a0b02:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
 80a0b04:	bd10      	pop	{r4, pc}

080a0b06 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a0b06:	b570      	push	{r4, r5, r6, lr}
 80a0b08:	460e      	mov	r6, r1
	if (!reserve(length)) {
 80a0b0a:	4611      	mov	r1, r2
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a0b0c:	4604      	mov	r4, r0
 80a0b0e:	4615      	mov	r5, r2
	if (!reserve(length)) {
 80a0b10:	f7ff ffe8 	bl	80a0ae4 <_ZN6String7reserveEj>
 80a0b14:	b918      	cbnz	r0, 80a0b1e <_ZN6String4copyEPKcj+0x18>
		invalidate();
 80a0b16:	4620      	mov	r0, r4
 80a0b18:	f7ff ffcd 	bl	80a0ab6 <_ZN6String10invalidateEv>
		return *this;
 80a0b1c:	e004      	b.n	80a0b28 <_ZN6String4copyEPKcj+0x22>
	}
	len = length;
 80a0b1e:	60a5      	str	r5, [r4, #8]
	strcpy(buffer, cstr);
 80a0b20:	6820      	ldr	r0, [r4, #0]
 80a0b22:	4631      	mov	r1, r6
 80a0b24:	f000 fcb9 	bl	80a149a <strcpy>
	return *this;
}
 80a0b28:	4620      	mov	r0, r4
 80a0b2a:	bd70      	pop	{r4, r5, r6, pc}

080a0b2c <_ZN6StringC1EPKc>:

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
 80a0b2c:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a0b2e:	2300      	movs	r3, #0

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
 80a0b30:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a0b32:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a0b34:	6043      	str	r3, [r0, #4]
	len = 0;
 80a0b36:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a0b38:	7303      	strb	r3, [r0, #12]
/*********************************************/

String::String(const char *cstr)
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
 80a0b3a:	460d      	mov	r5, r1
 80a0b3c:	b139      	cbz	r1, 80a0b4e <_ZN6StringC1EPKc+0x22>
 80a0b3e:	4608      	mov	r0, r1
 80a0b40:	f000 fcb3 	bl	80a14aa <strlen>
 80a0b44:	4629      	mov	r1, r5
 80a0b46:	4602      	mov	r2, r0
 80a0b48:	4620      	mov	r0, r4
 80a0b4a:	f7ff ffdc 	bl	80a0b06 <_ZN6String4copyEPKcj>
}
 80a0b4e:	4620      	mov	r0, r4
 80a0b50:	bd38      	pop	{r3, r4, r5, pc}

080a0b52 <_ZN6StringaSERKS_>:
}
#endif

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
 80a0b52:	4288      	cmp	r0, r1
	rhs.len = 0;
}
#endif

String & String::operator = (const String &rhs)
{
 80a0b54:	b510      	push	{r4, lr}
 80a0b56:	460b      	mov	r3, r1
 80a0b58:	4604      	mov	r4, r0
	if (this == &rhs) return *this;
 80a0b5a:	d007      	beq.n	80a0b6c <_ZN6StringaSERKS_+0x1a>

	if (rhs.buffer) copy(rhs.buffer, rhs.len);
 80a0b5c:	6809      	ldr	r1, [r1, #0]
 80a0b5e:	b119      	cbz	r1, 80a0b68 <_ZN6StringaSERKS_+0x16>
 80a0b60:	689a      	ldr	r2, [r3, #8]
 80a0b62:	f7ff ffd0 	bl	80a0b06 <_ZN6String4copyEPKcj>
 80a0b66:	e001      	b.n	80a0b6c <_ZN6StringaSERKS_+0x1a>
	else invalidate();
 80a0b68:	f7ff ffa5 	bl	80a0ab6 <_ZN6String10invalidateEv>

	return *this;
}
 80a0b6c:	4620      	mov	r0, r4
 80a0b6e:	bd10      	pop	{r4, pc}

080a0b70 <_ZN6StringC1ERKS_>:
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
}

String::String(const String &value)
 80a0b70:	b510      	push	{r4, lr}
 80a0b72:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a0b74:	2300      	movs	r3, #0
 80a0b76:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a0b78:	6043      	str	r3, [r0, #4]
	len = 0;
 80a0b7a:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a0b7c:	7303      	strb	r3, [r0, #12]
}

String::String(const String &value)
{
	init();
	*this = value;
 80a0b7e:	f7ff ffe8 	bl	80a0b52 <_ZN6StringaSERKS_>
}
 80a0b82:	4620      	mov	r0, r4
 80a0b84:	bd10      	pop	{r4, pc}

080a0b86 <_ZN6StringaSEPKc>:
	return *this;
}
#endif

String & String::operator = (const char *cstr)
{
 80a0b86:	b538      	push	{r3, r4, r5, lr}
 80a0b88:	4605      	mov	r5, r0
	if (cstr) copy(cstr, strlen(cstr));
 80a0b8a:	460c      	mov	r4, r1
 80a0b8c:	b141      	cbz	r1, 80a0ba0 <_ZN6StringaSEPKc+0x1a>
 80a0b8e:	4608      	mov	r0, r1
 80a0b90:	f000 fc8b 	bl	80a14aa <strlen>
 80a0b94:	4621      	mov	r1, r4
 80a0b96:	4602      	mov	r2, r0
 80a0b98:	4628      	mov	r0, r5
 80a0b9a:	f7ff ffb4 	bl	80a0b06 <_ZN6String4copyEPKcj>
 80a0b9e:	e001      	b.n	80a0ba4 <_ZN6StringaSEPKc+0x1e>
	else invalidate();
 80a0ba0:	f7ff ff89 	bl	80a0ab6 <_ZN6String10invalidateEv>

	return *this;
}
 80a0ba4:	4628      	mov	r0, r5
 80a0ba6:	bd38      	pop	{r3, r4, r5, pc}

080a0ba8 <_ZN6StringC1Ec>:
	init();
	move(rval);
}
#endif

String::String(char c)
 80a0ba8:	b513      	push	{r0, r1, r4, lr}
 80a0baa:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a0bac:	2300      	movs	r3, #0

String::String(char c)
{
	init();
	char buf[2];
	buf[0] = c;
 80a0bae:	f88d 1004 	strb.w	r1, [sp, #4]
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a0bb2:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a0bb4:	6043      	str	r3, [r0, #4]
	len = 0;
 80a0bb6:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a0bb8:	7303      	strb	r3, [r0, #12]
{
	init();
	char buf[2];
	buf[0] = c;
	buf[1] = 0;
	*this = buf;
 80a0bba:	a901      	add	r1, sp, #4
String::String(char c)
{
	init();
	char buf[2];
	buf[0] = c;
	buf[1] = 0;
 80a0bbc:	f88d 3005 	strb.w	r3, [sp, #5]
	*this = buf;
 80a0bc0:	f7ff ffe1 	bl	80a0b86 <_ZN6StringaSEPKc>
}
 80a0bc4:	4620      	mov	r0, r4
 80a0bc6:	b002      	add	sp, #8
 80a0bc8:	bd10      	pop	{r4, pc}

080a0bca <_ZN6String6concatEPKcj>:
{
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
 80a0bca:	b570      	push	{r4, r5, r6, lr}
 80a0bcc:	4604      	mov	r4, r0
	unsigned int newlen = len + length;
 80a0bce:	6883      	ldr	r3, [r0, #8]
	if (!cstr) return 0;
 80a0bd0:	460e      	mov	r6, r1
 80a0bd2:	b909      	cbnz	r1, 80a0bd8 <_ZN6String6concatEPKcj+0xe>
 80a0bd4:	2000      	movs	r0, #0
 80a0bd6:	bd70      	pop	{r4, r5, r6, pc}
	if (length == 0) return 1;
 80a0bd8:	b162      	cbz	r2, 80a0bf4 <_ZN6String6concatEPKcj+0x2a>
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
 80a0bda:	18d5      	adds	r5, r2, r3
	if (!cstr) return 0;
	if (length == 0) return 1;
	if (!reserve(newlen)) return 0;
 80a0bdc:	4629      	mov	r1, r5
 80a0bde:	f7ff ff81 	bl	80a0ae4 <_ZN6String7reserveEj>
 80a0be2:	2800      	cmp	r0, #0
 80a0be4:	d0f6      	beq.n	80a0bd4 <_ZN6String6concatEPKcj+0xa>
	strcpy(buffer + len, cstr);
 80a0be6:	6820      	ldr	r0, [r4, #0]
 80a0be8:	68a3      	ldr	r3, [r4, #8]
 80a0bea:	4631      	mov	r1, r6
 80a0bec:	4418      	add	r0, r3
 80a0bee:	f000 fc54 	bl	80a149a <strcpy>
	len = newlen;
 80a0bf2:	60a5      	str	r5, [r4, #8]

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
	if (!cstr) return 0;
	if (length == 0) return 1;
 80a0bf4:	2001      	movs	r0, #1
	if (!reserve(newlen)) return 0;
	strcpy(buffer + len, cstr);
	len = newlen;
	return 1;
}
 80a0bf6:	bd70      	pop	{r4, r5, r6, pc}

080a0bf8 <_ZN6String6concatEc>:
	if (!cstr) return 0;
	return concat(cstr, strlen(cstr));
}

unsigned char String::concat(char c)
{
 80a0bf8:	b507      	push	{r0, r1, r2, lr}
	char buf[2];
	buf[0] = c;
	buf[1] = 0;
 80a0bfa:	2300      	movs	r3, #0
}

unsigned char String::concat(char c)
{
	char buf[2];
	buf[0] = c;
 80a0bfc:	f88d 1004 	strb.w	r1, [sp, #4]
	buf[1] = 0;
	return concat(buf, 1);
 80a0c00:	2201      	movs	r2, #1
 80a0c02:	a901      	add	r1, sp, #4

unsigned char String::concat(char c)
{
	char buf[2];
	buf[0] = c;
	buf[1] = 0;
 80a0c04:	f88d 3005 	strb.w	r3, [sp, #5]
	return concat(buf, 1);
 80a0c08:	f7ff ffdf 	bl	80a0bca <_ZN6String6concatEPKcj>
}
 80a0c0c:	b003      	add	sp, #12
 80a0c0e:	f85d fb04 	ldr.w	pc, [sp], #4

080a0c12 <_ZplRK15StringSumHelperRK6String>:
/*********************************************/
/*  Concatenate                              */
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
 80a0c12:	460b      	mov	r3, r1
 80a0c14:	b510      	push	{r4, lr}
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
 80a0c16:	689a      	ldr	r2, [r3, #8]
 80a0c18:	6809      	ldr	r1, [r1, #0]
/*********************************************/
/*  Concatenate                              */
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
 80a0c1a:	4604      	mov	r4, r0
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
 80a0c1c:	f7ff ffd5 	bl	80a0bca <_ZN6String6concatEPKcj>
 80a0c20:	b910      	cbnz	r0, 80a0c28 <_ZplRK15StringSumHelperRK6String+0x16>
 80a0c22:	4620      	mov	r0, r4
 80a0c24:	f7ff ff47 	bl	80a0ab6 <_ZN6String10invalidateEv>
	return a;
}
 80a0c28:	4620      	mov	r0, r4
 80a0c2a:	bd10      	pop	{r4, pc}

080a0c2c <_ZNK6String6equalsEPKc>:
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
 80a0c2c:	b508      	push	{r3, lr}
	if (len == 0) return (cstr == NULL || *cstr == 0);
 80a0c2e:	6882      	ldr	r2, [r0, #8]
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
 80a0c30:	460b      	mov	r3, r1
	if (len == 0) return (cstr == NULL || *cstr == 0);
 80a0c32:	b912      	cbnz	r2, 80a0c3a <_ZNK6String6equalsEPKc+0xe>
 80a0c34:	b919      	cbnz	r1, 80a0c3e <_ZNK6String6equalsEPKc+0x12>
 80a0c36:	2001      	movs	r0, #1
 80a0c38:	bd08      	pop	{r3, pc}
	if (cstr == NULL) return buffer[0] == 0;
 80a0c3a:	b911      	cbnz	r1, 80a0c42 <_ZNK6String6equalsEPKc+0x16>
 80a0c3c:	6803      	ldr	r3, [r0, #0]
 80a0c3e:	7818      	ldrb	r0, [r3, #0]
 80a0c40:	e002      	b.n	80a0c48 <_ZNK6String6equalsEPKc+0x1c>
	return strcmp(buffer, cstr) == 0;
 80a0c42:	6800      	ldr	r0, [r0, #0]
 80a0c44:	f000 fc1f 	bl	80a1486 <strcmp>
 80a0c48:	fab0 f080 	clz	r0, r0
 80a0c4c:	0940      	lsrs	r0, r0, #5
}
 80a0c4e:	bd08      	pop	{r3, pc}

080a0c50 <_ZNK6String10startsWithERKS_j>:
	if (len < s2.len) return 0;
	return startsWith(s2, 0);
}

unsigned char String::startsWith( const String &s2, unsigned int offset ) const
{
 80a0c50:	b510      	push	{r4, lr}
 80a0c52:	4614      	mov	r4, r2
	if (offset > len - s2.len || !buffer || !s2.buffer) return 0;
 80a0c54:	6883      	ldr	r3, [r0, #8]
 80a0c56:	688a      	ldr	r2, [r1, #8]
 80a0c58:	1a9b      	subs	r3, r3, r2
 80a0c5a:	429c      	cmp	r4, r3
 80a0c5c:	d80a      	bhi.n	80a0c74 <_ZNK6String10startsWithERKS_j+0x24>
 80a0c5e:	6800      	ldr	r0, [r0, #0]
 80a0c60:	b158      	cbz	r0, 80a0c7a <_ZNK6String10startsWithERKS_j+0x2a>
 80a0c62:	6809      	ldr	r1, [r1, #0]
 80a0c64:	b141      	cbz	r1, 80a0c78 <_ZNK6String10startsWithERKS_j+0x28>
	return strncmp( &buffer[offset], s2.buffer, s2.len ) == 0;
 80a0c66:	4420      	add	r0, r4
 80a0c68:	f000 fc27 	bl	80a14ba <strncmp>
 80a0c6c:	fab0 f080 	clz	r0, r0
 80a0c70:	0940      	lsrs	r0, r0, #5
 80a0c72:	bd10      	pop	{r4, pc}
	return startsWith(s2, 0);
}

unsigned char String::startsWith( const String &s2, unsigned int offset ) const
{
	if (offset > len - s2.len || !buffer || !s2.buffer) return 0;
 80a0c74:	2000      	movs	r0, #0
 80a0c76:	bd10      	pop	{r4, pc}
 80a0c78:	4608      	mov	r0, r1
	return strncmp( &buffer[offset], s2.buffer, s2.len ) == 0;
}
 80a0c7a:	bd10      	pop	{r4, pc}

080a0c7c <_ZNK6String10startsWithERKS_>:
	return 1;
}

unsigned char String::startsWith( const String &s2 ) const
{
	if (len < s2.len) return 0;
 80a0c7c:	6882      	ldr	r2, [r0, #8]
 80a0c7e:	688b      	ldr	r3, [r1, #8]
 80a0c80:	429a      	cmp	r2, r3
 80a0c82:	d302      	bcc.n	80a0c8a <_ZNK6String10startsWithERKS_+0xe>
	return startsWith(s2, 0);
 80a0c84:	2200      	movs	r2, #0
 80a0c86:	f7ff bfe3 	b.w	80a0c50 <_ZNK6String10startsWithERKS_j>
}
 80a0c8a:	2000      	movs	r0, #0
 80a0c8c:	4770      	bx	lr

080a0c8e <_ZNK6StringixEj>:
	return buffer[index];
}

char String::operator[]( unsigned int index ) const
{
	if (index >= len || !buffer) return 0;
 80a0c8e:	6883      	ldr	r3, [r0, #8]
 80a0c90:	4299      	cmp	r1, r3
 80a0c92:	d203      	bcs.n	80a0c9c <_ZNK6StringixEj+0xe>
 80a0c94:	6800      	ldr	r0, [r0, #0]
 80a0c96:	b110      	cbz	r0, 80a0c9e <_ZNK6StringixEj+0x10>
	return buffer[index];
 80a0c98:	5c40      	ldrb	r0, [r0, r1]
 80a0c9a:	4770      	bx	lr
	return buffer[index];
}

char String::operator[]( unsigned int index ) const
{
	if (index >= len || !buffer) return 0;
 80a0c9c:	2000      	movs	r0, #0
	return buffer[index];
}
 80a0c9e:	4770      	bx	lr

080a0ca0 <_ZNK6String6charAtEj>:
/*  Character Access                         */
/*********************************************/

char String::charAt(unsigned int loc) const
{
	return operator[](loc);
 80a0ca0:	f7ff bff5 	b.w	80a0c8e <_ZNK6StringixEj>

080a0ca4 <_ZNK6String9substringEjj>:
{
	return substring(left, len);
}

String String::substring(unsigned int left, unsigned int right) const
{
 80a0ca4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a0ca8:	461c      	mov	r4, r3
	if (left > right) {
 80a0caa:	429a      	cmp	r2, r3
 80a0cac:	bf88      	it	hi
 80a0cae:	4613      	movhi	r3, r2
{
	return substring(left, len);
}

String String::substring(unsigned int left, unsigned int right) const
{
 80a0cb0:	460e      	mov	r6, r1
 80a0cb2:	4615      	mov	r5, r2
	if (left > right) {
 80a0cb4:	bf88      	it	hi
 80a0cb6:	4625      	movhi	r5, r4
		unsigned int temp = right;
		right = left;
		left = temp;
	}
	String out;
 80a0cb8:	490d      	ldr	r1, [pc, #52]	; (80a0cf0 <_ZNK6String9substringEjj+0x4c>)
	return substring(left, len);
}

String String::substring(unsigned int left, unsigned int right) const
{
	if (left > right) {
 80a0cba:	bf88      	it	hi
 80a0cbc:	461c      	movhi	r4, r3
{
	return substring(left, len);
}

String String::substring(unsigned int left, unsigned int right) const
{
 80a0cbe:	4607      	mov	r7, r0
	if (left > right) {
		unsigned int temp = right;
		right = left;
		left = temp;
	}
	String out;
 80a0cc0:	f7ff ff34 	bl	80a0b2c <_ZN6StringC1EPKc>
	if (left > len) return out;
 80a0cc4:	68b1      	ldr	r1, [r6, #8]
 80a0cc6:	428d      	cmp	r5, r1
 80a0cc8:	d80f      	bhi.n	80a0cea <_ZNK6String9substringEjj+0x46>
 80a0cca:	428c      	cmp	r4, r1
 80a0ccc:	bf28      	it	cs
 80a0cce:	460c      	movcs	r4, r1
	if (right > len) right = len;
	char temp = buffer[right];  // save the replaced character
 80a0cd0:	6833      	ldr	r3, [r6, #0]
	buffer[right] = '\0';
 80a0cd2:	2200      	movs	r2, #0
		left = temp;
	}
	String out;
	if (left > len) return out;
	if (right > len) right = len;
	char temp = buffer[right];  // save the replaced character
 80a0cd4:	f813 8004 	ldrb.w	r8, [r3, r4]
	buffer[right] = '\0';
 80a0cd8:	551a      	strb	r2, [r3, r4]
	out = buffer + left;  // pointer arithmetic
 80a0cda:	6831      	ldr	r1, [r6, #0]
 80a0cdc:	4638      	mov	r0, r7
 80a0cde:	4429      	add	r1, r5
 80a0ce0:	f7ff ff51 	bl	80a0b86 <_ZN6StringaSEPKc>
	buffer[right] = temp;  //restore character
 80a0ce4:	6833      	ldr	r3, [r6, #0]
 80a0ce6:	f803 8004 	strb.w	r8, [r3, r4]
	return out;
}
 80a0cea:	4638      	mov	r0, r7
 80a0cec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a0cf0:	080a162d 	.word	0x080a162d

080a0cf4 <_ZNK6String9substringEj>:
	}
	return found;
}

String String::substring( unsigned int left ) const
{
 80a0cf4:	b510      	push	{r4, lr}
 80a0cf6:	4604      	mov	r4, r0
	return substring(left, len);
 80a0cf8:	688b      	ldr	r3, [r1, #8]
 80a0cfa:	f7ff ffd3 	bl	80a0ca4 <_ZNK6String9substringEjj>
}
 80a0cfe:	4620      	mov	r0, r4
 80a0d00:	bd10      	pop	{r4, pc}

080a0d02 <_ZN6String4trimEv>:
        }
        return *this;
}

String& String::trim(void)
{
 80a0d02:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!buffer || len == 0) return *this;
 80a0d06:	6807      	ldr	r7, [r0, #0]
        }
        return *this;
}

String& String::trim(void)
{
 80a0d08:	4605      	mov	r5, r0
	if (!buffer || len == 0) return *this;
 80a0d0a:	b317      	cbz	r7, 80a0d52 <_ZN6String4trimEv+0x50>
 80a0d0c:	6884      	ldr	r4, [r0, #8]
 80a0d0e:	b304      	cbz	r4, 80a0d52 <_ZN6String4trimEv+0x50>
 80a0d10:	46b8      	mov	r8, r7
 80a0d12:	4646      	mov	r6, r8
	char *begin = buffer;
	while (isspace(*begin)) begin++;
 80a0d14:	7830      	ldrb	r0, [r6, #0]
 80a0d16:	f108 0801 	add.w	r8, r8, #1
 80a0d1a:	f000 fb97 	bl	80a144c <isspace>
 80a0d1e:	2800      	cmp	r0, #0
 80a0d20:	d1f7      	bne.n	80a0d12 <_ZN6String4trimEv+0x10>
	char *end = buffer + len - 1;
 80a0d22:	3c01      	subs	r4, #1
 80a0d24:	443c      	add	r4, r7
	while (isspace(*end) && end >= begin) end--;
 80a0d26:	7820      	ldrb	r0, [r4, #0]
 80a0d28:	f000 fb90 	bl	80a144c <isspace>
 80a0d2c:	b948      	cbnz	r0, 80a0d42 <_ZN6String4trimEv+0x40>
	len = end + 1 - begin;
 80a0d2e:	1c62      	adds	r2, r4, #1
 80a0d30:	1b92      	subs	r2, r2, r6
	if (begin > buffer) memcpy(buffer, begin, len);
 80a0d32:	42be      	cmp	r6, r7
	if (!buffer || len == 0) return *this;
	char *begin = buffer;
	while (isspace(*begin)) begin++;
	char *end = buffer + len - 1;
	while (isspace(*end) && end >= begin) end--;
	len = end + 1 - begin;
 80a0d34:	60aa      	str	r2, [r5, #8]
	if (begin > buffer) memcpy(buffer, begin, len);
 80a0d36:	d908      	bls.n	80a0d4a <_ZN6String4trimEv+0x48>
 80a0d38:	4638      	mov	r0, r7
 80a0d3a:	4631      	mov	r1, r6
 80a0d3c:	f000 fb90 	bl	80a1460 <memcpy>
 80a0d40:	e003      	b.n	80a0d4a <_ZN6String4trimEv+0x48>
{
	if (!buffer || len == 0) return *this;
	char *begin = buffer;
	while (isspace(*begin)) begin++;
	char *end = buffer + len - 1;
	while (isspace(*end) && end >= begin) end--;
 80a0d42:	42b4      	cmp	r4, r6
 80a0d44:	d3f3      	bcc.n	80a0d2e <_ZN6String4trimEv+0x2c>
 80a0d46:	3c01      	subs	r4, #1
 80a0d48:	e7ed      	b.n	80a0d26 <_ZN6String4trimEv+0x24>
	len = end + 1 - begin;
	if (begin > buffer) memcpy(buffer, begin, len);
	buffer[len] = 0;
 80a0d4a:	682a      	ldr	r2, [r5, #0]
 80a0d4c:	68ab      	ldr	r3, [r5, #8]
 80a0d4e:	2100      	movs	r1, #0
 80a0d50:	54d1      	strb	r1, [r2, r3]
        return *this;
}
 80a0d52:	4628      	mov	r0, r5
 80a0d54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a0d58 <_ZNK6String5toIntEv>:
/*  Parsing / Conversion                     */
/*********************************************/

long String::toInt(void) const
{
	if (buffer) return atol(buffer);
 80a0d58:	6800      	ldr	r0, [r0, #0]
 80a0d5a:	b108      	cbz	r0, 80a0d60 <_ZNK6String5toIntEv+0x8>
 80a0d5c:	f000 bb64 	b.w	80a1428 <atol>
	return 0;
}
 80a0d60:	4770      	bx	lr
	...

080a0d64 <_GLOBAL__sub_I_System>:
 80a0d64:	4b07      	ldr	r3, [pc, #28]	; (80a0d84 <_GLOBAL__sub_I_System+0x20>)
 80a0d66:	2000      	movs	r0, #0
 80a0d68:	4a07      	ldr	r2, [pc, #28]	; (80a0d88 <_GLOBAL__sub_I_System+0x24>)
 80a0d6a:	7018      	strb	r0, [r3, #0]
 80a0d6c:	2301      	movs	r3, #1
 80a0d6e:	7013      	strb	r3, [r2, #0]
 80a0d70:	4a06      	ldr	r2, [pc, #24]	; (80a0d8c <_GLOBAL__sub_I_System+0x28>)
 80a0d72:	7010      	strb	r0, [r2, #0]
 80a0d74:	4a06      	ldr	r2, [pc, #24]	; (80a0d90 <_GLOBAL__sub_I_System+0x2c>)
 80a0d76:	7013      	strb	r3, [r2, #0]
 80a0d78:	4b06      	ldr	r3, [pc, #24]	; (80a0d94 <_GLOBAL__sub_I_System+0x30>)
 80a0d7a:	2202      	movs	r2, #2
 80a0d7c:	701a      	strb	r2, [r3, #0]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a0d7e:	f7ff bc4f 	b.w	80a0620 <set_system_mode>
 80a0d82:	bf00      	nop
 80a0d84:	200003cc 	.word	0x200003cc
 80a0d88:	200003cd 	.word	0x200003cd
 80a0d8c:	200003ca 	.word	0x200003ca
 80a0d90:	200003cb 	.word	0x200003cb
 80a0d94:	200003c9 	.word	0x200003c9

080a0d98 <_GLOBAL__sub_I__ZN9TCPServerC2Etm>:
{
public:
    typedef uint8_t flag_t;
    inline SleepNetworkFlag(SystemSleepNetwork f) : SleepNetworkFlag(static_cast<flag_t>(f)) {}

    inline SleepNetworkFlag(flag_t flag) : flag_(flag) {}
 80a0d98:	4b06      	ldr	r3, [pc, #24]	; (80a0db4 <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x1c>)
 80a0d9a:	2200      	movs	r2, #0
 80a0d9c:	4906      	ldr	r1, [pc, #24]	; (80a0db8 <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x20>)
 80a0d9e:	701a      	strb	r2, [r3, #0]
 80a0da0:	2301      	movs	r3, #1
 80a0da2:	700b      	strb	r3, [r1, #0]
 80a0da4:	4905      	ldr	r1, [pc, #20]	; (80a0dbc <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x24>)
 80a0da6:	700a      	strb	r2, [r1, #0]
 80a0da8:	4a05      	ldr	r2, [pc, #20]	; (80a0dc0 <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x28>)
 80a0daa:	7013      	strb	r3, [r2, #0]
 80a0dac:	4b05      	ldr	r3, [pc, #20]	; (80a0dc4 <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x2c>)
 80a0dae:	2202      	movs	r2, #2
 80a0db0:	701a      	strb	r2, [r3, #0]
 80a0db2:	4770      	bx	lr
 80a0db4:	200003d1 	.word	0x200003d1
 80a0db8:	200003d2 	.word	0x200003d2
 80a0dbc:	200003cf 	.word	0x200003cf
 80a0dc0:	200003d0 	.word	0x200003d0
 80a0dc4:	200003ce 	.word	0x200003ce

080a0dc8 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a0dc8:	4b02      	ldr	r3, [pc, #8]	; (80a0dd4 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
 80a0dca:	681a      	ldr	r2, [r3, #0]
 80a0dcc:	4b02      	ldr	r3, [pc, #8]	; (80a0dd8 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
 80a0dce:	601a      	str	r2, [r3, #0]
 80a0dd0:	4770      	bx	lr
 80a0dd2:	bf00      	nop
 80a0dd4:	2000030c 	.word	0x2000030c
 80a0dd8:	200003d4 	.word	0x200003d4

080a0ddc <_GLOBAL__sub_I_tone>:
 80a0ddc:	4b06      	ldr	r3, [pc, #24]	; (80a0df8 <_GLOBAL__sub_I_tone+0x1c>)
 80a0dde:	2200      	movs	r2, #0
 80a0de0:	4906      	ldr	r1, [pc, #24]	; (80a0dfc <_GLOBAL__sub_I_tone+0x20>)
 80a0de2:	701a      	strb	r2, [r3, #0]
 80a0de4:	2301      	movs	r3, #1
 80a0de6:	700b      	strb	r3, [r1, #0]
 80a0de8:	4905      	ldr	r1, [pc, #20]	; (80a0e00 <_GLOBAL__sub_I_tone+0x24>)
 80a0dea:	700a      	strb	r2, [r1, #0]
 80a0dec:	4a05      	ldr	r2, [pc, #20]	; (80a0e04 <_GLOBAL__sub_I_tone+0x28>)
 80a0dee:	7013      	strb	r3, [r2, #0]
 80a0df0:	4b05      	ldr	r3, [pc, #20]	; (80a0e08 <_GLOBAL__sub_I_tone+0x2c>)
 80a0df2:	2202      	movs	r2, #2
 80a0df4:	701a      	strb	r2, [r3, #0]
 80a0df6:	4770      	bx	lr
 80a0df8:	200003db 	.word	0x200003db
 80a0dfc:	200003dc 	.word	0x200003dc
 80a0e00:	200003d9 	.word	0x200003d9
 80a0e04:	200003da 	.word	0x200003da
 80a0e08:	200003d8 	.word	0x200003d8

080a0e0c <_GLOBAL__sub_I__ZN3UDPC2Ev>:
 80a0e0c:	4b06      	ldr	r3, [pc, #24]	; (80a0e28 <_GLOBAL__sub_I__ZN3UDPC2Ev+0x1c>)
 80a0e0e:	2200      	movs	r2, #0
 80a0e10:	4906      	ldr	r1, [pc, #24]	; (80a0e2c <_GLOBAL__sub_I__ZN3UDPC2Ev+0x20>)
 80a0e12:	701a      	strb	r2, [r3, #0]
 80a0e14:	2301      	movs	r3, #1
 80a0e16:	700b      	strb	r3, [r1, #0]
 80a0e18:	4905      	ldr	r1, [pc, #20]	; (80a0e30 <_GLOBAL__sub_I__ZN3UDPC2Ev+0x24>)
 80a0e1a:	700a      	strb	r2, [r1, #0]
 80a0e1c:	4a05      	ldr	r2, [pc, #20]	; (80a0e34 <_GLOBAL__sub_I__ZN3UDPC2Ev+0x28>)
 80a0e1e:	7013      	strb	r3, [r2, #0]
 80a0e20:	4b05      	ldr	r3, [pc, #20]	; (80a0e38 <_GLOBAL__sub_I__ZN3UDPC2Ev+0x2c>)
 80a0e22:	2202      	movs	r2, #2
 80a0e24:	701a      	strb	r2, [r3, #0]
 80a0e26:	4770      	bx	lr
 80a0e28:	200003e0 	.word	0x200003e0
 80a0e2c:	200003e1 	.word	0x200003e1
 80a0e30:	200003de 	.word	0x200003de
 80a0e34:	200003df 	.word	0x200003df
 80a0e38:	200003dd 	.word	0x200003dd

080a0e3c <_ZN11USARTSerialD1Ev>:
private:
  HAL_USART_Serial _serial;
  bool _blocking;
public:
  USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer);
  virtual ~USARTSerial() {};
 80a0e3c:	4770      	bx	lr

080a0e3e <_ZN11USARTSerial14blockOnOverrunEb>:
    HAL_USART_Half_Duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a0e3e:	7441      	strb	r1, [r0, #17]
 80a0e40:	4770      	bx	lr

080a0e42 <_ZN11USARTSerial17availableForWriteEv>:
}


int USARTSerial::availableForWrite(void)
{
  return HAL_USART_Available_Data(_serial);
 80a0e42:	7c00      	ldrb	r0, [r0, #16]
 80a0e44:	f7ff bba4 	b.w	80a0590 <HAL_USART_Available_Data>

080a0e48 <_ZN11USARTSerial9availableEv>:
}

int USARTSerial::available(void)
{
  return HAL_USART_Available_Data(_serial);
 80a0e48:	7c00      	ldrb	r0, [r0, #16]
 80a0e4a:	f7ff bba1 	b.w	80a0590 <HAL_USART_Available_Data>

080a0e4e <_ZN11USARTSerial4peekEv>:
}

int USARTSerial::peek(void)
{
  return HAL_USART_Peek_Data(_serial);
 80a0e4e:	7c00      	ldrb	r0, [r0, #16]
 80a0e50:	f7ff bbae 	b.w	80a05b0 <HAL_USART_Peek_Data>

080a0e54 <_ZN11USARTSerial4readEv>:
}

int USARTSerial::read(void)
{
  return HAL_USART_Read_Data(_serial);
 80a0e54:	7c00      	ldrb	r0, [r0, #16]
 80a0e56:	f7ff bba3 	b.w	80a05a0 <HAL_USART_Read_Data>

080a0e5a <_ZN11USARTSerial5flushEv>:
}

void USARTSerial::flush()
{
  HAL_USART_Flush_Data(_serial);
 80a0e5a:	7c00      	ldrb	r0, [r0, #16]
 80a0e5c:	f7ff bbb0 	b.w	80a05c0 <HAL_USART_Flush_Data>

080a0e60 <_ZN11USARTSerialD0Ev>:
 80a0e60:	b510      	push	{r4, lr}
 80a0e62:	4604      	mov	r4, r0
 80a0e64:	f7ff f919 	bl	80a009a <_ZdlPv>
 80a0e68:	4620      	mov	r0, r4
 80a0e6a:	bd10      	pop	{r4, pc}

080a0e6c <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
 80a0e6c:	b570      	push	{r4, r5, r6, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a0e6e:	7c45      	ldrb	r5, [r0, #17]
{
  HAL_USART_Flush_Data(_serial);
}

size_t USARTSerial::write(uint8_t c)
{
 80a0e70:	4604      	mov	r4, r0
 80a0e72:	460e      	mov	r6, r1
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a0e74:	b925      	cbnz	r5, 80a0e80 <_ZN11USARTSerial5writeEh+0x14>
 80a0e76:	7c00      	ldrb	r0, [r0, #16]
 80a0e78:	f7ff fbb2 	bl	80a05e0 <HAL_USART_Available_Data_For_Write>
 80a0e7c:	2800      	cmp	r0, #0
 80a0e7e:	dd05      	ble.n	80a0e8c <_ZN11USARTSerial5writeEh+0x20>
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a0e80:	7c20      	ldrb	r0, [r4, #16]
 80a0e82:	4631      	mov	r1, r6
  }
  return 0;
}
 80a0e84:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
size_t USARTSerial::write(uint8_t c)
{
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a0e88:	f7ff bb7a 	b.w	80a0580 <HAL_USART_Write_Data>
  }
  return 0;
}
 80a0e8c:	4628      	mov	r0, r5
 80a0e8e:	bd70      	pop	{r4, r5, r6, pc}

080a0e90 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>:
#include "spark_wiring_usartserial.h"
#include "spark_wiring_constants.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a0e90:	b510      	push	{r4, lr}
 80a0e92:	4604      	mov	r4, r0
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a0e94:	2000      	movs	r0, #0
 80a0e96:	6060      	str	r0, [r4, #4]
 80a0e98:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80a0e9c:	60a0      	str	r0, [r4, #8]
 80a0e9e:	4806      	ldr	r0, [pc, #24]	; (80a0eb8 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_+0x28>)
{
  _serial = serial;
 80a0ea0:	7421      	strb	r1, [r4, #16]
#include "spark_wiring_usartserial.h"
#include "spark_wiring_constants.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a0ea2:	6020      	str	r0, [r4, #0]
{
  _serial = serial;
  // Default is blocking mode
  _blocking = true;
 80a0ea4:	2001      	movs	r0, #1
 80a0ea6:	7460      	strb	r0, [r4, #17]
  HAL_USART_Init(serial, rx_buffer, tx_buffer);
 80a0ea8:	4608      	mov	r0, r1
 80a0eaa:	4611      	mov	r1, r2
 80a0eac:	461a      	mov	r2, r3
 80a0eae:	f7ff fb5f 	bl	80a0570 <HAL_USART_Init>
}
 80a0eb2:	4620      	mov	r0, r4
 80a0eb4:	bd10      	pop	{r4, pc}
 80a0eb6:	bf00      	nop
 80a0eb8:	080a16c8 	.word	0x080a16c8

080a0ebc <_ZN11USARTSerial5beginEmm>:
  begin(baud, SERIAL_8N1);
}

void USARTSerial::begin(unsigned long baud, uint32_t config)
{
  HAL_USART_BeginConfig(_serial, baud, config, 0);
 80a0ebc:	7c00      	ldrb	r0, [r0, #16]
 80a0ebe:	2300      	movs	r3, #0
 80a0ec0:	f7ff bba6 	b.w	80a0610 <HAL_USART_BeginConfig>

080a0ec4 <_ZN11USARTSerial5beginEm>:
}
// Public Methods //////////////////////////////////////////////////////////////

void USARTSerial::begin(unsigned long baud)
{
  begin(baud, SERIAL_8N1);
 80a0ec4:	2200      	movs	r2, #0
 80a0ec6:	f7ff bff9 	b.w	80a0ebc <_ZN11USARTSerial5beginEmm>

080a0eca <_ZN11USARTSerial9isEnabledEv>:
USARTSerial::operator bool() {
  return true;
}

bool USARTSerial::isEnabled() {
  return HAL_USART_Is_Enabled(_serial);
 80a0eca:	7c00      	ldrb	r0, [r0, #16]
 80a0ecc:	f7ff bb80 	b.w	80a05d0 <HAL_USART_Is_Enabled>

080a0ed0 <_Z22__fetch_global_Serial1v>:
// Preinstantiate Objects //////////////////////////////////////////////////////
static Ring_Buffer serial1_rx_buffer;
static Ring_Buffer serial1_tx_buffer;

USARTSerial& __fetch_global_Serial1()
{
 80a0ed0:	b538      	push	{r3, r4, r5, lr}
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
 80a0ed2:	4d0c      	ldr	r5, [pc, #48]	; (80a0f04 <_Z22__fetch_global_Serial1v+0x34>)
 80a0ed4:	6829      	ldr	r1, [r5, #0]
 80a0ed6:	f011 0401 	ands.w	r4, r1, #1
 80a0eda:	d111      	bne.n	80a0f00 <_Z22__fetch_global_Serial1v+0x30>
 80a0edc:	4628      	mov	r0, r5
 80a0ede:	f7ff f8de 	bl	80a009e <__cxa_guard_acquire>
 80a0ee2:	b168      	cbz	r0, 80a0f00 <_Z22__fetch_global_Serial1v+0x30>
 80a0ee4:	4621      	mov	r1, r4
 80a0ee6:	4a08      	ldr	r2, [pc, #32]	; (80a0f08 <_Z22__fetch_global_Serial1v+0x38>)
 80a0ee8:	4b08      	ldr	r3, [pc, #32]	; (80a0f0c <_Z22__fetch_global_Serial1v+0x3c>)
 80a0eea:	4809      	ldr	r0, [pc, #36]	; (80a0f10 <_Z22__fetch_global_Serial1v+0x40>)
 80a0eec:	f7ff ffd0 	bl	80a0e90 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>
 80a0ef0:	4628      	mov	r0, r5
 80a0ef2:	f7ff f8d9 	bl	80a00a8 <__cxa_guard_release>
 80a0ef6:	4806      	ldr	r0, [pc, #24]	; (80a0f10 <_Z22__fetch_global_Serial1v+0x40>)
 80a0ef8:	4906      	ldr	r1, [pc, #24]	; (80a0f14 <_Z22__fetch_global_Serial1v+0x44>)
 80a0efa:	4a07      	ldr	r2, [pc, #28]	; (80a0f18 <_Z22__fetch_global_Serial1v+0x48>)
 80a0efc:	f000 f9ca 	bl	80a1294 <__aeabi_atexit>
	return serial1;
}
 80a0f00:	4803      	ldr	r0, [pc, #12]	; (80a0f10 <_Z22__fetch_global_Serial1v+0x40>)
 80a0f02:	bd38      	pop	{r3, r4, r5, pc}
 80a0f04:	2000047c 	.word	0x2000047c
 80a0f08:	20000480 	.word	0x20000480
 80a0f0c:	200003f8 	.word	0x200003f8
 80a0f10:	200003e4 	.word	0x200003e4
 80a0f14:	080a0e3d 	.word	0x080a0e3d
 80a0f18:	20000378 	.word	0x20000378

080a0f1c <_ZN9USBSerial14blockOnOverrunEb>:
  USB_USART_Flush_Data();
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a0f1c:	7401      	strb	r1, [r0, #16]
 80a0f1e:	4770      	bx	lr

080a0f20 <_ZN9USBSerialD1Ev>:

#include "spark_wiring_stream.h"
#include "usb_hal.h"
#include "system_task.h"

class USBSerial : public Stream
 80a0f20:	4770      	bx	lr

080a0f22 <_ZN9USBSerial4readEv>:


// Read data from buffer
int USBSerial::read()
{
	return USB_USART_Receive_Data(false);
 80a0f22:	2000      	movs	r0, #0
 80a0f24:	f7ff bb14 	b.w	80a0550 <USB_USART_Receive_Data>

080a0f28 <_ZN9USBSerial4peekEv>:
  _blocking = block;
}

int USBSerial::peek()
{
	return USB_USART_Receive_Data(true);
 80a0f28:	2001      	movs	r0, #1
 80a0f2a:	f7ff bb11 	b.w	80a0550 <USB_USART_Receive_Data>

080a0f2e <_ZN9USBSerial17availableForWriteEv>:
	return USB_USART_Receive_Data(false);
}

int USBSerial::availableForWrite()
{
  return USB_USART_Available_Data_For_Write();
 80a0f2e:	f7ff bb5f 	b.w	80a05f0 <USB_USART_Available_Data_For_Write>

080a0f32 <_ZN9USBSerial9availableEv>:
}

int USBSerial::available()
{
 80a0f32:	b508      	push	{r3, lr}
	return USB_USART_Available_Data();
 80a0f34:	f7ff fb04 	bl	80a0540 <USB_USART_Available_Data>
}
 80a0f38:	bd08      	pop	{r3, pc}

080a0f3a <_ZN9USBSerial5writeEh>:

size_t USBSerial::write(uint8_t byte)
{
 80a0f3a:	b538      	push	{r3, r4, r5, lr}
 80a0f3c:	4605      	mov	r5, r0
 80a0f3e:	460c      	mov	r4, r1
  if (USB_USART_Available_Data_For_Write() > 0 || _blocking) {
 80a0f40:	f7ff fb56 	bl	80a05f0 <USB_USART_Available_Data_For_Write>
 80a0f44:	2800      	cmp	r0, #0
 80a0f46:	dc01      	bgt.n	80a0f4c <_ZN9USBSerial5writeEh+0x12>
 80a0f48:	7c28      	ldrb	r0, [r5, #16]
 80a0f4a:	b118      	cbz	r0, 80a0f54 <_ZN9USBSerial5writeEh+0x1a>
    USB_USART_Send_Data(byte);
 80a0f4c:	4620      	mov	r0, r4
 80a0f4e:	f7ff fb07 	bl	80a0560 <USB_USART_Send_Data>
    return 1;
 80a0f52:	2001      	movs	r0, #1
  }
  return 0;
}
 80a0f54:	bd38      	pop	{r3, r4, r5, pc}

080a0f56 <_ZN9USBSerial5flushEv>:

void USBSerial::flush()
{
  USB_USART_Flush_Data();
 80a0f56:	f7ff bb53 	b.w	80a0600 <USB_USART_Flush_Data>

080a0f5a <_ZN9USBSerialD0Ev>:
 80a0f5a:	b510      	push	{r4, lr}
 80a0f5c:	4604      	mov	r4, r0
 80a0f5e:	f7ff f89c 	bl	80a009a <_ZdlPv>
 80a0f62:	4620      	mov	r0, r4
 80a0f64:	bd10      	pop	{r4, pc}
	...

080a0f68 <_ZN9USBSerialC1Ev>:
 80a0f68:	2200      	movs	r2, #0
 80a0f6a:	6042      	str	r2, [r0, #4]
 80a0f6c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a0f70:	6082      	str	r2, [r0, #8]
#include "spark_wiring_usbserial.h"

//
// Constructor
//
USBSerial::USBSerial()
 80a0f72:	4a02      	ldr	r2, [pc, #8]	; (80a0f7c <_ZN9USBSerialC1Ev+0x14>)
 80a0f74:	6002      	str	r2, [r0, #0]
{
  _blocking = true;
 80a0f76:	2201      	movs	r2, #1
 80a0f78:	7402      	strb	r2, [r0, #16]
}
 80a0f7a:	4770      	bx	lr
 80a0f7c:	080a16f8 	.word	0x080a16f8

080a0f80 <_ZN9USBSerial5beginEl>:
// Public methods
//

void USBSerial::begin(long speed)
{
    USB_USART_Init((unsigned)speed);
 80a0f80:	4608      	mov	r0, r1
 80a0f82:	f7ff bad5 	b.w	80a0530 <USB_USART_Init>
	...

080a0f88 <_Z20_fetch_global_serialv>:
}

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL
USBSerial& _fetch_global_serial()
{
 80a0f88:	b510      	push	{r4, lr}
	static USBSerial _globalSerial;
 80a0f8a:	4c0a      	ldr	r4, [pc, #40]	; (80a0fb4 <_Z20_fetch_global_serialv+0x2c>)
 80a0f8c:	6823      	ldr	r3, [r4, #0]
 80a0f8e:	07db      	lsls	r3, r3, #31
 80a0f90:	d40e      	bmi.n	80a0fb0 <_Z20_fetch_global_serialv+0x28>
 80a0f92:	4620      	mov	r0, r4
 80a0f94:	f7ff f883 	bl	80a009e <__cxa_guard_acquire>
 80a0f98:	b150      	cbz	r0, 80a0fb0 <_Z20_fetch_global_serialv+0x28>
 80a0f9a:	4807      	ldr	r0, [pc, #28]	; (80a0fb8 <_Z20_fetch_global_serialv+0x30>)
 80a0f9c:	f7ff ffe4 	bl	80a0f68 <_ZN9USBSerialC1Ev>
 80a0fa0:	4620      	mov	r0, r4
 80a0fa2:	f7ff f881 	bl	80a00a8 <__cxa_guard_release>
 80a0fa6:	4804      	ldr	r0, [pc, #16]	; (80a0fb8 <_Z20_fetch_global_serialv+0x30>)
 80a0fa8:	4904      	ldr	r1, [pc, #16]	; (80a0fbc <_Z20_fetch_global_serialv+0x34>)
 80a0faa:	4a05      	ldr	r2, [pc, #20]	; (80a0fc0 <_Z20_fetch_global_serialv+0x38>)
 80a0fac:	f000 f972 	bl	80a1294 <__aeabi_atexit>
	return _globalSerial;
}
 80a0fb0:	4801      	ldr	r0, [pc, #4]	; (80a0fb8 <_Z20_fetch_global_serialv+0x30>)
 80a0fb2:	bd10      	pop	{r4, pc}
 80a0fb4:	20000518 	.word	0x20000518
 80a0fb8:	20000504 	.word	0x20000504
 80a0fbc:	080a0f21 	.word	0x080a0f21
 80a0fc0:	20000378 	.word	0x20000378

080a0fc4 <_ZN5spark9WiFiClassD1Ev>:
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
    ~WiFiClass() {}
 80a0fc4:	4770      	bx	lr

080a0fc6 <_ZN5spark9WiFiClass5readyEv>:
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
 80a0fc6:	2000      	movs	r0, #0
 80a0fc8:	4601      	mov	r1, r0
 80a0fca:	4602      	mov	r2, r0
 80a0fcc:	f7ff bb40 	b.w	80a0650 <network_ready>

080a0fd0 <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj>:
    void setIPAddressSource(IPAddressSource source) {
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
 80a0fd0:	4803      	ldr	r0, [pc, #12]	; (80a0fe0 <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x10>)
 80a0fd2:	4b04      	ldr	r3, [pc, #16]	; (80a0fe4 <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x14>)
one second timeout is reached). If the aforementioned "bug" is ever fixed by
TI, no changes need to be made to this function, as it would be implemented
the same way.
*****************************************************************************/

    WiFiClass WiFi;
 80a0fd4:	4904      	ldr	r1, [pc, #16]	; (80a0fe8 <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x18>)
 80a0fd6:	4a05      	ldr	r2, [pc, #20]	; (80a0fec <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x1c>)
 80a0fd8:	6003      	str	r3, [r0, #0]
 80a0fda:	f000 b95b 	b.w	80a1294 <__aeabi_atexit>
 80a0fde:	bf00      	nop
 80a0fe0:	2000051c 	.word	0x2000051c
 80a0fe4:	080a1728 	.word	0x080a1728
 80a0fe8:	080a0fc5 	.word	0x080a0fc5
 80a0fec:	20000378 	.word	0x20000378

080a0ff0 <serialEventRun>:

/**
 * Provides background processing of serial data.
 */
void serialEventRun()
{
 80a0ff0:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
 80a0ff2:	4b0f      	ldr	r3, [pc, #60]	; (80a1030 <serialEventRun+0x40>)
 80a0ff4:	b133      	cbz	r3, 80a1004 <serialEventRun+0x14>
 80a0ff6:	f7ff ffc7 	bl	80a0f88 <_Z20_fetch_global_serialv>
 80a0ffa:	6803      	ldr	r3, [r0, #0]
 80a0ffc:	691b      	ldr	r3, [r3, #16]
 80a0ffe:	4798      	blx	r3
 80a1000:	2800      	cmp	r0, #0
 80a1002:	dc0d      	bgt.n	80a1020 <serialEventRun+0x30>
        serialEvent();

    if (serialEvent1 && Serial1.available()>0)
 80a1004:	4b0b      	ldr	r3, [pc, #44]	; (80a1034 <serialEventRun+0x44>)
 80a1006:	b133      	cbz	r3, 80a1016 <serialEventRun+0x26>
 80a1008:	f7ff ff62 	bl	80a0ed0 <_Z22__fetch_global_Serial1v>
 80a100c:	6803      	ldr	r3, [r0, #0]
 80a100e:	691b      	ldr	r3, [r3, #16]
 80a1010:	4798      	blx	r3
 80a1012:	2800      	cmp	r0, #0
 80a1014:	dc07      	bgt.n	80a1026 <serialEventRun+0x36>
        serialEvent1();

#if Wiring_Serial2
    if (serialEventRun2) serialEventRun2();
 80a1016:	4b08      	ldr	r3, [pc, #32]	; (80a1038 <serialEventRun+0x48>)
 80a1018:	b143      	cbz	r3, 80a102c <serialEventRun+0x3c>
 80a101a:	f3af 8000 	nop.w
 80a101e:	bd08      	pop	{r3, pc}
 * Provides background processing of serial data.
 */
void serialEventRun()
{
    if (serialEvent && Serial.available()>0)
        serialEvent();
 80a1020:	f3af 8000 	nop.w
 80a1024:	e7ee      	b.n	80a1004 <serialEventRun+0x14>

    if (serialEvent1 && Serial1.available()>0)
        serialEvent1();
 80a1026:	f3af 8000 	nop.w
 80a102a:	e7f4      	b.n	80a1016 <serialEventRun+0x26>
 80a102c:	bd08      	pop	{r3, pc}
 80a102e:	bf00      	nop
	...

080a103c <_post_loop>:
#if Wiring_Serial5
void serialEvent5() __attribute__((weak));
#endif

void _post_loop()
{
 80a103c:	b508      	push	{r3, lr}
	serialEventRun();
 80a103e:	f7ff ffd7 	bl	80a0ff0 <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a1042:	f7ff f9f3 	bl	80a042c <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a1046:	4b01      	ldr	r3, [pc, #4]	; (80a104c <_post_loop+0x10>)
 80a1048:	6018      	str	r0, [r3, #0]
 80a104a:	bd08      	pop	{r3, pc}
 80a104c:	20000528 	.word	0x20000528

080a1050 <_Z33system_initialize_user_backup_ramv>:
 * the dynamically linked application module.
 */
void system_initialize_user_backup_ram()
{
    size_t len = &link_global_retained_end-&link_global_retained_start;
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a1050:	4802      	ldr	r0, [pc, #8]	; (80a105c <_Z33system_initialize_user_backup_ramv+0xc>)
 80a1052:	4a03      	ldr	r2, [pc, #12]	; (80a1060 <_Z33system_initialize_user_backup_ramv+0x10>)
 80a1054:	4903      	ldr	r1, [pc, #12]	; (80a1064 <_Z33system_initialize_user_backup_ramv+0x14>)
 80a1056:	1a12      	subs	r2, r2, r0
 80a1058:	f000 ba02 	b.w	80a1460 <memcpy>
 80a105c:	40024000 	.word	0x40024000
 80a1060:	40024004 	.word	0x40024004
 80a1064:	080a1890 	.word	0x080a1890

080a1068 <module_user_init_hook>:

#endif


void module_user_init_hook()
{
 80a1068:	b538      	push	{r3, r4, r5, lr}
#if PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ =  __backup_sram_signature==signature;
 80a106a:	4c09      	ldr	r4, [pc, #36]	; (80a1090 <module_user_init_hook+0x28>)
 80a106c:	4d09      	ldr	r5, [pc, #36]	; (80a1094 <module_user_init_hook+0x2c>)
 80a106e:	6823      	ldr	r3, [r4, #0]
 80a1070:	1b5a      	subs	r2, r3, r5
 80a1072:	4253      	negs	r3, r2
 80a1074:	4153      	adcs	r3, r2
 80a1076:	4a08      	ldr	r2, [pc, #32]	; (80a1098 <module_user_init_hook+0x30>)
 80a1078:	7013      	strb	r3, [r2, #0]
    if (!backup_ram_was_valid_) {
 80a107a:	b913      	cbnz	r3, 80a1082 <module_user_init_hook+0x1a>
        system_initialize_user_backup_ram();
 80a107c:	f7ff ffe8 	bl	80a1050 <_Z33system_initialize_user_backup_ramv>
        __backup_sram_signature = signature;
 80a1080:	6025      	str	r5, [r4, #0]
    /* for dynamically linked user part, set the random seed if the user
     * app defines random_seed_from_cloud.
     */
// todo - add a RNG define for that capability
#if defined(STM32F2XX)
    if (random_seed_from_cloud) {
 80a1082:	4b06      	ldr	r3, [pc, #24]	; (80a109c <module_user_init_hook+0x34>)
 80a1084:	b11b      	cbz	r3, 80a108e <module_user_init_hook+0x26>
    		uint32_t seed = HAL_RNG_GetRandomNumber();
 80a1086:	f7ff f9c9 	bl	80a041c <HAL_RNG_GetRandomNumber>
    		random_seed_from_cloud(seed);
 80a108a:	f3af 8000 	nop.w
 80a108e:	bd38      	pop	{r3, r4, r5, pc}
 80a1090:	40024000 	.word	0x40024000
 80a1094:	9a271c1e 	.word	0x9a271c1e
 80a1098:	20000520 	.word	0x20000520
 80a109c:	00000000 	.word	0x00000000

080a10a0 <pinAvailable>:

/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
 80a10a0:	b510      	push	{r4, lr}
 80a10a2:	4604      	mov	r4, r0

  // SPI safety check
#ifndef SPARK_WIRING_NO_SPI
  if(SPI.isEnabled() == true && (pin == SCK || pin == MOSI || pin == MISO))
 80a10a4:	480f      	ldr	r0, [pc, #60]	; (80a10e4 <pinAvailable+0x44>)
 80a10a6:	f7ff fccb 	bl	80a0a40 <_ZN8SPIClass9isEnabledEv>
 80a10aa:	b128      	cbz	r0, 80a10b8 <pinAvailable+0x18>
 80a10ac:	f1a4 030d 	sub.w	r3, r4, #13
 80a10b0:	2b02      	cmp	r3, #2
 80a10b2:	d801      	bhi.n	80a10b8 <pinAvailable+0x18>
  {
    return 0; // 'pin' is used
 80a10b4:	2000      	movs	r0, #0
 80a10b6:	bd10      	pop	{r4, pc}
  }
#endif
  // I2C safety check
#ifndef SPARK_WIRING_NO_I2C
  if(Wire.isEnabled() == true && (pin == SCL || pin == SDA))
 80a10b8:	f000 f87c 	bl	80a11b4 <_Z19__fetch_global_Wirev>
 80a10bc:	f7ff fbb4 	bl	80a0828 <_ZN7TwoWire9isEnabledEv>
 80a10c0:	b108      	cbz	r0, 80a10c6 <pinAvailable+0x26>
 80a10c2:	2c01      	cmp	r4, #1
 80a10c4:	d9f6      	bls.n	80a10b4 <pinAvailable+0x14>
    return 0; // 'pin' is used
  }
#endif
#ifndef SPARK_WIRING_NO_USART_SERIAL
  // Serial1 safety check
  if(Serial1.isEnabled() == true && (pin == RX || pin == TX))
 80a10c6:	f7ff ff03 	bl	80a0ed0 <_Z22__fetch_global_Serial1v>
 80a10ca:	f7ff fefe 	bl	80a0eca <_ZN11USARTSerial9isEnabledEv>
 80a10ce:	b118      	cbz	r0, 80a10d8 <pinAvailable+0x38>
 80a10d0:	f1a4 0312 	sub.w	r3, r4, #18
 80a10d4:	2b01      	cmp	r3, #1
 80a10d6:	d9ed      	bls.n	80a10b4 <pinAvailable+0x14>
  {
    return 0; // 'pin' is used
  }
#endif

  if (pin >= TOTAL_PINS)
 80a10d8:	2c17      	cmp	r4, #23
 80a10da:	bf8c      	ite	hi
 80a10dc:	2000      	movhi	r0, #0
 80a10de:	2001      	movls	r0, #1
    return 0;
  else
    return 1; // 'pin' is available
}
 80a10e0:	bd10      	pop	{r4, pc}
 80a10e2:	bf00      	nop
 80a10e4:	2000056c 	.word	0x2000056c

080a10e8 <pinMode>:
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a10e8:	2817      	cmp	r0, #23
/*
 * @brief Set the mode of the pin to OUTPUT, INPUT, INPUT_PULLUP,
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{
 80a10ea:	b538      	push	{r3, r4, r5, lr}
 80a10ec:	4605      	mov	r5, r0
 80a10ee:	460c      	mov	r4, r1

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a10f0:	d80a      	bhi.n	80a1108 <pinMode+0x20>
 80a10f2:	29ff      	cmp	r1, #255	; 0xff
 80a10f4:	d008      	beq.n	80a1108 <pinMode+0x20>
  {
    return;
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a10f6:	f7ff ffd3 	bl	80a10a0 <pinAvailable>
 80a10fa:	b128      	cbz	r0, 80a1108 <pinMode+0x20>
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a10fc:	4628      	mov	r0, r5
 80a10fe:	4621      	mov	r1, r4
}
 80a1100:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a1104:	f7ff b9aa 	b.w	80a045c <HAL_Pin_Mode>
 80a1108:	bd38      	pop	{r3, r4, r5, pc}

080a110a <_Z11analogWritett>:
/*
 * @brief Should take an integer 0-255 and create a 500Hz PWM signal with a duty cycle from 0-100%.
 * On Photon, DAC1 and DAC2 act as true analog outputs(values: 0 to 4095) using onchip DAC peripheral
 */
void analogWrite(pin_t pin, uint16_t value)
{
 80a110a:	b538      	push	{r3, r4, r5, lr}
 80a110c:	4604      	mov	r4, r0
 80a110e:	460d      	mov	r5, r1
    // Safety check
    if (!pinAvailable(pin))
 80a1110:	f7ff ffc6 	bl	80a10a0 <pinAvailable>
 80a1114:	b1e8      	cbz	r0, 80a1152 <_Z11analogWritett+0x48>
    {
        return;
    }

    if (HAL_Validate_Pin_Function(pin, PF_DAC) == PF_DAC)
 80a1116:	4620      	mov	r0, r4
 80a1118:	2104      	movs	r1, #4
 80a111a:	f7ff f997 	bl	80a044c <HAL_Validate_Pin_Function>
 80a111e:	2804      	cmp	r0, #4
    {
        HAL_DAC_Write(pin, value);
 80a1120:	4620      	mov	r0, r4
    if (!pinAvailable(pin))
    {
        return;
    }

    if (HAL_Validate_Pin_Function(pin, PF_DAC) == PF_DAC)
 80a1122:	d104      	bne.n	80a112e <_Z11analogWritett+0x24>
    {
        HAL_DAC_Write(pin, value);
 80a1124:	4629      	mov	r1, r5
            return;
        }

        HAL_PWM_Write(pin, value);
    }
}
 80a1126:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        return;
    }

    if (HAL_Validate_Pin_Function(pin, PF_DAC) == PF_DAC)
    {
        HAL_DAC_Write(pin, value);
 80a112a:	f7ff b9a7 	b.w	80a047c <HAL_DAC_Write>
    }
    else if (HAL_Validate_Pin_Function(pin, PF_TIMER) == PF_TIMER)
 80a112e:	2102      	movs	r1, #2
 80a1130:	f7ff f98c 	bl	80a044c <HAL_Validate_Pin_Function>
 80a1134:	2802      	cmp	r0, #2
 80a1136:	d10c      	bne.n	80a1152 <_Z11analogWritett+0x48>
    {
        PinMode mode = HAL_Get_Pin_Mode(pin);
 80a1138:	4620      	mov	r0, r4
 80a113a:	f7ff f997 	bl	80a046c <HAL_Get_Pin_Mode>

        if (mode != OUTPUT && mode != AF_OUTPUT_PUSHPULL)
 80a113e:	2801      	cmp	r0, #1
 80a1140:	d001      	beq.n	80a1146 <_Z11analogWritett+0x3c>
 80a1142:	2804      	cmp	r0, #4
 80a1144:	d105      	bne.n	80a1152 <_Z11analogWritett+0x48>
        {
            return;
        }

        HAL_PWM_Write(pin, value);
 80a1146:	4620      	mov	r0, r4
 80a1148:	b2e9      	uxtb	r1, r5
    }
}
 80a114a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        if (mode != OUTPUT && mode != AF_OUTPUT_PUSHPULL)
        {
            return;
        }

        HAL_PWM_Write(pin, value);
 80a114e:	f7ff b99d 	b.w	80a048c <HAL_PWM_Write>
 80a1152:	bd38      	pop	{r3, r4, r5, pc}

080a1154 <_GLOBAL__sub_I_pinMode>:
{
public:
    typedef uint8_t flag_t;
    inline SleepNetworkFlag(SystemSleepNetwork f) : SleepNetworkFlag(static_cast<flag_t>(f)) {}

    inline SleepNetworkFlag(flag_t flag) : flag_(flag) {}
 80a1154:	4b06      	ldr	r3, [pc, #24]	; (80a1170 <_GLOBAL__sub_I_pinMode+0x1c>)
 80a1156:	2200      	movs	r2, #0
 80a1158:	4906      	ldr	r1, [pc, #24]	; (80a1174 <_GLOBAL__sub_I_pinMode+0x20>)
 80a115a:	701a      	strb	r2, [r3, #0]
 80a115c:	2301      	movs	r3, #1
 80a115e:	700b      	strb	r3, [r1, #0]

class PublishFlag
{
public:
	typedef uint8_t flag_t;
	PublishFlag(flag_t flag) : flag_(flag) {}
 80a1160:	4905      	ldr	r1, [pc, #20]	; (80a1178 <_GLOBAL__sub_I_pinMode+0x24>)
 80a1162:	700a      	strb	r2, [r1, #0]
 80a1164:	4a05      	ldr	r2, [pc, #20]	; (80a117c <_GLOBAL__sub_I_pinMode+0x28>)
 80a1166:	7013      	strb	r3, [r2, #0]
 80a1168:	4b05      	ldr	r3, [pc, #20]	; (80a1180 <_GLOBAL__sub_I_pinMode+0x2c>)
 80a116a:	2202      	movs	r2, #2
 80a116c:	701a      	strb	r2, [r3, #0]
 80a116e:	4770      	bx	lr
 80a1170:	20000524 	.word	0x20000524
 80a1174:	20000525 	.word	0x20000525
 80a1178:	20000522 	.word	0x20000522
 80a117c:	20000523 	.word	0x20000523
 80a1180:	20000521 	.word	0x20000521

080a1184 <_GLOBAL__sub_I_Particle>:
 80a1184:	4b06      	ldr	r3, [pc, #24]	; (80a11a0 <_GLOBAL__sub_I_Particle+0x1c>)
 80a1186:	2200      	movs	r2, #0
 80a1188:	4906      	ldr	r1, [pc, #24]	; (80a11a4 <_GLOBAL__sub_I_Particle+0x20>)
 80a118a:	701a      	strb	r2, [r3, #0]
 80a118c:	2301      	movs	r3, #1
 80a118e:	700b      	strb	r3, [r1, #0]
 80a1190:	4905      	ldr	r1, [pc, #20]	; (80a11a8 <_GLOBAL__sub_I_Particle+0x24>)
 80a1192:	700a      	strb	r2, [r1, #0]
 80a1194:	4a05      	ldr	r2, [pc, #20]	; (80a11ac <_GLOBAL__sub_I_Particle+0x28>)
 80a1196:	7013      	strb	r3, [r2, #0]
 80a1198:	4b05      	ldr	r3, [pc, #20]	; (80a11b0 <_GLOBAL__sub_I_Particle+0x2c>)
 80a119a:	2202      	movs	r2, #2
 80a119c:	701a      	strb	r2, [r3, #0]
 80a119e:	4770      	bx	lr
 80a11a0:	2000052f 	.word	0x2000052f
 80a11a4:	20000530 	.word	0x20000530
 80a11a8:	2000052d 	.word	0x2000052d
 80a11ac:	2000052e 	.word	0x2000052e
 80a11b0:	2000052c 	.word	0x2000052c

080a11b4 <_Z19__fetch_global_Wirev>:
#include "i2c_hal.h"

#ifndef SPARK_WIRING_NO_I2C

TwoWire& __fetch_global_Wire()
{
 80a11b4:	b538      	push	{r3, r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1);
 80a11b6:	4d0b      	ldr	r5, [pc, #44]	; (80a11e4 <_Z19__fetch_global_Wirev+0x30>)
 80a11b8:	6829      	ldr	r1, [r5, #0]
 80a11ba:	f011 0401 	ands.w	r4, r1, #1
 80a11be:	d10f      	bne.n	80a11e0 <_Z19__fetch_global_Wirev+0x2c>
 80a11c0:	4628      	mov	r0, r5
 80a11c2:	f7fe ff6c 	bl	80a009e <__cxa_guard_acquire>
 80a11c6:	b158      	cbz	r0, 80a11e0 <_Z19__fetch_global_Wirev+0x2c>
 80a11c8:	4621      	mov	r1, r4
 80a11ca:	4807      	ldr	r0, [pc, #28]	; (80a11e8 <_Z19__fetch_global_Wirev+0x34>)
 80a11cc:	f7ff fb1a 	bl	80a0804 <_ZN7TwoWireC1E17HAL_I2C_Interface>
 80a11d0:	4628      	mov	r0, r5
 80a11d2:	f7fe ff69 	bl	80a00a8 <__cxa_guard_release>
 80a11d6:	4804      	ldr	r0, [pc, #16]	; (80a11e8 <_Z19__fetch_global_Wirev+0x34>)
 80a11d8:	4904      	ldr	r1, [pc, #16]	; (80a11ec <_Z19__fetch_global_Wirev+0x38>)
 80a11da:	4a05      	ldr	r2, [pc, #20]	; (80a11f0 <_Z19__fetch_global_Wirev+0x3c>)
 80a11dc:	f000 f85a 	bl	80a1294 <__aeabi_atexit>
	return wire;
}
 80a11e0:	4801      	ldr	r0, [pc, #4]	; (80a11e8 <_Z19__fetch_global_Wirev+0x34>)
 80a11e2:	bd38      	pop	{r3, r4, r5, pc}
 80a11e4:	20000534 	.word	0x20000534
 80a11e8:	20000538 	.word	0x20000538
 80a11ec:	080a07ad 	.word	0x080a07ad
 80a11f0:	20000378 	.word	0x20000378

080a11f4 <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a11f4:	b513      	push	{r0, r1, r4, lr}
 80a11f6:	4c08      	ldr	r4, [pc, #32]	; (80a1218 <_GLOBAL__sub_I_INADDR_NONE+0x24>)
 80a11f8:	2100      	movs	r1, #0
 80a11fa:	9100      	str	r1, [sp, #0]
 80a11fc:	460a      	mov	r2, r1
 80a11fe:	460b      	mov	r3, r1
 80a1200:	4620      	mov	r0, r4
 80a1202:	f7ff fb5b 	bl	80a08bc <_ZN9IPAddressC1Ehhhh>
 80a1206:	4620      	mov	r0, r4
 80a1208:	4904      	ldr	r1, [pc, #16]	; (80a121c <_GLOBAL__sub_I_INADDR_NONE+0x28>)
 80a120a:	4a05      	ldr	r2, [pc, #20]	; (80a1220 <_GLOBAL__sub_I_INADDR_NONE+0x2c>)
 80a120c:	b002      	add	sp, #8
 80a120e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a1212:	f000 b83f 	b.w	80a1294 <__aeabi_atexit>
 80a1216:	bf00      	nop
 80a1218:	2000054c 	.word	0x2000054c
 80a121c:	080a0861 	.word	0x080a0861
 80a1220:	20000378 	.word	0x20000378

080a1224 <_GLOBAL__sub_I_SPI>:
#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a1224:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1226:	4b12      	ldr	r3, [pc, #72]	; (80a1270 <_GLOBAL__sub_I_SPI+0x4c>)
 80a1228:	2100      	movs	r1, #0
 80a122a:	7019      	strb	r1, [r3, #0]
 80a122c:	4b11      	ldr	r3, [pc, #68]	; (80a1274 <_GLOBAL__sub_I_SPI+0x50>)
 80a122e:	2401      	movs	r4, #1
 80a1230:	701c      	strb	r4, [r3, #0]
 80a1232:	4b11      	ldr	r3, [pc, #68]	; (80a1278 <_GLOBAL__sub_I_SPI+0x54>)
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a1234:	4f11      	ldr	r7, [pc, #68]	; (80a127c <_GLOBAL__sub_I_SPI+0x58>)
 80a1236:	7019      	strb	r1, [r3, #0]
 80a1238:	4b11      	ldr	r3, [pc, #68]	; (80a1280 <_GLOBAL__sub_I_SPI+0x5c>)
 80a123a:	2202      	movs	r2, #2
 80a123c:	701c      	strb	r4, [r3, #0]
 80a123e:	4b11      	ldr	r3, [pc, #68]	; (80a1284 <_GLOBAL__sub_I_SPI+0x60>)
 80a1240:	4e11      	ldr	r6, [pc, #68]	; (80a1288 <_GLOBAL__sub_I_SPI+0x64>)
 80a1242:	4d12      	ldr	r5, [pc, #72]	; (80a128c <_GLOBAL__sub_I_SPI+0x68>)
 80a1244:	4638      	mov	r0, r7
 80a1246:	701a      	strb	r2, [r3, #0]
 80a1248:	f7ff fbec 	bl	80a0a24 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a124c:	4638      	mov	r0, r7

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a124e:	4f10      	ldr	r7, [pc, #64]	; (80a1290 <_GLOBAL__sub_I_SPI+0x6c>)
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a1250:	462a      	mov	r2, r5
 80a1252:	4631      	mov	r1, r6
 80a1254:	f000 f81e 	bl	80a1294 <__aeabi_atexit>

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a1258:	4621      	mov	r1, r4
 80a125a:	4638      	mov	r0, r7
 80a125c:	f7ff fbe2 	bl	80a0a24 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a1260:	4638      	mov	r0, r7
 80a1262:	4631      	mov	r1, r6
 80a1264:	462a      	mov	r2, r5
 80a1266:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 80a126a:	f000 b813 	b.w	80a1294 <__aeabi_atexit>
 80a126e:	bf00      	nop
 80a1270:	20000567 	.word	0x20000567
 80a1274:	20000568 	.word	0x20000568
 80a1278:	20000565 	.word	0x20000565
 80a127c:	2000056c 	.word	0x2000056c
 80a1280:	20000566 	.word	0x20000566
 80a1284:	20000564 	.word	0x20000564
 80a1288:	080a0a15 	.word	0x080a0a15
 80a128c:	20000378 	.word	0x20000378
 80a1290:	20000578 	.word	0x20000578

080a1294 <__aeabi_atexit>:
 80a1294:	4603      	mov	r3, r0
 80a1296:	4608      	mov	r0, r1
 80a1298:	4619      	mov	r1, r3
 80a129a:	f000 b8c9 	b.w	80a1430 <__cxa_atexit>
	...

080a12a0 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE>:
 80a12a0:	4b24      	ldr	r3, [pc, #144]	; (80a1334 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x94>)
 80a12a2:	681a      	ldr	r2, [r3, #0]
 80a12a4:	07d0      	lsls	r0, r2, #31
 80a12a6:	bf5c      	itt	pl
 80a12a8:	2201      	movpl	r2, #1
 80a12aa:	601a      	strpl	r2, [r3, #0]
 80a12ac:	4b22      	ldr	r3, [pc, #136]	; (80a1338 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x98>)
 80a12ae:	681a      	ldr	r2, [r3, #0]
 80a12b0:	07d1      	lsls	r1, r2, #31
 80a12b2:	bf5c      	itt	pl
 80a12b4:	2201      	movpl	r2, #1
 80a12b6:	601a      	strpl	r2, [r3, #0]
 80a12b8:	4b20      	ldr	r3, [pc, #128]	; (80a133c <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x9c>)
 80a12ba:	681a      	ldr	r2, [r3, #0]
 80a12bc:	07d2      	lsls	r2, r2, #31
 80a12be:	bf5c      	itt	pl
 80a12c0:	2201      	movpl	r2, #1
 80a12c2:	601a      	strpl	r2, [r3, #0]
 80a12c4:	4b1e      	ldr	r3, [pc, #120]	; (80a1340 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xa0>)
 80a12c6:	681a      	ldr	r2, [r3, #0]
 80a12c8:	07d0      	lsls	r0, r2, #31
 80a12ca:	bf5c      	itt	pl
 80a12cc:	2201      	movpl	r2, #1
 80a12ce:	601a      	strpl	r2, [r3, #0]
 80a12d0:	4b1c      	ldr	r3, [pc, #112]	; (80a1344 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xa4>)
 80a12d2:	681a      	ldr	r2, [r3, #0]
 80a12d4:	07d1      	lsls	r1, r2, #31
 80a12d6:	bf5c      	itt	pl
 80a12d8:	2201      	movpl	r2, #1
 80a12da:	601a      	strpl	r2, [r3, #0]
 80a12dc:	4b1a      	ldr	r3, [pc, #104]	; (80a1348 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xa8>)
 80a12de:	681a      	ldr	r2, [r3, #0]
 80a12e0:	07d2      	lsls	r2, r2, #31
 80a12e2:	bf5c      	itt	pl
 80a12e4:	2201      	movpl	r2, #1
 80a12e6:	601a      	strpl	r2, [r3, #0]
 80a12e8:	4b18      	ldr	r3, [pc, #96]	; (80a134c <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xac>)
 80a12ea:	681a      	ldr	r2, [r3, #0]
 80a12ec:	07d0      	lsls	r0, r2, #31
 80a12ee:	bf5c      	itt	pl
 80a12f0:	2201      	movpl	r2, #1
 80a12f2:	601a      	strpl	r2, [r3, #0]
 80a12f4:	4b16      	ldr	r3, [pc, #88]	; (80a1350 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xb0>)
 80a12f6:	681a      	ldr	r2, [r3, #0]
 80a12f8:	07d1      	lsls	r1, r2, #31
 80a12fa:	bf5c      	itt	pl
 80a12fc:	2201      	movpl	r2, #1
 80a12fe:	601a      	strpl	r2, [r3, #0]
 80a1300:	4b14      	ldr	r3, [pc, #80]	; (80a1354 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xb4>)
 80a1302:	681a      	ldr	r2, [r3, #0]
 80a1304:	07d2      	lsls	r2, r2, #31
 80a1306:	bf5c      	itt	pl
 80a1308:	2201      	movpl	r2, #1
 80a130a:	601a      	strpl	r2, [r3, #0]
 80a130c:	4b12      	ldr	r3, [pc, #72]	; (80a1358 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xb8>)
 80a130e:	681a      	ldr	r2, [r3, #0]
 80a1310:	07d0      	lsls	r0, r2, #31
 80a1312:	bf5c      	itt	pl
 80a1314:	2201      	movpl	r2, #1
 80a1316:	601a      	strpl	r2, [r3, #0]
 80a1318:	4b10      	ldr	r3, [pc, #64]	; (80a135c <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xbc>)
 80a131a:	681a      	ldr	r2, [r3, #0]
 80a131c:	07d1      	lsls	r1, r2, #31
 80a131e:	bf5c      	itt	pl
 80a1320:	2201      	movpl	r2, #1
 80a1322:	601a      	strpl	r2, [r3, #0]
 80a1324:	4b0e      	ldr	r3, [pc, #56]	; (80a1360 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xc0>)
 80a1326:	681a      	ldr	r2, [r3, #0]
 80a1328:	07d2      	lsls	r2, r2, #31
 80a132a:	bf5c      	itt	pl
 80a132c:	2201      	movpl	r2, #1
 80a132e:	601a      	strpl	r2, [r3, #0]
 80a1330:	4770      	bx	lr
 80a1332:	bf00      	nop
 80a1334:	200005b0 	.word	0x200005b0
 80a1338:	200005ac 	.word	0x200005ac
 80a133c:	200005a8 	.word	0x200005a8
 80a1340:	200005a4 	.word	0x200005a4
 80a1344:	200005a0 	.word	0x200005a0
 80a1348:	2000059c 	.word	0x2000059c
 80a134c:	20000598 	.word	0x20000598
 80a1350:	20000594 	.word	0x20000594
 80a1354:	20000590 	.word	0x20000590
 80a1358:	2000058c 	.word	0x2000058c
 80a135c:	20000588 	.word	0x20000588
 80a1360:	20000584 	.word	0x20000584

080a1364 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE>:
 80a1364:	4b24      	ldr	r3, [pc, #144]	; (80a13f8 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x94>)
 80a1366:	681a      	ldr	r2, [r3, #0]
 80a1368:	07d0      	lsls	r0, r2, #31
 80a136a:	bf5c      	itt	pl
 80a136c:	2201      	movpl	r2, #1
 80a136e:	601a      	strpl	r2, [r3, #0]
 80a1370:	4b22      	ldr	r3, [pc, #136]	; (80a13fc <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x98>)
 80a1372:	681a      	ldr	r2, [r3, #0]
 80a1374:	07d1      	lsls	r1, r2, #31
 80a1376:	bf5c      	itt	pl
 80a1378:	2201      	movpl	r2, #1
 80a137a:	601a      	strpl	r2, [r3, #0]
 80a137c:	4b20      	ldr	r3, [pc, #128]	; (80a1400 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x9c>)
 80a137e:	681a      	ldr	r2, [r3, #0]
 80a1380:	07d2      	lsls	r2, r2, #31
 80a1382:	bf5c      	itt	pl
 80a1384:	2201      	movpl	r2, #1
 80a1386:	601a      	strpl	r2, [r3, #0]
 80a1388:	4b1e      	ldr	r3, [pc, #120]	; (80a1404 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xa0>)
 80a138a:	681a      	ldr	r2, [r3, #0]
 80a138c:	07d0      	lsls	r0, r2, #31
 80a138e:	bf5c      	itt	pl
 80a1390:	2201      	movpl	r2, #1
 80a1392:	601a      	strpl	r2, [r3, #0]
 80a1394:	4b1c      	ldr	r3, [pc, #112]	; (80a1408 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xa4>)
 80a1396:	681a      	ldr	r2, [r3, #0]
 80a1398:	07d1      	lsls	r1, r2, #31
 80a139a:	bf5c      	itt	pl
 80a139c:	2201      	movpl	r2, #1
 80a139e:	601a      	strpl	r2, [r3, #0]
 80a13a0:	4b1a      	ldr	r3, [pc, #104]	; (80a140c <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xa8>)
 80a13a2:	681a      	ldr	r2, [r3, #0]
 80a13a4:	07d2      	lsls	r2, r2, #31
 80a13a6:	bf5c      	itt	pl
 80a13a8:	2201      	movpl	r2, #1
 80a13aa:	601a      	strpl	r2, [r3, #0]
 80a13ac:	4b18      	ldr	r3, [pc, #96]	; (80a1410 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xac>)
 80a13ae:	681a      	ldr	r2, [r3, #0]
 80a13b0:	07d0      	lsls	r0, r2, #31
 80a13b2:	bf5c      	itt	pl
 80a13b4:	2201      	movpl	r2, #1
 80a13b6:	601a      	strpl	r2, [r3, #0]
 80a13b8:	4b16      	ldr	r3, [pc, #88]	; (80a1414 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xb0>)
 80a13ba:	681a      	ldr	r2, [r3, #0]
 80a13bc:	07d1      	lsls	r1, r2, #31
 80a13be:	bf5c      	itt	pl
 80a13c0:	2201      	movpl	r2, #1
 80a13c2:	601a      	strpl	r2, [r3, #0]
 80a13c4:	4b14      	ldr	r3, [pc, #80]	; (80a1418 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xb4>)
 80a13c6:	681a      	ldr	r2, [r3, #0]
 80a13c8:	07d2      	lsls	r2, r2, #31
 80a13ca:	bf5c      	itt	pl
 80a13cc:	2201      	movpl	r2, #1
 80a13ce:	601a      	strpl	r2, [r3, #0]
 80a13d0:	4b12      	ldr	r3, [pc, #72]	; (80a141c <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xb8>)
 80a13d2:	681a      	ldr	r2, [r3, #0]
 80a13d4:	07d0      	lsls	r0, r2, #31
 80a13d6:	bf5c      	itt	pl
 80a13d8:	2201      	movpl	r2, #1
 80a13da:	601a      	strpl	r2, [r3, #0]
 80a13dc:	4b10      	ldr	r3, [pc, #64]	; (80a1420 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xbc>)
 80a13de:	681a      	ldr	r2, [r3, #0]
 80a13e0:	07d1      	lsls	r1, r2, #31
 80a13e2:	bf5c      	itt	pl
 80a13e4:	2201      	movpl	r2, #1
 80a13e6:	601a      	strpl	r2, [r3, #0]
 80a13e8:	4b0e      	ldr	r3, [pc, #56]	; (80a1424 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xc0>)
 80a13ea:	681a      	ldr	r2, [r3, #0]
 80a13ec:	07d2      	lsls	r2, r2, #31
 80a13ee:	bf5c      	itt	pl
 80a13f0:	2201      	movpl	r2, #1
 80a13f2:	601a      	strpl	r2, [r3, #0]
 80a13f4:	4770      	bx	lr
 80a13f6:	bf00      	nop
 80a13f8:	200005e0 	.word	0x200005e0
 80a13fc:	200005dc 	.word	0x200005dc
 80a1400:	200005d8 	.word	0x200005d8
 80a1404:	200005d4 	.word	0x200005d4
 80a1408:	200005d0 	.word	0x200005d0
 80a140c:	200005cc 	.word	0x200005cc
 80a1410:	200005c8 	.word	0x200005c8
 80a1414:	200005c4 	.word	0x200005c4
 80a1418:	200005c0 	.word	0x200005c0
 80a141c:	200005bc 	.word	0x200005bc
 80a1420:	200005b8 	.word	0x200005b8
 80a1424:	200005b4 	.word	0x200005b4

080a1428 <atol>:
 80a1428:	2100      	movs	r1, #0
 80a142a:	220a      	movs	r2, #10
 80a142c:	f000 b8e4 	b.w	80a15f8 <strtol>

080a1430 <__cxa_atexit>:
 80a1430:	b538      	push	{r3, r4, r5, lr}
 80a1432:	4605      	mov	r5, r0
 80a1434:	4804      	ldr	r0, [pc, #16]	; (80a1448 <__cxa_atexit+0x18>)
 80a1436:	460c      	mov	r4, r1
 80a1438:	4613      	mov	r3, r2
 80a143a:	b120      	cbz	r0, 80a1446 <__cxa_atexit+0x16>
 80a143c:	2002      	movs	r0, #2
 80a143e:	4629      	mov	r1, r5
 80a1440:	4622      	mov	r2, r4
 80a1442:	f3af 8000 	nop.w
 80a1446:	bd38      	pop	{r3, r4, r5, pc}
 80a1448:	00000000 	.word	0x00000000

080a144c <isspace>:
 80a144c:	4b03      	ldr	r3, [pc, #12]	; (80a145c <isspace+0x10>)
 80a144e:	681b      	ldr	r3, [r3, #0]
 80a1450:	4418      	add	r0, r3
 80a1452:	7840      	ldrb	r0, [r0, #1]
 80a1454:	f000 0008 	and.w	r0, r0, #8
 80a1458:	4770      	bx	lr
 80a145a:	bf00      	nop
 80a145c:	20000310 	.word	0x20000310

080a1460 <memcpy>:
 80a1460:	b510      	push	{r4, lr}
 80a1462:	1e43      	subs	r3, r0, #1
 80a1464:	440a      	add	r2, r1
 80a1466:	4291      	cmp	r1, r2
 80a1468:	d004      	beq.n	80a1474 <memcpy+0x14>
 80a146a:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a146e:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a1472:	e7f8      	b.n	80a1466 <memcpy+0x6>
 80a1474:	bd10      	pop	{r4, pc}

080a1476 <memset>:
 80a1476:	4603      	mov	r3, r0
 80a1478:	4402      	add	r2, r0
 80a147a:	4293      	cmp	r3, r2
 80a147c:	d002      	beq.n	80a1484 <memset+0xe>
 80a147e:	f803 1b01 	strb.w	r1, [r3], #1
 80a1482:	e7fa      	b.n	80a147a <memset+0x4>
 80a1484:	4770      	bx	lr

080a1486 <strcmp>:
 80a1486:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a148a:	f811 3b01 	ldrb.w	r3, [r1], #1
 80a148e:	2a01      	cmp	r2, #1
 80a1490:	bf28      	it	cs
 80a1492:	429a      	cmpcs	r2, r3
 80a1494:	d0f7      	beq.n	80a1486 <strcmp>
 80a1496:	1ad0      	subs	r0, r2, r3
 80a1498:	4770      	bx	lr

080a149a <strcpy>:
 80a149a:	4603      	mov	r3, r0
 80a149c:	f811 2b01 	ldrb.w	r2, [r1], #1
 80a14a0:	f803 2b01 	strb.w	r2, [r3], #1
 80a14a4:	2a00      	cmp	r2, #0
 80a14a6:	d1f9      	bne.n	80a149c <strcpy+0x2>
 80a14a8:	4770      	bx	lr

080a14aa <strlen>:
 80a14aa:	4603      	mov	r3, r0
 80a14ac:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a14b0:	2a00      	cmp	r2, #0
 80a14b2:	d1fb      	bne.n	80a14ac <strlen+0x2>
 80a14b4:	1a18      	subs	r0, r3, r0
 80a14b6:	3801      	subs	r0, #1
 80a14b8:	4770      	bx	lr

080a14ba <strncmp>:
 80a14ba:	b570      	push	{r4, r5, r6, lr}
 80a14bc:	b1a2      	cbz	r2, 80a14e8 <strncmp+0x2e>
 80a14be:	1e45      	subs	r5, r0, #1
 80a14c0:	3901      	subs	r1, #1
 80a14c2:	786b      	ldrb	r3, [r5, #1]
 80a14c4:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80a14c8:	1c6e      	adds	r6, r5, #1
 80a14ca:	42a3      	cmp	r3, r4
 80a14cc:	d106      	bne.n	80a14dc <strncmp+0x22>
 80a14ce:	f06f 0401 	mvn.w	r4, #1
 80a14d2:	1b64      	subs	r4, r4, r5
 80a14d4:	4414      	add	r4, r2
 80a14d6:	42e0      	cmn	r0, r4
 80a14d8:	d102      	bne.n	80a14e0 <strncmp+0x26>
 80a14da:	461c      	mov	r4, r3
 80a14dc:	1b18      	subs	r0, r3, r4
 80a14de:	bd70      	pop	{r4, r5, r6, pc}
 80a14e0:	4635      	mov	r5, r6
 80a14e2:	2b00      	cmp	r3, #0
 80a14e4:	d1ed      	bne.n	80a14c2 <strncmp+0x8>
 80a14e6:	e7f8      	b.n	80a14da <strncmp+0x20>
 80a14e8:	4610      	mov	r0, r2
 80a14ea:	bd70      	pop	{r4, r5, r6, pc}

080a14ec <_strtol_r>:
 80a14ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a14f0:	460f      	mov	r7, r1
 80a14f2:	4c40      	ldr	r4, [pc, #256]	; (80a15f4 <_strtol_r+0x108>)
 80a14f4:	f8d4 9000 	ldr.w	r9, [r4]
 80a14f8:	463d      	mov	r5, r7
 80a14fa:	f815 eb01 	ldrb.w	lr, [r5], #1
 80a14fe:	eb09 040e 	add.w	r4, r9, lr
 80a1502:	7866      	ldrb	r6, [r4, #1]
 80a1504:	f006 0408 	and.w	r4, r6, #8
 80a1508:	f004 06ff 	and.w	r6, r4, #255	; 0xff
 80a150c:	b10c      	cbz	r4, 80a1512 <_strtol_r+0x26>
 80a150e:	462f      	mov	r7, r5
 80a1510:	e7f2      	b.n	80a14f8 <_strtol_r+0xc>
 80a1512:	4674      	mov	r4, lr
 80a1514:	2c2d      	cmp	r4, #45	; 0x2d
 80a1516:	d103      	bne.n	80a1520 <_strtol_r+0x34>
 80a1518:	1cbd      	adds	r5, r7, #2
 80a151a:	787c      	ldrb	r4, [r7, #1]
 80a151c:	2601      	movs	r6, #1
 80a151e:	e003      	b.n	80a1528 <_strtol_r+0x3c>
 80a1520:	2c2b      	cmp	r4, #43	; 0x2b
 80a1522:	bf04      	itt	eq
 80a1524:	787c      	ldrbeq	r4, [r7, #1]
 80a1526:	1cbd      	addeq	r5, r7, #2
 80a1528:	b113      	cbz	r3, 80a1530 <_strtol_r+0x44>
 80a152a:	2b10      	cmp	r3, #16
 80a152c:	d10a      	bne.n	80a1544 <_strtol_r+0x58>
 80a152e:	e05a      	b.n	80a15e6 <_strtol_r+0xfa>
 80a1530:	2c30      	cmp	r4, #48	; 0x30
 80a1532:	d156      	bne.n	80a15e2 <_strtol_r+0xf6>
 80a1534:	782c      	ldrb	r4, [r5, #0]
 80a1536:	f004 04df 	and.w	r4, r4, #223	; 0xdf
 80a153a:	2c58      	cmp	r4, #88	; 0x58
 80a153c:	d14c      	bne.n	80a15d8 <_strtol_r+0xec>
 80a153e:	786c      	ldrb	r4, [r5, #1]
 80a1540:	2310      	movs	r3, #16
 80a1542:	3502      	adds	r5, #2
 80a1544:	2e00      	cmp	r6, #0
 80a1546:	bf14      	ite	ne
 80a1548:	f04f 4800 	movne.w	r8, #2147483648	; 0x80000000
 80a154c:	f06f 4800 	mvneq.w	r8, #2147483648	; 0x80000000
 80a1550:	fbb8 faf3 	udiv	sl, r8, r3
 80a1554:	2700      	movs	r7, #0
 80a1556:	46be      	mov	lr, r7
 80a1558:	fb03 881a 	mls	r8, r3, sl, r8
 80a155c:	eb09 0c04 	add.w	ip, r9, r4
 80a1560:	f89c c001 	ldrb.w	ip, [ip, #1]
 80a1564:	f01c 0f04 	tst.w	ip, #4
 80a1568:	d001      	beq.n	80a156e <_strtol_r+0x82>
 80a156a:	3c30      	subs	r4, #48	; 0x30
 80a156c:	e00b      	b.n	80a1586 <_strtol_r+0x9a>
 80a156e:	f01c 0c03 	ands.w	ip, ip, #3
 80a1572:	d01b      	beq.n	80a15ac <_strtol_r+0xc0>
 80a1574:	f1bc 0f01 	cmp.w	ip, #1
 80a1578:	bf0c      	ite	eq
 80a157a:	f04f 0c37 	moveq.w	ip, #55	; 0x37
 80a157e:	f04f 0c57 	movne.w	ip, #87	; 0x57
 80a1582:	ebcc 0404 	rsb	r4, ip, r4
 80a1586:	429c      	cmp	r4, r3
 80a1588:	da10      	bge.n	80a15ac <_strtol_r+0xc0>
 80a158a:	f1b7 3fff 	cmp.w	r7, #4294967295	; 0xffffffff
 80a158e:	d00a      	beq.n	80a15a6 <_strtol_r+0xba>
 80a1590:	45d6      	cmp	lr, sl
 80a1592:	d806      	bhi.n	80a15a2 <_strtol_r+0xb6>
 80a1594:	d101      	bne.n	80a159a <_strtol_r+0xae>
 80a1596:	4544      	cmp	r4, r8
 80a1598:	dc03      	bgt.n	80a15a2 <_strtol_r+0xb6>
 80a159a:	fb03 4e0e 	mla	lr, r3, lr, r4
 80a159e:	2701      	movs	r7, #1
 80a15a0:	e001      	b.n	80a15a6 <_strtol_r+0xba>
 80a15a2:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 80a15a6:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a15aa:	e7d7      	b.n	80a155c <_strtol_r+0x70>
 80a15ac:	1c7c      	adds	r4, r7, #1
 80a15ae:	4673      	mov	r3, lr
 80a15b0:	d10a      	bne.n	80a15c8 <_strtol_r+0xdc>
 80a15b2:	2e00      	cmp	r6, #0
 80a15b4:	f04f 0122 	mov.w	r1, #34	; 0x22
 80a15b8:	bf14      	ite	ne
 80a15ba:	f04f 4300 	movne.w	r3, #2147483648	; 0x80000000
 80a15be:	f06f 4300 	mvneq.w	r3, #2147483648	; 0x80000000
 80a15c2:	6001      	str	r1, [r0, #0]
 80a15c4:	b92a      	cbnz	r2, 80a15d2 <_strtol_r+0xe6>
 80a15c6:	e011      	b.n	80a15ec <_strtol_r+0x100>
 80a15c8:	b10e      	cbz	r6, 80a15ce <_strtol_r+0xe2>
 80a15ca:	f1ce 0300 	rsb	r3, lr, #0
 80a15ce:	b16a      	cbz	r2, 80a15ec <_strtol_r+0x100>
 80a15d0:	b107      	cbz	r7, 80a15d4 <_strtol_r+0xe8>
 80a15d2:	1e69      	subs	r1, r5, #1
 80a15d4:	6011      	str	r1, [r2, #0]
 80a15d6:	e009      	b.n	80a15ec <_strtol_r+0x100>
 80a15d8:	2430      	movs	r4, #48	; 0x30
 80a15da:	2b00      	cmp	r3, #0
 80a15dc:	d1b2      	bne.n	80a1544 <_strtol_r+0x58>
 80a15de:	2308      	movs	r3, #8
 80a15e0:	e7b0      	b.n	80a1544 <_strtol_r+0x58>
 80a15e2:	230a      	movs	r3, #10
 80a15e4:	e7ae      	b.n	80a1544 <_strtol_r+0x58>
 80a15e6:	2c30      	cmp	r4, #48	; 0x30
 80a15e8:	d1ac      	bne.n	80a1544 <_strtol_r+0x58>
 80a15ea:	e7a3      	b.n	80a1534 <_strtol_r+0x48>
 80a15ec:	4618      	mov	r0, r3
 80a15ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a15f2:	bf00      	nop
 80a15f4:	20000310 	.word	0x20000310

080a15f8 <strtol>:
 80a15f8:	b530      	push	{r4, r5, lr}
 80a15fa:	4605      	mov	r5, r0
 80a15fc:	460c      	mov	r4, r1
 80a15fe:	4613      	mov	r3, r2
 80a1600:	4a03      	ldr	r2, [pc, #12]	; (80a1610 <strtol+0x18>)
 80a1602:	4629      	mov	r1, r5
 80a1604:	6810      	ldr	r0, [r2, #0]
 80a1606:	4622      	mov	r2, r4
 80a1608:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 80a160c:	f7ff bf6e 	b.w	80a14ec <_strtol_r>
 80a1610:	20000374 	.word	0x20000374

080a1614 <dynalib_user>:
 80a1614:	080a001d 080a005d 080a0089 080a008d     ....]...........
 80a1624:	00000000 65766f6d 00310020 30300032     ....move .1.2.00
 80a1634:	766f6d00 00000065 00000000              .move.......

080a1640 <_ZTV7TwoWire>:
	...
 80a1648:	080a07ad 080a07f7 080a07cf 080a07af     ................
 80a1658:	080a07d7 080a07df 080a07e7 080a07ef     ................

080a1668 <_ZTV9IPAddress>:
	...
 80a1670:	080a086f 080a0861 080a0863 00000000     o...a...c.......

080a1680 <_ZTV8SPIClass>:
	...
 80a1688:	080a0a15 080a0a17 2b25005a 3a643330     ........Z.%+03d:
 80a1698:	75323025 2d592500 252d6d25 48255464     %02u.%Y-%m-%dT%H
 80a16a8:	3a4d253a 7a255325 63736100 656d6974     :%M:%S%z.asctime
	...

080a16c0 <_ZTV11USARTSerial>:
	...
 80a16c8:	080a0e3d 080a0e61 080a0e6d 080a0909     =...a...m.......
 80a16d8:	080a0e49 080a0e55 080a0e4f 080a0e5b     I...U...O...[...
 80a16e8:	080a0e3f 080a0e43                       ?...C...

080a16f0 <_ZTV9USBSerial>:
	...
 80a16f8:	080a0f21 080a0f5b 080a0f3b 080a0909     !...[...;.......
 80a1708:	080a0f33 080a0f23 080a0f29 080a0f57     3...#...)...W...
 80a1718:	080a0f2f 080a0f1d                       /.......

080a1720 <_ZTVN5spark9WiFiClassE>:
	...
 80a1728:	080a0fc7                                ....

080a172c <_ctype_>:
 80a172c:	20202000 20202020 28282020 20282828     .         ((((( 
 80a173c:	20202020 20202020 20202020 20202020                     
 80a174c:	10108820 10101010 10101010 10101010      ...............
 80a175c:	04040410 04040404 10040404 10101010     ................
 80a176c:	41411010 41414141 01010101 01010101     ..AAAAAA........
 80a177c:	01010101 01010101 01010101 10101010     ................
 80a178c:	42421010 42424242 02020202 02020202     ..BBBBBB........
 80a179c:	02020202 02020202 02020202 10101010     ................
 80a17ac:	00000020 00000000 00000000 00000000      ...............
	...
 80a182c:	00004300                                         .C.

080a182f <link_const_variable_data_end>:
	...

080a1830 <link_constructors_location>:
 80a1830:	080a03b9 	.word	0x080a03b9
 80a1834:	080a0689 	.word	0x080a0689
 80a1838:	080a06b9 	.word	0x080a06b9
 80a183c:	080a074d 	.word	0x080a074d
 80a1840:	080a077d 	.word	0x080a077d
 80a1844:	080a0831 	.word	0x080a0831
 80a1848:	080a08d9 	.word	0x080a08d9
 80a184c:	080a09e5 	.word	0x080a09e5
 80a1850:	080a0a49 	.word	0x080a0a49
 80a1854:	080a0a79 	.word	0x080a0a79
 80a1858:	080a0d65 	.word	0x080a0d65
 80a185c:	080a0d99 	.word	0x080a0d99
 80a1860:	080a0dc9 	.word	0x080a0dc9
 80a1864:	080a0ddd 	.word	0x080a0ddd
 80a1868:	080a0e0d 	.word	0x080a0e0d
 80a186c:	080a0fd1 	.word	0x080a0fd1
 80a1870:	080a1155 	.word	0x080a1155
 80a1874:	080a1185 	.word	0x080a1185
 80a1878:	080a11f5 	.word	0x080a11f5
 80a187c:	080a1225 	.word	0x080a1225
 80a1880:	080a12a1 	.word	0x080a12a1
 80a1884:	080a1365 	.word	0x080a1365

080a1888 <link_constructors_end>:
	...
